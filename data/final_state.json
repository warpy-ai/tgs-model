{
    "seeds": [],
    "task_descriptions": {
        "1": {
            "seed": "File operations",
            "description": "Write a Bash script to create a compressed archive (e.g., .tar.gz or .zip) of a specified directory, including its subdirectories and files, while excluding certain file types or patterns."
        },
        "2": {
            "seed": "text processing",
            "description": "Write a Bash script to extract the top 10 most frequently occurring words from a given text file, excluding common words like \"the\", \"a\", \"and\", etc."
        },
        "3": {
            "seed": "system administration",
            "description": "Write a Bash script to automate the process of taking regular backups of important system directories (e.g., /etc, /var/log) and rotating old backup files based on a specified retention period."
        },
        "4": {
            "seed": "network management",
            "description": "Write a Bash script to periodically check network interface status and send an email notification if any interface goes down."
        },
        "5": {
            "seed": "user management",
            "description": "Write a Bash script to add, modify, or delete user accounts on a Linux system, with options to set password expiration, home directory, and default shell."
        },
        "6": {
            "seed": "process management",
            "description": "Write a Bash script to list all running processes, sort them by CPU usage in descending order, and display the top 10 CPU-intensive processes along with their process IDs, CPU usage percentages, and command names."
        },
        "7": {
            "seed": "system monitoring",
            "description": "Write a Bash script to periodically check system load average and log CPU, memory, and disk space usage to a file if the load exceeds a specified threshold."
        },
        "8": {
            "seed": "automation tasks",
            "description": "Develop a Bash script to automate the backup process of a MySQL database, compressing the backup file and securely transferring it to a remote server via SFTP."
        },
        "9": {
            "seed": "backup and archiving",
            "description": "Write a Bash script to create a compressed archive (e.g., .tar.gz, .zip) of a specified directory and its contents, with the archive file named according to the current date and time."
        },
        "10": {
            "seed": "security and permissions.",
            "description": "Write a Bash script to scan a directory and its subdirectories for files with world-writable permissions, and then change the permissions to remove the world-writable attribute while preserving the existing user and group permissions."
        }
    },
    "commands": {
        "1": {
            "invocation": "Write a Bash script to create a compressed archive (e.g., .tar.gz or .zip) of a specified directory, including its subdirectories and files, while excluding certain file types or patterns.",
            "cmd": "To create a compressed archive (e.g., .tar.gz or .zip) of a specified directory, including its subdirectories and files, while excluding certain file types or patterns, you can use the following Bash script:\n\n```bash\n#!/bin/bash\n\n# Set the directory to archive\ndir_to_archive=\"/path/to/directory\"\n\n# Set the filename for the compressed archive\narchive_filename=\"archive.tar.gz\"\n\n# Set the patterns or file types to exclude (comma-separated)\nexclude_patterns=(\"*.log,*.tmp,*.swp\")\n\n# Navigate to the parent directory of the directory to archive\ncd \"$(dirname \"$dir_to_archive\")\"\n\n# Create the compressed archive, excluding specified patterns\ntar -czf \"$archive_filename\" --exclude=\"$dir_to_archive/{${exclude_patterns[*]}}\" \"$(basename \"$dir_to_archive\")\"\n```\n\nThis script performs the following steps:\n\n1. Set the directory to archive (`dir_to_archive`).\n2. Set the filename for the compressed archive (`archive_filename`).\n3. Set the patterns or file types to exclude (`exclude_patterns`).\n4. Change the current working directory to the parent directory of the directory to archive.\n5. Use the `tar` command to create a compressed archive file (`archive_filename`) in gzip format (`-cz`), excluding the specified patterns or file types (`--exclude`).\n\nTo use this script, save it to a file (e.g., `create_archive.sh`), make it executable with `chmod +x create_archive.sh`, and run it with `./create_archive.sh`.\n\nNote: Adjust the values of `dir_to_archive`, `archive_filename`, and `exclude_patterns` according to your specific requirements."
        },
        "2": {
            "invocation": "Write a Bash script to extract the top 10 most frequently occurring words from a given text file, excluding common words like \"the\", \"a\", \"and\", etc.",
            "cmd": "#!/bin/bash\n\n# List of common words to exclude\ncommon_words=\"a an and are as at be by but for from had have he her his how in is it its not of on or she that the their this to was we were what when which with\"\n\n# Read the file and convert to lowercase\nfile_contents=$(tr '[:upper:]' '[:lower:]' < \"$1\")\n\n# Remove punctuation and split into words\nwords=$(echo \"$file_contents\" | tr -c '[:alnum:] ' '[\\n*]')\n\n# Filter out common words\nfiltered_words=$(echo \"$words\" | tr ' ' '\\n' | grep -vwf <(echo \"$common_words\") | sort | uniq -c | sort -rn | head -n 10)\n\n# Print the top 10 most frequently occurring words\necho \"Top 10 most frequently occurring words:\"\necho \"$filtered_words\" | awk '{printf \"%5d %s\\n\", $1, $2}'"
        },
        "3": {
            "invocation": "Write a Bash script to automate the process of taking regular backups of important system directories (e.g., /etc, /var/log) and rotating old backup files based on a specified retention period.",
            "cmd": "```bash\n#!/bin/bash\n\n# Define directories to backup\nbackup_dirs=(\"/etc\" \"/var/log\")\n\n# Define backup destination directory\nbackup_dest=\"/path/to/backup/directory\"\n\n# Define retention period in days\nretention_period=30\n\n# Get current date for backup filename\nbackup_date=$(date +%Y%m%d)\nbackup_filename=\"backup_${backup_date}.tar.gz\"\n\n# Create backup file\ntar -czf \"${backup_dest}/${backup_filename}\" \"${backup_dirs[@]}\"\n\n# Remove old backup files based on retention period\nfind \"${backup_dest}\" -maxdepth 1 -name 'backup_*.tar.gz' -mtime +\"${retention_period}\" -delete\n```\n\nThis script performs the following actions:\n\n1. Defines the directories to be backed up (`/etc` and `/var/log`) in the `backup_dirs` array.\n2. Defines the destination directory for the backups (`/path/to/backup/directory`).\n3. Defines the retention period for old backups (30 days).\n4. Generates the current date and creates a backup filename with the format `backup_YYYYMMDD.tar.gz`.\n5. Creates a compressed tar archive (`tar -czf`) of the specified directories in the backup destination directory, using the generated filename.\n6. Removes old backup files from the backup destination directory based on the specified retention period (`find ... -mtime +\"${retention_period}\" -delete`).\n\nThis script should be scheduled to run periodically (e.g., daily or weekly) using a tool like `cron` to automate the backup process."
        },
        "4": {
            "invocation": "Write a Bash script to periodically check network interface status and send an email notification if any interface goes down.",
            "cmd": "#!/bin/bash\n\n# Check network interface status\ninterfaces=$(ip link show | awk -F': ' '/state/ {print $2}')\n\n# Set recipient email address\nrecipient=\"admin@example.com\"\n\n# Loop through interfaces and check status\nfor interface in $interfaces; do\n    status=$(echo $interface | cut -d' ' -f1)\n    if [ \"$status\" != \"UP\" ]; then\n        # Send email notification if any interface is down\n        subject=\"Network Interface Down: $interface\"\n        message=\"The network interface $interface is down.\"\n        echo \"$message\" | mail -s \"$subject\" \"$recipient\"\n    fi\ndone"
        },
        "5": {
            "invocation": "Write a Bash script to add, modify, or delete user accounts on a Linux system, with options to set password expiration, home directory, and default shell.",
            "cmd": "Here's a Bash script that accomplishes the task of adding, modifying, or deleting user accounts on a Linux system, with options to set password expiration, home directory, and default shell:\n\n```bash\n#!/bin/bash\n\n# Function to print usage instructions\nusage() {\n  echo \"Usage: $0 [options] [username]\"\n  echo \"Options:\"\n  echo \"  -a, --add           Add a new user\"\n  echo \"  -m, --modify        Modify an existing user\"\n  echo \"  -d, --delete        Delete an existing user\"\n  echo \"  -p, --password      Set or change user password\"\n  echo \"  -e, --expire        Set password expiration date (YYYY-MM-DD)\"\n  echo \"  -h, --home          Set home directory\"\n  echo \"  -s, --shell         Set default shell\"\n  exit 1\n}\n\n# Parse command-line options\nwhile [[ $# -gt 0 ]]; do\n  case \"$1\" in\n    -a|--add)\n      ADD=true\n      shift\n      ;;\n    -m|--modify)\n      MODIFY=true\n      shift\n      ;;\n    -d|--delete)\n      DELETE=true\n      shift\n      ;;\n    -p|--password)\n      PASSWORD=true\n      shift\n      ;;\n    -e|--expire)\n      EXPIRE=\"$2\"\n      shift 2\n      ;;\n    -h|--home)\n      HOME=\"$2\"\n      shift 2\n      ;;\n    -s|--shell)\n      SHELL=\"$2\"\n      shift 2\n      ;;\n    -*)\n      echo \"Invalid option: $1\"\n      usage\n      ;;\n    *)\n      USERNAME=\"$1\"\n      shift\n      ;;\n  esac\ndone\n\n# Check if a username is provided\nif [ -z \"$USERNAME\" ]; then\n  echo \"Error: Username not provided.\"\n  usage\nfi\n\n# Add a new user\nif [ \"$ADD\" = true ]; then\n  useradd -m \"$USERNAME\"\n  if [ -n \"$PASSWORD\" ]; then\n    passwd \"$USERNAME\"\n  fi\n  if [ -n \"$EXPIRE\" ]; then\n    chage -E \"$EXPIRE\" \"$USERNAME\"\n  fi\n  if [ -n \"$HOME\" ]; then\n    usermod -d \"$HOME\" -m \"$USERNAME\"\n  fi\n  if [ -n \"$SHELL\" ]; then\n    usermod -s \"$SHELL\" \"$USERNAME\"\n  fi\nfi\n\n# Modify an existing user\nif [ \"$MODIFY\" = true ]; then\n  if [ -n \"$PASSWORD\" ]; then\n    passwd \"$USERNAME\"\n  fi\n  if [ -n \"$EXPIRE\" ]; then\n    chage -E \"$EXPIRE\" \"$USERNAME\"\n  fi\n  if [ -n \"$HOME\" ]; then\n    usermod -d \"$HOME\" -m \"$USERNAME\"\n  fi\n  if [ -n \"$SHELL\" ]; then\n    usermod -s \"$SHELL\" \"$USERNAME\"\n  fi\nfi\n\n# Delete an existing user\nif [ \"$DELETE\" = true ]; then\n  userdel -r \"$USERNAME\"\nfi\n```\n\nThis script provides the following functionality:\n\n- Add a new user account with options to set password, password expiration date, home directory, and default shell\n- Modify an existing user account with options to change password, password expiration date, home directory, and default shell\n- Delete an existing user account and their home directory\n\nThe script uses command-line options to specify the desired action and additional options. Run the script with the `-h` or `--help` option to see the usage instructions."
        },
        "6": {
            "invocation": "Write a Bash script to list all running processes, sort them by CPU usage in descending order, and display the top 10 CPU-intensive processes along with their process IDs, CPU usage percentages, and command names.",
            "cmd": "ps aux --sort=-pcpu | head -n 11 | awk 'NR>1 {printf \"%5d %5s%% %s\\n\", $2, $3, $11}'"
        },
        "7": {
            "invocation": "Write a Bash script to periodically check system load average and log CPU, memory, and disk space usage to a file if the load exceeds a specified threshold.",
            "cmd": "Here's a Bash script that accomplishes the given task:\n\n```bash\n#!/bin/bash\n\n# Set the load average threshold\nload_threshold=1.0\n\n# Set the log file path\nlog_file=\"/var/log/system_load.log\"\n\n# Function to log system resource usage\nlog_usage() {\n    echo \"$(date): Load Average: $1\" >> \"$log_file\"\n    echo \"CPU Usage: $(top -bn1 | grep \"Cpu(s)\" | awk '{print $2 + $4 \"%\"}')\" >> \"$log_file\"\n    echo \"Memory Usage: $(free -m | awk 'NR==2{printf \"%.2f%%\\n\", $3*100/$2 }')\" >> \"$log_file\"\n    echo \"Disk Usage: $(df -h | awk '$NF==\"/\"{printf \"%s\\t%s\\t%s\\n\", $5, $6, $1}')\" >> \"$log_file\"\n    echo \"\" >> \"$log_file\"\n}\n\n# Continuously check system load average\nwhile true; do\n    load_avg=$(uptime | awk -F'[a-z]:' '{ print $2 }')\n    if (( $(echo \"$load_avg > $load_threshold\" | bc -l) )); then\n        log_usage \"$load_avg\"\n    fi\n    sleep 60  # Check every 60 seconds\ndone\n```\n\nThis script does the following:\n\n1. Sets the load average threshold to 1.0 (adjust as needed).\n2. Defines the log file path (`/var/log/system_load.log`).\n3. Defines a function `log_usage` that logs the current load average, CPU usage, memory usage, and disk usage to the log file.\n4. Enters an infinite loop that checks the system load average every 60 seconds.\n5. If the load average exceeds the specified threshold, it calls the `log_usage` function to log the system resource usage.\n\nThe script uses various Linux commands like `uptime`, `top`, `free`, `df`, `awk`, and `bc` to retrieve and format the required system resource information.\n\nNote: You might need to run this script with sudo privileges or modify the log file path to a writable location for non-root users."
        },
        "8": {
            "invocation": "Develop a Bash script to automate the backup process of a MySQL database, compressing the backup file and securely transferring it to a remote server via SFTP.",
            "cmd": "#!/bin/bash\n\n# Define database credentials\nDB_USER=\"your_db_username\"\nDB_PASS=\"your_db_password\"\nDB_NAME=\"your_db_name\"\n\n# Define remote server details\nREMOTE_HOST=\"remote_server_address\"\nREMOTE_USER=\"remote_server_username\"\nREMOTE_PATH=\"/path/to/backup/destination\"\n\n# Define backup file name with timestamp\nBACKUP_FILE=\"$DB_NAME-$(date +%Y%m%d-%H%M%S).sql.gz\"\n\n# Backup the database and compress the file\nmysqldump -u $DB_USER -p$DB_PASS $DB_NAME | gzip > $BACKUP_FILE\n\n# Transfer the backup file to the remote server via SFTP\nsftp -oStrictHostKeyChecking=no $REMOTE_USER@$REMOTE_HOST <<EOF\nput $BACKUP_FILE $REMOTE_PATH\nEOF\n\n# Remove the local backup file after successful transfer\nrm $BACKUP_FILE"
        },
        "9": {
            "invocation": "Write a Bash script to create a compressed archive (e.g., .tar.gz, .zip) of a specified directory and its contents, with the archive file named according to the current date and time.",
            "cmd": "#!/bin/bash\n\n# Get the current date and time\nNOW=$(date +\"%Y%m%d_%H%M%S\")\n\n# Ask the user for the directory to archive\nread -p \"Enter the directory to archive: \" DIR_TO_ARCHIVE\n\n# Create the archive with the current date and time as the filename\ntar -czf \"$DIR_TO_ARCHIVE\"_\"$NOW\".tar.gz \"$DIR_TO_ARCHIVE\""
        },
        "10": {
            "invocation": "Write a Bash script to scan a directory and its subdirectories for files with world-writable permissions, and then change the permissions to remove the world-writable attribute while preserving the existing user and group permissions.",
            "cmd": "#!/bin/bash\n\nfind /path/to/directory -type f -perm /022 -print0 | xargs -0 chmod o-w"
        }
    }
}
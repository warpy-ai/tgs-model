Compare *.csv files in the current directory tree with their analogs stored in /some/other/path/ </s> find . -name "*.csv" -exec diff {} /some/other/path/{} ";" -print
display all html files  in  current folder </s> find -name "*.htm" -print
Find directories in the current directory tree that were modified within the last 24 hours and move them to /path/to/target-dir </s> find . -type d -mtime -0 -print0 | xargs -0 mv -t /path/to/target-dir
Search the system for *.rpm files ignoring removable media </s> find / -xdev -name \*.rpm
find all foo.bar files in the entire file system </s> find / -name foo.bar -print
create backup of all the text files  present in the current folder </s> find -name "*.txt" cp {} {}.bkup \;
Print unique lines of sorted file "A.txt" compared to sorted file "B.txt" </s> comm -2 -3 <(sort A.txt) <(sort B.txt)
Find recursively the latest modified file in the current directory </s> find . -type f -print0 | xargs -0 ls -ltr | tail -n 1
Compose filepath as folder path where file $f is located, and lowercase filename of $f file, and save it in 'g' variable </s> g=`dirname "$f"`/`basename "$f" | tr '[A-Z]' '[a-z]'`
Search  in current directory downwards all files which  have not been accessed since last 7 days </s> find . -atime +7 -print
Search for Subscription.java under current directory, and go to directory containing it. </s> cd "$(find . -name Subscription.java -printf '%h\n')"
Represent the current time as seconds since epoch and save it to variable 'TODAY' </s> TODAY=$(date  -d "$(date +%F)" +%s)
delete all the mp3 files in the current folder. </s> find . -type f -name "*.mp3" -exec rm -f {} \;
Find files in the current directory tree that have one link </s> find . -links 1
search for the regular/normal file 'myfile' in the folder /root excluding those that are present in the /root/work directory </s> find /root/ -path '/root/work' -prune -o -name myfile -type f -print
Clears terminal screen. </s> echo `clear`
display all the files having the word "searched phrasse" in their name in the current folder excluding those from the paths "/tmp/" and "./var/log" </s> find . -type f -name "*searched phrasse*" ! -path "./tmp/*" ! -path "./var/log/*"
find md5sum of content from "www.google.com" </s> curl -s www.google.com | md5
Find all directories named 'mydir' under 'local' and '/tmp' directory tree </s> find local /tmp -name mydir -type d -print
Finds out what groups a current user has. </s> groups
Resolve symbolic link of file "FILE" even if the file does not exist </s> readlink -m FILE
Recursively finds all files not like *.itp, *ane.gro, *.top in a current folder and removes them. </s> find . -depth -type f -not -name *.itp -and -not -name *ane.gro -and -not -name *.top -exec rm '{}' +
Search for the files that are owned by user rooter or by user www-data </s> find -user root -o -user www-data
Get a list of directories owned by group ID 100 </s> find / -type d -gid  100
Show all variables whose name or value contains "PATH", sorted in reverse alphabetical order. </s> env | uniq | sort -r | grep PATH
Open a local SSH port on 1080 for application-level port forwarding </s> ssh -D1080 root@localhost -g
Print content of each file under the current directory followed by that file name </s> find . -type f -exec cat {} \; -print
Recursively copies everything under the 'current' folder to the '.hiddendir' folder. </s> cp * .hiddendir -R
Check if "~/mnt/sdc1" is mounted </s> mount | grep -q ~/mnt/sdc1
Replace all instances of "STRING_TO_REPLACE" with "STRING_TO_REPLACE_IT" in "index.html" and write the output to standard output and "index.html" </s> sed s/STRING_TO_REPLACE/STRING_TO_REPLACE_IT/g index.html | tee index.html
Pipe output of "yes" to "more" and append the first 3 lines to "file" </s> yes | awk 'FNR<4 {print >>"file"; close("file")}  1' | more
download file  "https://raw.githubusercontent.com/creationix/nvm/v0.31.0/install.sh" and execute it </s> curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.31.0/install.sh | bash
Find regular files readable by the world </s> find . -perm -g=r -type f -exec ls -l {} \;
Find *.html files in the current directory tree that were last modified more than 7 days ago </s> find . -mtime +7 -name "*.html" -print
Find all files named "file.ext" in the current directory tree and print the path names of the directories they are in </s> find `pwd` -name file.ext |xargs -l1 dirname
Convert the content of variable 'CLEAN' to small letters </s> CLEAN=`echo -n $CLEAN | tr A-Z a-z`
Find all files/directories under current directory tree that start with 'test' in their names without descending into directories with the same name pattern </s> find . -name 'test*' -prune
Search the current directory and two levels below for file `teste.tex' </s> find ~/ -maxdepth 3 -name teste.tex
Find all broken symlinks under current directory </s> find ./ -type l -exec file {} \; |grep broken
Compose filepath as folder path where file $SRC is located, and lowercase filename of $SRC file, and save it in 'DST' variable </s> DST=`dirname "${SRC}"`/`basename "${SRC}" | tr '[A-Z]' '[a-z]'`
Display the mimetype of "filename" </s> file -i filename
list any files modified since /bin/sh was last modified </s> find . -newer /bin/sh
Find all files/directories with spaces in their names under ~/Library directory </s> find ~/Library -name '* *'
Report file system '/dev/disk0s2' disk usage </s> df | grep /dev/disk0s2
Report file system containing path to /dir/inner_dir/ disk usage human-readable. </s> df -h /dir/inner_dir/
find all the files in the folder ~/Music which begin with "Automatically Add" </s> find ~/Music/ -name "Automatically Add*"
Find all files/directories under '/usr/local/games' directory tree that contain the string 'xpilot' in their names </s> find /usr/local/games -name "*xpilot*"
copy the file header.shtml to those dirs </s> find dir1 dir2 dir3 dir4 -type d -exec cp header.shtml {} \;
Find all directories under current directory with 755 permission and change their permission to 644 </s> find . -perm 755 -exec chmod 644 {} \;
Calculate the md5sum of the executable file of command "cc" </s> md5sum $(which cc)
Find all files/directories with '.c' or '.h' extension under current directory tree and search for the regex provided by first positional argument and show the output by paging through one screenful at a time </s> find . -name '*.[ch]' | xargs grep $1 | less
List all crons in the environment </s> cat /etc/passwd | sed 's/^\([^:]*\):.*$/crontab -u \1 -l 2>\&1/' | grep -v "no crontab for" | sh
display all the tex files in the current folder </s> find . -name "*.tex"
display all the files in current folder which have been accessed in the last 15 days </s> find . -atime -15
Make a directory in the current working directory with a random 32 alphanumeric character name </s> mkdir $(cat /dev/urandom | tr -dc 'a-zA-Z0-9' | fold -w 32 | head -n 1)
Make directories "$@" verbosely and replace "mkdir: created directory " with "jar-jar: yea, weesa gotta " in the output </s> mkdir -v "$@" | sed 's/mkdir: created directory /jar-jar: yea, weesa gotta /'
Count number of lines in "Sample_51770BL1_R1.fastq.gz" </s> zcat Sample_51770BL1_R1.fastq.gz | wc -l
create a backup of all the files in the current folder to the floppy and save the file list in the file /tmp/BACKUP.LOG </s> find . -cpio /dev/fd0 -print | tee /tmp/BACKUP.LOG
Remove all vmware-*.log files/directories under current directory </s> find . -name vmware-*.log | xargs -i rm -rf {}
Print out all files with their paths that have identical content and the same filename in different cases </s> find * -type f  | xargs md5sum | sort | uniq -Dw32 | awk -F'[ /]' '{ print $NF }' | sort -f | uniq -Di
Find all directories at level 3 of directory tree $from_dir </s> find $from_dir -mindepth 3 -maxdepth 3 -type d
Delete all MP3 files under /tmp </s> find /tmp -iname '*.mp3' -print0 | xargs -0 rm
display all the header files  and cpp files in the current folder </s> find \( -name '*.cpp' -o -name '*.h' \) -print
Remove all files with names like "vmware-*.log" from the current directory tree </s> find . -name vmware-*.log | xargs -i rm -rf {}
Get domain name with 'google' from dig reverse lookup. </s> dig -x 8.8.8.8| awk '/PTR[[:space:]]/ && /google/ {print $NF}'
Search for 'It took' in all $srch1* (case insensitive) files under current directory and run the sed script 'N;s/(.*)\n(.*)/\2 \1/' on the output </s> find . -iname "$srch1*" -exec grep "It took" {} \; -print |sed -r 'N;s/(.*)\n(.*)/\2 \1/'
Remove all regular files from the current directory tree whose names do not end with "ignore1" or "ignore2" </s> find . -type f -not -name '*ignore1' -not -name '*ignore2' | xargs rm
find all the files in the entire file system which belong to the group "staff" </s> find / -group staff -print
Output the string 'yes' continously until killed </s> yes
Print the files in the current directory as a list of semicolon separated values </s> ls -m | tr -d ' ' | tr ',' ';'
Save in QUEUE_PIDS variable only pid numbers that stored in $NEW_PIDS variable </s> QUEUE_PIDS=$(comm -23 <(echo "$NEW_PIDS" | sort -u) <(echo "$LIMITED_PIDS" | sort -u) | grep -v '^$')
Show files in /home owned by group `test' </s> find /home -group test
Recursively list all the files and directories that are only in directory /dir1 with their full paths. </s> diff -rq /dir1 /dir2 | grep -E "^Only in /dir1.*" | sed -n 's/://p' | awk '{print $3"/"$4}'
List common files in directories "1" and "2" </s> cat <(ls 1 | sort -u) <(ls 2 | sort -u) | uniq -d
Remove regular files whose names match Perl regular expression '\w+-\d+x\d+\.\w+$' from the current directory tree </s> find -type f |  grep -P '\w+-\d+x\d+\.\w+$' | xargs rm
Recursively set all permissions under "/folder" to 755 </s> chmod 755 /folder -R
Saves location of file $1 in 'dir' variable. </s> dir=$(dirname -- "$1")
Find all *.c files under and below the current directory that contain "wait_event_interruptible" </s> find . -name \*.c -exec grep wait_event_interruptible {} /dev/null \;
create directory /tmp/foo </s> mkdir /tmp/foo
Recursively finds all files containing text 'OPEN' and prints folder where they are placed. </s> grep -r OPEN * | awk '{split($1, path, ":"); print path[1]}' | xargs -I{} dirname {}
find all the files that were modified yesterday in the current directory. </s> find . -daystart -ctime 0 -type f
Find all files under foldername directory and set their permission to 644 </s> sudo find foldername -type f -exec chmod 644 {} ";"
find Texinfo source files in /usr/local/doc </s> find foo -path foo/bar -print
Remove trailing white spaces from all files under current directory ignoring .git, .svn directories and binary files </s> find . -not \( -name .svn -prune -o -name .git -prune \) -type f -print0 | xargs -0 file -In | grep -v binary | cut -d ":" -f1 | xargs -0 sed -i '' -E "s/[[:space:]]*$//"
Write out the entire directory hierarchy from the current directory </s> find . -print
find all the directories in the current folder and create the same directory structure in a remote machine using ssh </s> find -type d | ssh server-B 'xargs -I% mkdir -p "/path/to/dir/%"'
Remove duplicate lines in "file_name" and print the output on stdout </s> awk '{print(NR"\t"$0)}' file_name | sort -t$'\t' -k2,2 | uniq --skip-fields 1 | sort -k1,1 -t$'\t' | cut -f2 -d$'\t'
Find regular files that are larger than 2GB </s> find . -type f -size +2G
Merge each line in "file" into a single comma separated line </s> paste -d, -s file
find all the files that have been modified since the last time we checked </s> find /etc -newer /var/log/backup.timestamp -print
Remove all files except the ones listed in "MANIFEST" </s> find -type f -printf %P\\n | sort | comm -3 MANIFEST - | xargs rm
Remove all .sh files in the current directory tree whose names begin with "new" </s> find . -name "new*.sh" -exec rm -f '{}' \;
Change permissions to u=rwx,g=rx,o= for all directories inside the current directory tree </s> find . -type d -exec chmod u=rwx,g=rx,o= '{}' \;
Sort the lines of the file 'temp.txt' and change it in-place </s> sort temp.txt -o temp.txt
Finds shell options like 'checkjobs' with their state. </s> shopt -p | grep checkjobs
Print the directory name of the physical current working directory </s> dirname `pwd -P`
display all the regular/ normal files in a folder </s> find src/js -type f
Format "$line" as a table </s> echo "$line" | column -t
Add variable TESTVAR with value "bbb" to a temporary environment, and search for TESTVAR in all variables and their values in the resulting environment. </s> TESTVAR=bbb env | fgrep TESTVAR
find all the perl files in /var/www ( case insensitive search ) </s> find /var/www/ -type f -iname "*.pl" -print
Print only group names from /etc/group. </s> cut -d: -f1 /etc/group
Print a welcome message with the current user's user name </s> echo "Welcome `whoami`!"
Show the list of user wnj's files that are newer than file `ttt' </s> find / -newer ttt -user wnj -print
search for files named "WSFY321.c" in a case-insensitive manner </s> find . -iname "WSFY321.c"
Prints shell option 'globstar' with indication of its status. </s> shopt -p globstar
Execute command "$cmd_str" on host "$SERVER" as user "$USER" </s> ssh "$USER@$SERVER" "$cmd_str"
Remount "yaffs2" filesystem "/dev/block/mtdblk4" to "/system" as read and write only </s> mount -o rw,remount -t yaffs2 /dev/block/mtdblk4 /system
Find all read only files in  /home directory </s> find /home -type f -perm /u=r
Serach  in root directory all files which  have more than 2 links. </s> find / -links +2 -print
find -name '*.js' -not -path './node_modules/*' -not -path './vendor/*' </s> find -name '*.js' -not \( -path './node_modules/*' -o -path './vendor/*' \)
List all files and directories in the /home directory tree whose names are "Trash" </s> find /home -name Trash -exec ls -al {} \;
create and list filenames in the archive </s> tar cf - $PWD|tar tvf -|awk '{print $6}'|grep -v "/$"
Find all the files without permission 777 </s> find / -type f ! -perm 777
Find all foo.mp4 files in the current directory tree and print the pathnames of their parent directories </s> find . -name foo.mp4 -exec dirname {} \;
Search for files whose name is "filename" and whose permissions are 777 </s> find / -perm 777 -iname "filename"
Find all files/directories under _CACHE_* directories </s> find _CACHE_*
Inserts "new line" after last occurrence of ScriptAlias in a file </s> tac file | awk '/ScriptAlias/ && ! seen {print "new line"; seen=1} {print}' | tac
Find all files/directories containing the case insensitive string something' in their names under current directory tree </s> find . -iname '*something*'
Search the current directory tree for directories </s> find $PWD -type d
Print content of 'whatever' file </s> cat whatever | egrep 'snozzberries|$'
Search for 'mystring' in all *.txt files under current directory </s> find . -name '*.txt' | xargs egrep mystring
Extract path and query part from URL </s> echo "$url" | cut -d'/' -f4-
Prints path to folder that contains file "/path/to/vm.vmwarevm/vm.vmx". </s> echo /path/to/vm.vmwarevm/vm.vmx | xargs dirname
Find all files/directories under $1 which have at least write permission for their owner and set write permission for group for these files/directories </s> find $1 -perm -u+w -exec chmod g+w {} \;
Creates temporary file in $appdir variable with name formatted like expression in variable ${template}, and saves path to it in 'launcherfile' variable. </s> launcherfile=$(mktemp -p "$appdir" "$template")
Find all .txt files under the current directory and below </s> find . -name '*.txt' -print0
Remove the last 2 tab-separated fields of each line in file pointed to by filename </s> cat $filename | rev | cut -c 3- | rev
Create symbolic link "$1/link" to the absolute path of "$2" </s> ln -s "$(readlink -e "$2")" "$1/link"
find all the files in the folder "/usr/app/etl/01/OTH/log/tra" which have been modified  in the last 240 hours  excluding hidden files and those with the name "/usr/app/etl/01/CLE/par/files_to_skip.par" </s> find /usr/app/etl/01/OTH/log/tra -type f ! -name ".*" -mtime -10 | egrep -vf /usr/app/etl/01/CLE/par/files_to_skip.par
Create a ssh key with no passphrase and store it in "outfile". </s> ssh-keygen -f outfile -N ''
Copies file 'index.html' to each top-level directory in the current directory beginning with 'd'. </s> find . -mindepth 1 -maxdepth 1 -type d| grep \/a |xargs -n 1 cp -i index.html
Print the last 10 lines of '/var/log/syslog', printing out any additional data appended to the file </s> tail -f /var/log/syslog
Find all files you have modified in the last two days </s> find ~ -type f -mtime -2
Look in the current directory and below for all files whose names begin with either "my" or "qu" </s> find . \( -name "my*" -o -name "qu*" \) -print
Search directories /res/values-en-rUS and /res/xml for XML files </s> find /res/values-en-rUS /res/xml -iname '*.xml'
Find all C source code files from the current directory tree that contain "keyword" in their pathnames, ignoring the case </s> find . -type f \( -iname “*.c” \) |grep -i “keyword”
Find all directories under current directory </s> find . -type d -print
Find all image.pdf files under ./polkadots </s> find ./polkadots -type f -name "image.pdf"
find directories in the folder /usr/spool/uucp </s> find /usr/spool/uucp -type d -print
Find all your jsp's, map them to your localhost webserver, and invoke a wget (fetch) on them </s> find -name \*.jsp | sed 's/^/http:\/\/127.0.0.1/server/g' | xargs -n 1 wget
Archive "source" to "destination" via ssh on port "PORT_NUMBER" </s> rsync -azP -e "ssh -p PORT_NUMBER" source destination
Find files/directories that does not have write permssion for group </s> find /path ! -perm /020
Change permissions of ".bash_logout", ".bashrc", and ".profile" to 444 </s> chmod 444 .bash_logout .bashrc .profile
Find all .gz archives in the current directory tree and check if they are valid </s> find . -name *.gz -exec gunzip '{}' \;
Count the number of times that a single "-----------\n" separated record contains both "A=2" and "dummy=2" and the number of records that do not have "dummy=2" in compressed file "file.gz" </s> zcat file.gz | awk -v RS="-----------\n" '/A=2[ ,\n]/ && /dummy=2[ ,\n]/{count++} !/dummy=2[ ,\n]/{other++} END{print "Final counter value=",count, "; other=", other}'
find all the regular/normal files in the folder /travelphotos which are bigger than 200KB and which do not have the word "2015" in their name </s> find /travelphotos -type f -size +200k -not -iname "*2015*"
Search the current directory for PHP files </s> find . -type f -name "*.php"
Find all files that contain the case insensitive regex 'stringtofind' in maximum 1 level down the / directory without descending into other partitions </s> find / -maxdepth 1 -xdev -type f -print -exec grep -i "stringtofind" -q {} \;
Update timestamps of all regular files (ie. excluding directories, symlinks, sockets, etc.) under /your/dir </s> find /your/dir -type f -exec touch {} +
Print file type of the executable file of command "file" </s> which file | file -f -
Finds strings with text "text" in all files named "string to be searched" recursively in a current folder. </s> find . -name "string to be searched" -exec grep "text" "{}" \;
change the permission of all the directories to 755 in the current folder </s> find -type d -exec chmod 755 {} \;
Search for 'class Pool' in all *.java (case insensitive) files under current directory </s> find -iname '*.java'|xargs grep 'class Pool'
Print the names of any differing files in directories "dir1/" and "dir2/" </s> diff  --brief --recursive dir1/ dir2/
Find files starting with the word "file" in the current directory tree, ignoring the case </s> find . -iname "file*"
search for version in system.info files. </s> find /home/*/public_html/ -type f -iwholename "*/modules/system/system.info" -exec grep -H "version = \"" {} \;
Make directories to "x/p/q" as needed </s> mkdir -p x/p/q
Write "hello world" to the console and print number of bytes, symbols and strings in provided input. </s> echo "hello world" | tee >(wc)
Find all *.txt files/directories under current directory discarding 'Permission denied' errors </s> find . -name "*.txt" -print | grep -v 'Permission denied'
List .conf files residing in the /etc/nginx/ directory tree </s> find /etc/nginx -name '*.conf' -exec echo {} ;
Prints the day of last Friday in a current month. </s> cal | awk '$6{date=$6}END{print date}'
Find all .java files  under current directory </s> find . -print | grep '\.java'
Count the number of lines in every regular .rb file in the current directory tree </s> find . -name "*.rb" -type f -print0 | xargs -0 wc -l
Search for the regex $greppattern in all files with '.c' or '.h' extension under $searchpath with name pattern $filepat and show the matched line numbers, file names and matched lines </s> find "$searchpath" -name "$filepat.[ch]" -exec grep --color -aHn "$greppattern" {} \;
Search for the regex "\$wp_version =" in all the regular files that end with '/wp-includes/version.php' (case insensitive) in their paths in directories/files taken from the glob pattern '/var/www/vhosts/*/httpdocs' and show the matched lines along with the file names </s> find /var/www/vhosts/*/httpdocs -type f -iwholename "*/wp-includes/version.php" -exec grep -H "\$wp_version =" {} \;
Rename all .html files to .txt </s> rename 's/\.html$/\.txt/' *.html
Print disk of mount point "/pa/th" </s> mount | awk '$3 == "/pa/th" {print $1}'
Set the permissions of all directories inside the current directory tree to ug=rwx,o= </s> find . -type d -name files -exec chmod ug=rwx,o= '{}' \;
find all the files in the entire filesystem which belong to the user root and display the ten files. </s> find / -user root | head
display all the header files  and cpp files in the current folder </s> find . -name \*.h -print -o -name \*.cpp -print
Find all directories under /home/username/public_html/sites/all/modules and set their permission to 750 </s> find /home/username/public_html/sites/all/modules -type d -exec chmod 750 {} +
find all the text files in the folder /home/calvin which are atleast below 2 levels </s> find /home/calvin/ -mindepth 2  -name “*.txt”
Replace all negative numbers in the 3rd comma-separated column of inputfile by the number notated in parenthesis instead of with a minus sign. </s> awk -F, 'BEGIN {OFS = ","} {gsub("-([0-9.]+)", "(" substr($3, 2) ")", $3); print}' inputfile
Gets IP address of 'en0' network interface. </s> ifconfig en0 | awk '/inet addr/{print substr($2,6)}'
Print the characters in $b that match with any character in $a without printing any newline </s> echo "$b" | grep -o "[$a]" | tr -d '\n'
Display current running kernel's compile-time config file. </s> cat /boot/config-`uname -r`
Forward all connections to client localhost 3309 via the SSH tunnel to "mysql_access_server" and then connect to host "sqlmaster.example.com" on port 3306 </s> ssh -f mysql_access_server -L 3309:sqlmaster.example.com:3306 -N
Disables shell option 'nullglob'. </s> shopt -u nullglob
Find all .zip files in the current directory tree </s> find . -depth -name *.zip
Find regular files named "regex" under and below /dir/to/search/ </s> find /dir/to/search/ -type f -name 'regex' -print
Find all SGID files </s> find / -perm /g=s
Search the current directory tree for all files matching pattern "*.rb" </s> find . -name "*.rb"
Make directories a, b, c, ..., z under path2 as needed. </s> mkdir -p path2/{a..z}
Use "$BYTES" amount of RAM with no output </s> yes | tr \\n x | head -c $BYTES | grep n
Prints file descriptor of executed built-in 'true'. </s> echo <(true)
Find files in the current directory tree of size between 700k and 1000k </s> find . \( -size +700k -and -size -1000k \)
find all the log files in the file system </s> find / -name "*.log"
Search /usr/bin for regular files that were last accessed more than 100 days ago </s> find /usr/bin -type f -atime +100
Silently read exactly 1 character ignoring any delimiters  into variable "SELECT" </s> read -s -N 1 SELECT
Find all regular files starting from level 3 of directory tree ~/container and move them to the current directory </s> find ~/container  -mindepth 3 -type f -exec mv {} . \;
Remove the file with inode number 752010 </s> find -inum 752010 -exec rm {} \;
use regex with find command </s> find . * | grep -P "[a-f0-9\-]{36}\.jpg"
Find all .java files under and below the current directory </s> find . -name '*.java'
Find all regular files with 400 permission under '/data' directory tree </s> find /data -type f -perm 400 -print
find all the files in the folder "/u/bill" which have been accessed in the last 2-6 minutes </s> find /u/bill -amin +2 -amin -6
Sort file1 and file2 then display differences between them. </s> diff <(sort file1 -u) <(sort file2 -u)
Remove all tmp/*.mp3 files </s> find tmp -maxdepth 1 -name '*.mp3' -maxdepth 1 | xargs rm
Set permissions to 600 for regular files under var/ </s> find var/ -type f -exec chmod 600 {} \;
Set the group to "username" for all files with GID=1000 in the current directory tree </s> find -gid 1000 -exec chown -h :username {} \;
finds all files modified within a certain time frame recursively </s> find . -type f -newermt "2013-06-01" \! -newermt "2013-06-20"
Search for all files and directories named foo, FOO, or any other combination of uppercase and lowercase characters beneath the current directory. </s> find . -iname foo
Backup all of the Java files in the current directory tree by copying them and appending the suffix .bk to each </s> find . -name "*.java" -exec cp {} {}.bk \;
Print mount point of the file system containing $filename. </s> df "$filename" | awk 'NR==1 {next} {print $6; exit}'
Search directory /Users/david/Desktop/ recursively for regular files with extensions .txt, .mpg, .jpg </s> find /Users/david/Desktop -type f \( -name '*.txt' -o -name '*.mpg' -o -name '*.jpg' \)
List files and directories one level deep in the current directory tree </s> tree -L 2
Rename all files in the current directory to the md5 sum followed by the extension and print the conversions </s> md5sum * | sed -e 's/\([^ ]*\) \(.*\(\..*\)\)$/mv -v \2 \1\3/e'
Mark variables and function which are modified or created for export to the environment of subsequent commands </s> set -a
Replace all newlines from the contents of "file" except the last with spaces </s> sed ':a;N;$!ba;s/\n/ /g' file
Find all files with name ending with .txt and display only the filenames without full paths </s> find ./ -name "*.txt" | rev | cut -d '/' -f1 | rev
Search directory $CURR_DIR for regular files that were changed, accessed, or modified $FTIME days ago </s> find ${CURR_DIR} -type f \( -ctime ${FTIME} -o -atime ${FTIME} -o -mtime ${FTIME} \) -printf "./%P\n"
Find all files/directories under current directory tree with inode number 211028 and move them to 'newname.dir' </s> find . -inum 211028 -exec mv {} newname.dir \;
Replace all occurrences of 'previousword' with 'newword' in all regular files with '.cpp' extension under '/myprojects' directory tree and modify them in-place </s> find /myprojects -type f -name '*.cpp' -print0 | xargs -0 -n 1 sed -i 's/previousword/newword/g'
Print the full path prefix for all files in the current directory tree as a list </s> tree -fi
Treat each line of "list-of-entries.txt" as a value to be put in one cell of the table that "column" outputs </s> column list-of-entries.txt
Find files with group write permission and remove the permission </s> find . -perm -20 -exec chmod g-w {} ;
display all the files in the file system which belong to the user "wnj" or which are modified after the file "ttt" </s> find / \( -newer ttt -or -user wnj \) -print
Prints long recursive listing of all content of a current folder, saving output to 'output.file'. </s> ls |& tee files.txt
List environment variables whose name matches '^\w*X\w*' </s> set | grep -oP '^\w*X\w*(?==)'
Find all files matching "abc*" in the current directory and append a column with "OK" </s> find . -name 'abc*' -exec echo {}' OK' \; | column -t
Verbosely compresses all files on third and fourth depth level keeping original files in place. </s> bzip2 -kv */*/*
Copy all files and directories in "/home/" to "/newhome" preserving directory hierarchy and modification time </s> find /home/ -maxdepth 1 -print | sudo cpio -pamVd /newhome
Copies 'libgtest_main.so' and 'libgtest.so' to '/usr/lib/', preserving all attributes, and copying symlinks as symlinks, without following in source files. </s> sudo cp -a libgtest_main.so libgtest.so /usr/lib/
Find all files named "file.ext" within the current folder and print the path where each one is located </s> find `pwd` -name "file.ext" -exec dirname {} \;
search for MP3 files in the current folder and subfolders exclude dir1 AND dir2 </s> find ! -path "dir1" ! -path "dir2" -iname "*.mp3"
display all the files in the current folder excluding those ending with ".disabled" in sorted order </s> find /target/ | grep -v '\.disabled$' | sort
Change the owner of all files in the directory tree "dir_to_start" excluding file "file_to_exclude" to "owner" </s> find dir_to_start -not -name "file_to_exclude"  -print0 | xargs -0 chown owner
Look for files that have SUID or SGID set </s> find / -perm +6000 -type f
Prints information about user $euids currently on machine and its processes, without printing header. </s> w -h $euids
Send SIGHUP (hangup) signal to all parents of zombie processes. </s> kill -HUP $(ps -A -ostat,ppid | grep -e '[zZ]'| awk '{ print $2 }')
Find text in whole directory tree </s> find . -type f | xargs grep "text"
Set permissions of all directories under "/path/to/base/dir" to 755 </s> chmod 755 $(find /path/to/base/dir -type d)
create directories foo and bar </s> mkdir foo bar
Find all files/directories which have been modified within the last day in the drectories/files taken from the glob pattern '/tmp/test/*' </s> find /tmp/test/* -mtime -1
View lines 116 through 120 of history </s> history | head -n 120 | tail -n 5
Find all files/directories in entire file system more than 700 Megabytes </s> find / -size +700M
display all the files in the current folder which have not been modified in the last 7 days and which are not in the list "file.lst" </s> find -mtime +7 -print | grep -Fxvf file.lst
Search for a pattern "can't" in all the files with the name "file-containing-can't" in the current directory tree </s> find . -name "file-containing-can't" -exec grep "can't" '{}' \; -print
Search the current directory tree for regular files named `doc.txt' and print "found" for each of them </s> find ./ -type f -name doc.txt -printf "found\n"
Calculate md5 sum of files $source_file and $dest_file </s> md5sum "$source_file" "$dest_file"
find all the directories in the current folder that are empty(size 0 bytes) </s> find -type d -empty
show all the files  in current directory </s> find .
Gets IP addresses of all active network interfaces and saves to 'ip' variable. </s> ip=$(ifconfig | grep -oP "(?<=inet addr:).*?(?=Bcast)")
Find all .gif files in the /var/www directory tree that are between 5 kB and 10 kB in size </s> find /var/www -name *.gif -size +5k -size -10k
find files in /u/bill directory which are access an 2 to 6 minutes ago </s> find /u/bill -amin +2 -amin -6
Find all files/directories named 'game' under current directory tree </s> find . -name game
Count the number of files in the /usr/ports directory tree whose names begin with 'pkg-plist' and which contain 'dirrmtry' </s> find /usr/ports/ -name pkg-plist\* -exec grep dirrmtry '{}' '+' | wc -l
display all the files ending with ".user" in /var/adm/logs/morelogs/ and excluding all regular files </s> find /var/adm/logs/morelogs/* -type f -prune -name "*.user" -print
Add a date time stamp to every line of output in "ping google.com" </s> ping google.com | xargs -L 1 -I '{}' date '+%c: {}'
Prints full path to files in a current folder. </s> ls -d $PWD/*
Find all hard links to file1 under /home directory </s> find /home -xdev -samefile file1
Find all files/directories under current directory and set their permission to 775 </s> find . -type f -exec chmod 775 {} \;
Perform a case insensitive search for *.jpg files which are greater than 500KB in size under /ftp/dir/ directory </s> find /ftp/dir/ -size +500k -iname "*.jpg"
Prevent ssh from reading from standard input and execute "touch /home/user/file_name.txt" on "$R_HOST" as "$R_USER" </s> ssh -n $R_USER@$R_HOST 'touch /home/user/file_name.txt'
Find all the files that were modified exactly one day ago </s> find . -mtime 1
Display the entire file system in a tree-like format </s> tree /
Lists all subdirectories in the current directory </s> ls -d -- */                    ### more reliable GNU ls
Find all regular files under current directory tree excluding files from './dir1' (except './dir1/subdir1/) and './dir2' directories </s> find . \( -not -path './dir1/*' -and -not -path './dir2/*' -or -path './dir1/subdir1/*' \) -type f
Remove all regular files from the current directory tree whose names do not end with "txt" </s> find . -type f -not -name '*txt' -print0 | xargs -0 rm --
find all files under "/usr" </s> find /usr -print
Find all *.mp4 files under /foo/bar and move them to /some/path </s> find /foo/bar -name '*.mp4' -print0 | xargs -I{} -0 mv -t /some/path {}
find all files that are readable and writable by their owner </s> find . -perm -600 -print
create a tar ball of all the jpg and png images in the current folder </s> find . \( -iname "*.png" -o -iname "*.jpg" \) -print -exec tar -rf images.tar {} \;
Find all files in the current directory recursively with "linkin park" in their names and copy them to /Users/tommye/Desktop/LP </s> find . -type f -iname "*linkin park*" -exec cp -r {} /Users/tommye/Desktop/LP \;
Move files older than 1 day to directory TMP </s> find . -atime +1 -type f -exec mv {} TMP \;
Find all files named 'file' in 1 level down the current directory whose status were changed more than 1 day ago </s> find . -maxdepth 1 -ctime +1 -name file
Add a cron job to existing list, without removing existing ones, ro tun "scripty.sh" at 2:01 am, 3rd day of april (4th month), if that day happens to be a friday (5th day of the week starting with sunday=0). </s> cat <(crontab -l) <(echo "1 2 3 4 5 scripty.sh") | crontab -
Request authority info with comments for 'djzah.com' from name server 'ns1.hosangit.com', and pass it to 'script.awk' awk script. </s> dig @ns1.hosangit.com djzah.com +noall +authority +comments | awk -f script.awk
find md5sum of an empty string </s> echo -n '' | md5
Getting a detailed list of files/dirs </s> find  / -name "apt" -ls
Print 7 spaces in a row </s> yes ' ' | head -7 | tr -d '\n'
find all files in the current directory whose size is 24 or 25 bytes. </s> find . -size -26c -size +23c -print
Print each character in "Hello" as a hexadecimal value </s> echo -n "Hello" | od -A n -t x1
Find all 777 permission directories under current directory and  set permissions to 755 </s> find . -type d -perm 777 -print -exec chmod 755 {} \;
find all the directories in the current folder </s> find -type d
Keep only the last two hyphen-separated sections of "abc-def-ghi-jkl" </s> echo "abc-def-ghi-jkl" | rev | cut -d- -f-2 | rev
List all entry names contained directly by directory in_save in the current directory, pausing for user input at each page. </s> find ./in_save/ -type f -maxdepth 1| more
Show the list of files larger than 100 MB </s> find / -size +100M -print
delete all the text files in the current folder. </s> find . -type f -name "*.txt" -exec rm -f {} \;
Delete all empty directories under current directory </s> find -type d -empty
Recursively remove all "*.txt" files and answer "y" to any prompt </s> yes | rm -r *.txt
Find all directories under /path/to/base/dir and change their permission to 755 </s> find /path/to/base/dir -type d -print0 | xargs -0 chmod 755
Find all files under minimum 1 level down the current directory </s> find .  -mindepth 1 -type f
Immediately terminate all processes whose command or arguments match "myProcessName" </s> ps -ef | grep myProcessName | grep -v grep | awk '{print $2}' | xargs kill -9
find all the files that have been modified in the last 1 day </s> find . -type f -daystart -mtime -1
Show all lines as they are executed and stop at the first command returning nonzero </s> set -ex
Recursively change owner of all files in "folder" to "user_name" </s> chown -R user_name folder
recursively change owner and group of the directory  /vol/html and all files into it to user ec2-user and group apache </s> sudo chown -R ec2-user:apache /vol/html
find all the directories with the name "uploads" in current folder </s> find . -type d -name 'uploads'
Find all files/directories under current directory with a Depth-First search </s> find dir -depth
Prints all Saturday days of a current month. </s> cal -h | cut -c19-20
List all nfs mount points on the system </s> mount -l | grep 'type nfs' | sed 's/.* on \([^ ]*\) .*/\1/'
Remove all tmp/*.mp3 files </s> find tmp -maxdepth 1 -name *.mp3 -print0 | xargs -0 rm
Sets shell option 'nounset'. </s> shopt -s -o nounset
Print the minimum transmission time of 10 ping requests to "google.com" from cygwin </s> ping google.com -n 10 | grep Minimum | awk '{print $3}' | sed s/,//
Search all files in the current directory tree, except GIT files, for "string-to-search" </s> find . -name .git -prune -o -print | xargs grep "string-to-search"
Search the "katalogi" directory tree for files named "wzorzec" </s> find katalogi -name wzorzec
Find all files under current directory whose file type description contains "image", display only path to each file. </s> find . -type f -exec file {} \; | grep -o -P '^.+: \w+ image'
Save a list of all the files/directories under current directory tree to a file named 'foo' </s> find . -fprint foo
Find files that are 0 bytes in size in the current directory tree and remove them </s> find . -size 0 -exec rm {} \;
Read a single line from standard input and save to variable "line" </s> read line
Set variable "b" to the first word of "a" converted to lowercase. </s> b=`echo "$a" | awk '{ print tolower($1) }'`
Open all .c files in the current directory tree in the vim editor </s> find . -name "*.c" -print | vim -
Stores system load average number in the 'proc_load_average' variable. </s> proc_load_average=`w | head -1 | cut -d" " -f13 | cut -d"," -f1-2 | tr ',' '.'`
Format output of 'file' content to columns with wide not less than 80 pixels </s> cat file | column -c 80
Print true directory name of the current directory </s> readlink `pwd`
List all files in the current directory tree that were last modified more than 60 minutes ago </s> find -mmin +60
Copies all files with "FooBar" in the path under the current directory to the '~/foo/bar' directory. </s> find . | grep FooBar | xargs -I{} cp {} ~/foo/bar
Change directory to the directory containing the "oracle" executable </s> cd $(dirname `which oracle`)
Remove the regular files from the current directory that were last modified on November, 22 </s> find -maxdepth 1 -type f -newermt "Nov 22" \! -newermt "Nov 23" -delete
Find directories named `doc' in /usr and below </s> find /usr \( -name doc -and -type d \)
Print comma separated gaps in file "file" that contains new line separated ordered numbers </s> seq $(tail -1 file)|diff - file|grep -Po '.*(?=d)'
Find all directories starting from / that have permissions 777 </s> find / -type d -perm 0777
Append all *.mp3 files modified within the last 180 days to tar archive `music.tar' </s> find . -name -type f '*.mp3' -mtime -180 -print0 | xargs -0 tar rvf music.tar
Make directory expanded by $dir variable </s> mkdir $dir
display all the files in current folder which have not been modified in the last 7 days </s> find . -mtime +7
Save the current date, system host name, and "$changes" with newlines removed to variable "subj" </s> subj="$(date) - $(hostname) - $(echo "$changes" | sed "s/$/,/" | tr "\n" " ")"
Create intermediate directories ~/foo/bar/ as required and directories baz, bif, bang </s> mkdir -p ~/foo/bar/baz ~/foo/bar/bif ~/foo/boo/bang
Move all directories from the `sourceDir' directory tree to the `destDir' directory </s> find sourceDir -mindepth 1 -type d  -exec mv -t destDir "{}"  \+
Delete all files named "filename" in the current directory tree, except the one with path ./path/to/filename </s> find . -name "filename" -and -not -path "./path/to/filename" -delete
Find all files/directories under $something directory </s> find $something
Set permissions to 660 for all regular files in the current directory tree </s> find . -type f -exec chmod 0660 {} +
Creates temporary file and saves path to it in 'content_dir1' variable. </s> content_dir1=$(mktemp)
Find a.out and object files in the current directory tree </s> find . ( -name a.out -o -name *.o ) -print
Find files that were modified 7 days ago and archive them </s> find . -type f -mtime 7 | xargs tar -cvf `date '+%d%m%Y'_archive.tar`
Make directories for each unique file path in "file1" </s> cat file1 |xargs -I {} dirname "{}"| sort -u | xargs -I{} mkdir -p "{}"
SSH into server "server.com" as user "remote_user" </s> ssh remote_user@server.com
Find all directories under current directory and set their permission to 755 </s> find -type d exec chmod 755 {} +
Remove all .sh files in the current directory tree whose names begin with "new" </s> find . -name "new*.sh" -exec rm -f '{}' \+
display all files in the current folder </s> find . -print
Find all empty files in the current directory and delete them </s> find . -type f -maxdepth 1 -empty -print0 | xargs -0 /bin/rm
Prints full process tree with id number of each process. </s> pstree -p
Find all files/directories under '/usr/local' containing 'blast' (case insensitive) in their names </s> find /usr/local -iname "*blast*"
Print the largest 20 files under current directory </s> find . -type f -printf '%s %p\n' | sort -rn | head -20
Filters only directories from long file listing of the current directory </s> ls -l --color=always "$@" | grep --color=never '^d'
Find all files with extension .aac in the /home directory tree </s> find /home -type f -name '*.aac'
Set variable 'rav' to the contents of 'var' spelled backwards. </s> rav=$(echo $var | rev)
search for a word in all the .C files( those having the extension "c") in current directory </s> find . -type f \( -iname “*.c” \) |grep -i -r “keyword”
Print 10 lines of a single "x" </s> yes x | head -n 10
Recursively search for all directories containing "foo" (case insensitive) under the current directory, renaming them to replace "foo" (case insensitive) with "Bar" </s> find . -type d -iname '*foo*' -depth -exec rename 's@Foo@Bar@gi' {} +
find all the *.conf files under / (root) </s> find / -name "*.conf"
display all the C files or Python files in the folder "euler" </s> find euler/ -iname "*.c*" -exec echo {} \; -or -iname "*.py" -exec echo {} \;
Identify CMS version/releases accross all your PHPBB installations </s> find /var/www/vhosts/*/httpdocs/ -type f -wholename *includes/constants.php -exec grep -H "PHPBB_VERSION" {} \;
Write the output of "false" to standard output and to "/dev/null" </s> false | tee /dev/null
display all the normal/regular files in a directory </s> find $dir -type f -name $name -print
Search the /mnt/raid/upload directory tree for files that have been modified within the last 7 days </s> find /mnt/raid/upload -mtime -7 -print
Find all files under current directory and show their file information </s> find . -type f -print0 | xargs -0 file
find all the text files in the file system and search only in the disk partition of the root. </s> find / -mount -name "*.txt"
Find files that were modified more than 7 days ago and archive them </s> find . -type f -mtime +7 | xargs tar -cvf `date '+%d%m%Y'_archive.tar`
Find all files/directories under minimum 2 level down the current directory and set their permission to 700 </s> find . -mindepth 2 | xargs chmod 700
search for all the files in the folder /data/images which are modified after /tmp/foo </s> find /data/images -newer /tmp/foo
Print list of all user names who are logged in </s> who | sed -e 's/[ \t].*//g'
SSH into user@server and run command ${SSH_COMMAND} </s> ssh user@server "${SSH_COMMAND}"
find all regular/normal files in the current folder </s> find -type f
Remove all *.txt files, except robots.txt, under the given directory modified more than 5 minutes ago </s> find /home/u20806/public_html -name "robots.txt" -o -maxdepth 1 -mmin +5 -type f -name "*.txt" -delete
find all the files ending with "mkv" in current folder </s> find -name "*.mkv"
find all files in and under the current directory that have read, write and execute permissions set for all users. </s> find . -perm 777 -print
find all the text files in the current folder </s> find . — name "*.txt" — print
Counts all files in a current folder and subfolders. </s> find `pwd` -type f -exec ls -l {} \; | wc -l
find the count of all the regular files in a directory </s> find /usr -type f | wc -l
List files smaller than 9kB residing in the current directory and below </s> find . -size -9k
Find all files under $source_dir that match the regex expanded by $input_file_type in their paths </s> find "$source_dir" -type f|egrep "$input_file_type"
Find all files under /somefolder matching the extended regex '\./(.*\.error.*|second.*log|.*FFPC\.log)$' in their paths </s> find -E /somefolder -type f -regex '\./(.*\.error.*|second.*log|.*FFPC\.log)$'
List the files from the current directory tree that contain lines matching regular expression  '^Subject:.*unique subject' </s> find . -type f -print | xargs grep -il '^Subject:.*unique subject'
Search the files of the current directory tree for string "searched-string" </s> find . | xargs grep "searched-string"
Recursively copy all files and folders in the current directory excluding "exclude_pattern" to "/to/where/" </s> rsync -r --verbose --exclude 'exclude_pattern' ./* /to/where/
Recursively find all files in the directory "posns" and split each one into files of at most 10000 lines each </s> find posns -type f -exec split -l 10000 {} \;
Copy a file xyz.c to all the .c files present in the C directory and below </s> find ./C -name "*.c" | xargs -n1  cp xyz.c
find all regular/normal files in the folder "myfiles" which have read and write permission to the other users </s> find /myfiles -type f -perm -o+rw
Write the common third space separated fields in "file1.sorted" and "file2.sorted" to "common_values.field" </s> comm -12 <(cut -d " " -f 3 file1.sorted | uniq) <(cut -d " " -f 3 file2.sorted | uniq) > common_values.field
find files in current folder using name patterns and sort the display the file names in the sorted order </s> find . -name "S1A*1S*SAFE" | rev | awk -F '/' '{print $1}' | rev | sort -t _ -k 5
Print file type information of the "java" executable </s> cat `which java` | file -
Execute "${MD5}" on all files found under "${1}", numerically sort the results, and save to variable "DATA" </s> DATA=$( find "${1}" -type f -exec ${MD5} {} ';' | sort -n )
Find any hidden regular files in the current directory and its sub-directories that were modified after .cshrc was last modified. </s> find . -type f -name ".*" -newer .cshrc -print
List all files in the current directory tree larger than 1000 kb </s> find . -size +1000k
search for all the files in the entire file system which have either suid or sgid bit enabled and find of diff of these files with the file "files.secure". </s> find / \( -perm 2000 -o -perm 4000 \) -print | diff - files.secure
Print each line in "set1" and "set2" that does not exist in the other </s> sort set1 set2 | uniq
Make directories to "directory{1..3}/subdirectory{1..3}/subsubdirectory{1..2}" as needed </s> mkdir -p directory{1..3}/subdirectory{1..3}/subsubdirectory{1..2}
Sets shell option 'extglob'. </s> shopt -s extglob
split content of the file inputfile except lines started with "^t:" into pieces per 200 lines </s> cat inputfile | grep "^t\:" | split -l 200
Recursively removes all files like '4' under folder './a' and removes folders with such files if they become empty. </s> find a -type f -name '4' -delete -printf "%h\0" | xargs -0 -r rmdir
Find all directories in the current directory tree </s> find -type d
Find largest file in linux with find command </s> find . -type f -printf "%s\t%p\n" | sort -n | tail -1
Delete files containing whitespaces </s> find . -name "* *" -exec rm -f {} \;
Find files under current directory without descending into other file systems and append a null character at the end of each paths </s> find -x . -type f -print0
Search the ~/Books directory recursively for files named "Waldo" </s> find ~/Books -name Waldo
Search the *.cc files in the current directory tree for string "xxx" </s> find . -name "*.cc" -print -exec grep "xxx" {} \;
display all the files in the current folder excluding those that are present in the path "./etc" </s> find . ! -wholename "./etc*"
search for the directory "config" in the current folder and change directory to it </s> cd `find . -name "config"`
find all files beneath the current directory that begin with the letters 'Foo' and delete them. </s> find . -type f -name "Foo*" -exec rm {} \;
Push the directory containing the first existing command found in all arguments to the directory stack. </s> pushd $(dirname `which $@`)
Open all .java files in the current directory tree in the vim editor </s> find . -name '*.java' | xargs vim
Print amount of space available on the file system containing path to the current working directory in megabytes. </s> df . -B MB | tail -1 | awk {'print $4'} | cut -d'%' -f1
Search for 'whatIWantToFind' in all files under current directory </s> find . -exec grep whatIWantToFind {} \;
Search the current directory tree for directories that can be opened by noone </s> find -type d ! -perm -111
Find directories modified in last 7 days </s> find . -mtime -7 -type d
Unzip "bigfile.txt.gz" to standard output, search for patterns in "patterns.txt", and list the unique matches </s> gunzip -c bigfile.txt.gz | grep -f patterns.txt | sort | uniq -c
search the entire file system for the file "jan92.rpt" </s> find / -name jan92.rpt -print
Mount the "vboxsf" filesystem "D:\share_folder_vm" on "\share_folder" </s> sudo mount -t vboxsf D:\share_folder_vm \share_folder
Recursively change the owner and group of all files in the current directory to "andrewr" </s> chown -R andrewr:andrewr *
Recursively removes 'classes' folder, prompting user on each deletion. </s> rm -r classes
Replace "," with "\r\n" in "a,b" </s> echo "a,b"|sed 's/,/\r\n/'
Archive the entire file system into tarfile.tar.bz2 </s> find / -print0 | xargs -0 tar cjf tarfile.tar.bz2
Print last day of April, 2009 </s> cal 4 2009 | tr ' ' '\n' | grep -v ^$ | tail -n 1
Search for 'mystring' in all *.txt files under current directory </s> find . -name *.txt | xargs egrep mystring
Force create a symbolic link named "$lines" to "$c" without dereferencing "$lines" </s> ln -sfn "$c" "$lines"
Print $d if $d is an empty directory </s> find "$d" -prune -empty -type d
Find all files that have either a .php or a .js extension </s> find -regextype posix-egrep -regex '.*(php|js)$'
SSH into host "server" as user "user" </s> ssh user@server
find all the files in the current directory with the name "wagoneer" which are in the current device. </s> find . -xdev -name "wagoneer*" -print
Find all *.ogg (case insensitive) files/directories under your home directory </s> find $HOME -iname '*.ogg'
Search the file system for regular files whose pathnames are shorter than 25 characters </s> find / -type f|awk -F'/' '{print $NF}'| awk 'length($0) < 25'
Find all files on the system that are world writable </s> find / -wholename  '/proc' -prune  -o  -type f -perm -0002 -exec ls -l {} \;
Locate all files in the current directory and below that do not have "testfileasdf" in their names </s> find -not -name "*testfileasdf*"
find all text files in the folder "FFF" and find the md5sum for them </s> find FFF -name "*.txt" -exec md5sum '{}' \;
Search the bla directory recursively for *.so files </s> find bla -name "*.so"
Recursively copy all files and directories in "demo" excluding ".git" to "demo_bkp" </s> find demo -depth -name .git -prune -o -print0 | cpio -0pdv --quiet demo_bkp
Print the file system "file/goes/here" is on </s> df -P file/goes/here | tail -1 | cut -d' ' -f 1
Find and remove all .txt regular files under the current directory and below </s> find . -type f -name "*.txt" -exec rm -f {} \;
search for the regular/normal file "Dateiname" in the entire file system </s> find / -type f -iname "Dateiname"
Find all directories under current directory and set their permission to 775 </s> find -type d exec chmod 775 {} +
Print the current directory </s> find -prune
Concatenate files containing `test' in their names </s> find . -name '*test*' -exec cat {} \;
Find all directories under and below parent_directory </s> find parent_directory -type d
Find and delete all files with a used disk size of 0 </s> rm `du * | awk '$1 == "0" {print $2}'`
Represent the UTC date given in time string "1970.01.01-$string1" as number of seconds since the epoch and save it in 't1' variable </s> t1=$(date -u -d "1970.01.01-$string1" +"%s")
Search for .zip files that are larger than 100M found anywhere in the file system and delete those files. </s> find / -type f -name *.zip -size +100M -exec rm -i {} \;
Search for the case insensitive regex expanded by $2 in all files named $1 (to be expanded) under current directory </s> find . -name $1 -type f -exec grep -i $2 '{}' \;
display all the directories in the current folder excluding those that are present in the .svn directory tree </s> find -type d -path '.svn' -prune -o -print
Print differences between the sorted content of file $1 and file $2, executing 'diff' with options from "${@:3}" array slice </s> diff "${@:3}" <(sort "$1") <(sort "$2")
Search for '“foobar”' in all files starting with '‘' and ending with '’' and contain '.' in their names in the entire filesystem and display only the matched files </s> find / -name ‘*.*’ -exec grep -il “foobar” {} \;
Search the current directory recursively for files whose size is between 10 and 50 MB </s> find . -size +10M -size -50M -print
Recursively change "/usr/local" owner to the current user and group to admin </s> sudo chown -R $(whoami):admin /usr/local
Remove all .mpg files in the /home/luser directory tree </s> find /home/luser -type f -name '*.mpg' | xargs rm -f
Run a "rm" process to recursively remove "cache", making it immune to all SIGHUP signals sent to it. </s> nohup rm -rf cache &
Print new line separated numbers from "001" to "100" </s> yes | nl -ba | tr ' ' 0 | sed 100q | cut -b 4-6
Display all lines containing "IP_MROUTE" in the current kernel's compile-time config file. </s> cat /boot/config-`uname -r` | grep IP_MROUTE
find all  *.csv files which  modify within last 2 days in /home directory then zip ( archive )- </s> find /home/archive -type f -name "*.csv"  -mtime -2 -exec gzip -9f {} \;
search all undo files(ending with .undo) in the current folder and calculate the total size of them </s> find -name '*.undo' -exec wc -c {} + | tail -n 1
Find all directories under $FOLDER, take the first fields (dot (.) as the delimiter) from their timestamps and reverse sort them numerically </s> find "$FOLDER" -type d -printf "%T@\n" | cut -f 1 -d . | sort -nr
Compare files in "/tmp/dir1" and "/tmp/dir2", treat absent files as empty and all files as text, and print 3 lines of unified context </s> diff -Naur dir1/ dir2
List and remove all regular files named "core" under /prog that are larger than 500k </s> find /prog -type f -size +1000 -print -name core -exec rm {} \;
Prints process tree of the current command process. </s> pstree -p $$
display the filename and size of all the files in the file system which are bigger than 20MB </s> find / -type f -size +20000k -exec ls -lh {} \; | awk '{ print $8 ": " $5 }'
Print the first 32 hexadecimal characters from "/dev/urandom", determining C locale for character handling functions </s> cat /dev/urandom | env LC_CTYPE=C tr -cd 'a-f0-9' | head -c 32
SSH into host "$1" using key file "/path/to/ssh/secret/key" and execute command "$2" </s> ssh -i /path/to/ssh/secret/key $1 $2
find all the files that have been modified today </s> find /tmp/test/* -mtime +0
find all the files in current directory of size greater than 2GB. </s> find . -size +2G
Find all broken symlinks in maximum 1 level down the $path directory </s> find -L $path -maxdepth 1 -type l
Find all PHP files under current directory that contain only one line </s> find . -type f -name '*.php' -exec wc -l {} \; | egrep "^\s*1\s"
Changes group ownership of 'public' to 'pub'. </s> chgrp pub public
Change permissions to 500 for all regular files under and below the current directory </s> find . -type f -exec chmod 500 {} ';'
Save the "Pictures" directory in the current user's home directory on the directory stack </s> pushd /home/`whoami`/Pictures
Send each byte in "/home/cscape/Desktop/file" to awk script "x.awk" </s> fold -1 /home/cscape/Desktop/file  | awk -f x.awk
search in the current folder for the file "myletter.doc" </s> find . -name myletter.doc -print
Search the directories given as arguments to the Bash script for files whose name is not "ss" </s> find $@ -not -name ss
switch to user username </s> su username
Find all directories on the system whose size is greater than 50k </s> find / -type d -size +50k
Recursively change the owner of all files in "testproject/" to "ftpuser" </s> chown ftpuser testproject/ -R
Remove files whose names match regular expression '^.*/[A-Za-z]+-[0-9]+x[0-9]+\.[A-Za-z]+$' from the current directory tree </s> find -regex '^.*/[A-Za-z]+-[0-9]+x[0-9]+\.[A-Za-z]+$' | xargs echo rm -f
Remove all empty directories under the current directory and below </s> find ./ -type d -size 0c -print | xargs rmdir
Change owner to "$user" and group to "$group" of "$file" </s> chown -- "$user:$group" "$file"
Use the octal form to find and print detailed information about all regular files in your home directory and below that have only the group permission set. </s> find . -perm 040 -type f -exec ls -l {} \;
Print a list of all duplicate case insensitive file paths in the current directory tree </s> find . | sort -f | uniq -i -d
Copy the owner and group of "oldfile" to "newfile" </s> chown --reference=oldfile newfile
Delete all filename* files under /dir directory </s> find /dir -name "filename*" -type f -delete
Search only for regular files </s> find -type f
Numberically sort content of file 'files', using for sorting part of second one of dash separated fields beginning from second letter. </s> cat files | sort -t- -k2,2 -n
Save the user name in upper case of the current user in variable "v" </s> v=$(whoami | tr [:lower:] [:upper:])
Calculate the md5 sum of all files in the current directory with the filename printed first </s> ls -p | grep -v / | xargs md5sum | awk '{print $2,$1}'
Find the 5 largest regular files in the current directory and below. </s> find -type f -exec du -Sh {} + | sort -rh | head -n 5
display a long listing of all the "Trash" files in the folder /home </s> find /home -name Trash -exec ls -al {} \;
Find all files/directories named 'query' under current directory </s> find -name "query"
find all the files ending with "~" in current folder and move them to temp folder </s> find -name '*~' -print0 | xargs -0 -I _ mv _ /tmp/
change the permissions of all the directories in the current folder </s> chmod 751 `find ./ -type d -print`
display all the text files in current folder </s> find . -name "*.txt"
find files in $HOME ending in "txt" or "html" and case insensitive search for the word "vpn" </s> find $HOME \( -name \*txt -o -name \*html \) -print0 | xargs -0 grep -li vpn
Get second line from text contained in variable $data. </s> echo "$data" | cut -f2 -d$'\n'
Archive directory specified by variable "myFolder" to current directory. </s> rsync -av $myFolder .
Print the list of files in the current directory tree with "xx" preceding and following each filename </s> find . -exec echo xx{}xx \;
Find all the regular files in $DIR directory tree which have not been modified in the last 450 days and delete them </s> find $DIR -type f -mtime +450 -exec rm {} \;
Display all symlinks and their targets in the current directory tree </s> find -P . -type l -exec echo -n "{} -> " \; -exec readlink {} \;
find all the files in the file system that start with "win" and searched only in the mounted file systems </s> find / -mount -name 'win*'
Find files/directories containing 'test' in their names and display the directory contents before the directories themselves </s> find -name "*test*" -depth
search for the word "methodNameHere" in all the python files in the folder "/mycool/project/" and display color on the matched lines in the output </s> find /mycool/project/ -type f -name "*.py" -print0 | xargs -I {} -0 grep -H --color "methodNameHere" "{}"
Find all files/directories named '.todo' under $STORAGEFOLDER directory tree and print the parent directory names </s> find "$STORAGEFOLDER" -name .todo  -exec dirname {} \;
search for all the files in the folder /usr/bin which have not been accessed in the last 100*24 hours </s> find /usr/bin -type f -atime +100
display a long listing of all fles in current folder which have been modified in the last 60 minutes </s> find . -mmin -60 -ls
Find files/directories named 'file.txt' in the path '/usr/lib/important/' </s> find / -path /usr/lib/important/*/file.txt
Recursively removes all empty folders under current folder. </s> find . -depth -type d -empty -exec rmdir {} \;
Read a line from standard input </s> read
Print a listing of the /usr/local/etc/rc.d directory tree </s> find /usr/local/etc/rc.d -type f | awk -F/ '{print $NF}'
Print newline, word, and byte counts of each '*.java' file within current directory, and total newline, word, and byte counts </s> find . -name \*.java | tr '\n' '\0' | xargs -0 wc
Find all files/directories under current directory appending a null character at the end of each file name/path </s> find -print0
find regular files in the current directory, without descending into sub-directories and display as a null separated list. </s> find -maxdepth 1 -type f -printf '%f\000'
find all the reguar/normal php files in current directory. </s> find . -type f -name "*.php"
Print "echo ping -c 2" on each string in file 'ips' </s> cat ips | xargs echo ping -c 2
Format tab delimited file "list-of-entries.txt" as a table </s> column -t -s $'\t' list-of-entries.txt
Find all files under current directory with their size and paths, reverse sort them numerically, then print the first 4 entries by removing all matches to the regex [0-9]+\s from each line of the output </s> find -type f -printf "%s %p\n" | sort -nr | head -n 4 | sed -r 's/[0-9]+\s//g'
Counts sum of non-empty lines from all .php files in a current folder. </s> find . -name "*.php" | xargs grep -v -c '^$' | awk 'BEGIN {FS=":"} { cnt = cnt + $2} END {print cnt}'
find all files that belong to root user </s> find . -uid 0 -print
Delete all files/directories taken by the glob pattern * except the ones with the name 'b' </s> find * -maxdepth 0 -name 'b' -prune -o -exec rm -rf '{}' ';'
Search for the regex expanded by the variable $SEARCH in all regular files under $DIR directory tree </s> find "$DIR" -type f -exec grep -q "$SEARCH" {} + ;
Create a symbolic link in target directory "~/newlinks" to "$source" </s> ln -s "$source" -t ~/newlinks
Find all files with '.db' extension (case insensitive) that belong to user 'exampleuser' and were modified exactly 7 days ago under '/home' directory tree </s> find /home -user exampleuser -mtime 7 -iname ".db"
Infinitely print "no" to the screen </s> yes no
Save the absolute path of "$path" to variable "fullpath" </s> fullpath=`readlink -f "$path"`
Create a symbolic lnk named "$1/link" to "$dir" </s> ln -s "$dir" "$1/link"
List all files in the current directory tree that were modified less than 60 minutes ago </s> find . -mmin -60 |xargs ls -l
Read line from file descriptor 4 and store received input in 'line' variable </s> read -u 4 line
Force remove all files and folders in the physical current working directory </s> rm -rf "$(pwd -P)"/*
find all the files that have been changed exactly 24 hours ago </s> find . -ctime 1 -type f
find all js files under the build direcotry except build/external directory. </s> find build -not \( -path build/external -prune \) -name \*.js
find all foo.bar files in the entire file system and which are present in the same partition as root. </s> find / -name foo.bar -print -xdev
find all files named `linux' on the system </s> find / -name linux
Find all directories in maximum 1 level down the current directory that were modified less than 1 day ago </s> find -maxdepth 1 -type d -mtime -1
Change symbolic link "$f" into a file </s> cp --remove-destination $(readlink $f) $f
change the ownership of all directories in the current folder </s> find . -type d -exec chown username {} \;
find all the files from root folder which have nogroup or noname and dispaly their details. </s> find / \( -nogroup -o -noname \) -ls
Print all '-' separated digits in file 'infile' as dot ('.') separated digits </s> grep -Eo '([0-9]+-){3}[0-9]+' infile | tr - .
Search the /tmp directory tree for files owned by user `ian' </s> find /tmp -user ian
Check if "$file" contains DOS line endings </s> od -t x2 -N 1000 $file | cut -c8- | egrep -m1 -q ' 0d| 0d|0d$'
List all files in the current directory tree including those that may contain spaces in their names </s> find . -print0 | xargs -0 -l -i echo "{}";
Save the user name of the current user to variable "me" </s> me=$(whoami)
List all available commands in Mac OS </s> echo $PATH | tr ':' '\n' | xargs -I {} find {} -maxdepth 1 -type f -perm '++x'
Remount subtree "/outside" to "/inside" as a bind </s> mount /outside /inside -o bind
Show file type information for files in /usr/bin </s> find /usr/bin | xargs file
Append all PNG and JPG files to tar archive 'images.tar' </s> find . \( -iname "*.png" -o -iname "*.jpg" \) -print -exec tar -rf images.tar {} \;
Saves listing of a current folder in 'var' variable. </s> var=$(ls -l)
find all files in the current folder which are bigger than 10MB and less than 50 MB </s> find . -size +10M -size -50M -print
Remove all files under /home/user/Maildir/.SPAM/cur </s> find /home/user/Maildir/.SPAM/cur -type f -exec rm -f '{}' '+'
Save the date 222 days before today to the variable 'date_222days_before_TodayDay' </s> date_222days_before_TodayDay=$(date --date="222 days ago" +"%d")
Gets MAC address of en0 network interface. </s> ifconfig en0 | grep -Eo ..\(\:..\){5}
Archive files (not directories) in "sorce_dir" to "target_dir" </s> rsync -a --filter="-! */" sorce_dir/ target_dir/
Save the absolute path of the current script to variable "SELF" </s> script="`readlink -f "${BASH_SOURCE[0]}"`"
Count the number of all directories under directory '/mount/point' non-recursively </s> find /mount/point -maxdepth 1 -type d | wc -l
Finds IP address of system network interface, that belongs to 192.168.111 subnet. </s> ifconfig | grep 192.168.111 | awk '{print $2}'
find all the regular/normal files in the folder "myfiles" which have the permission 647. </s> find /myfiles -type f -perm -647
display all the php files in the entire file system </s> find / -name "*.php"
Save the current working directory to variable "CURRENT" </s> CURRENT=`pwd`
Output a CSV file as a formatted table </s> sed 's/^,/ ,/' test2.csv | tr -d \" | column -s, -t
Search the current directory tree for regular files changed less than 1 day ago </s> find . -type f -ctime -1
search for a shell script in the current folder and display the current folder path </s> find . -name onlyme.sh -exec pwd \;
Append the contents of ".cwdhist" file to the current in-memory history list </s> history -r .cwdhist
Count the number of lines in all ".txt" files </s> cat *.txt | wc -l
display all symbolic links in current folder </s> find . -lname "*"
Find all files/directories that are owned by user 'takuya' under current directory tree </s> find -user takuya
find the file "filename.txt" in the entire file system </s> find / -name filename.txt -print
Search the current directory tree for *.c and *.asm files, ignoring the case </s> find . -type f \( -iname "*.c" -or -iname "*.asm" \)
Find all *.ogg (case insensitive) files/directories under your home directory that are greater than 20MB in size </s> find $HOME -iname '*.ogg' -size +20M
Find all the .mp3 files in the music folder and pass to the ls command, -print0 is required if any filenames contain whitespace </s> find ./music -name "*.mp3" -print0 | xargs -0 ls
Print 10 "#" characters in a row </s> yes '#' | head -n 10 | tr -d '\n'
Search all .py files in the current directory tree for "some_function" </s> find . -name \*.py | xargs grep some_function
find all ".flac" files starting with "cmn-" and search for files having CJK characters using unicodes </s> find . -name 'cmn-*\.flac' -print | grep -P './cmn-[\x4e00-\x9fa5]\.flac'
Find all files in the current directory tree that were last changed $minutes minutes ago </s> find . -cmin $minutes -print
Find all files/directories following symbolic links under current directory tree that are owned by 'root' user </s> find . -follow -uid 0 -print
Find files matching the pattern "./sr*sc" in their paths under current directory </s> find . -path "./sr*sc"
Change the ownership of all files in the current directory tree from root to www-data </s> find -user root -exec chown www-data {} \;
Delete all files beneath the current directory that begin with the letters 'Foo'. </s> find . -type f -name "Foo*" -exec rm {} \;
List all files/directories under /data1/Marcel which are greater than 524288 bytes and were modified or accessed more than 1 year ago </s> find /data1/Marcel -size +1024 \( -mtime +365 -o -atime +365 \) -ls
Find all $tofind* files/directories under $parentdir </s> find $parentdir -name $tofind*
Finds recursively all folders named 'a' within current folder and removes only ones without files and another folders within. </s> find . -name "a" -type d | xargs rmdir
Find all files/directories in current directory and execute the script itself with minimal invocation for those files/directories </s> find . -exec $0 {} +
Search the current directory recursively for MOV files, following symlinks </s> find . -iname "*.mov" -follow
Set 644 permission to all regular files under current directory </s> find . -type f -print0 | xargs -0 chmod 644
Prints week day of a 31 day in a current month. </s> cal | awk -v date=31 'NR == 2 { split($0, header) } NR > 2 { for (i = 1; i <= NF; ++i) if ($i == date) { print header[NR == 3 ? i + 7 - NF : i]; exit } }'
Remove all files that are not newer than Jul 01 by modification time </s> find /file/path ! -newermt "Jul 01" -type f -print0 | xargs -0 rm
Search the current directory recursively for .m4a files </s> find . -type f -iname *.m4a -print
Copies file 'file1' to each of directories 'dir1', 'dir2', 'dir3'. </s> echo dir1 dir2 dir3 | xargs -n 1 cp file1
Search the current directory tree for symbolic links to files matching pattern '*/test*' </s> find -P . -lname '*/test*'
display all the files in the folder /etc /srv excluding those that are present in the path of ./srv/tftp/pxelinux.cfg* and /etc/mtab </s> find /etc /srv \! -path "./srv/tftp/pxelinux.cfg*" -a \! -name /etc/mtab
Find all directories under /path/to/Dir and set their permission to 755 </s> sudo find /path/to/Dir -type d -print0 | xargs -0 sudo chmod 755
Prints long recursive listing of all content of a root folder, saving output to 'output.file'. </s> ls -lR / | tee output.file
copy the entire contents of the current directory to another directory, while preserving the permissions, times, and ownership of every file and sub-directory </s> find . | cpio -pdumv /path/to/destination/dir
Print details for all files in the ./work directory tree with extension .sh that were modified less than 20 days ago </s> find ./work/ -type f -name "*.sh" -mtime -20 | xargs -r ls -l
list PID of a group leader </s> jobs -lp
Change the owner of "destination_dir" to "user" </s> chown user destination_dir
split the first 100 lines of the file "datafile" per lines with size 1700 bytes </s> sed 100q datafile | split -C 1700 -
Find all files whose names contain the string 'xpilot' which exist within '/usr/local/games' </s> find /usr/local/games -name "*xpilot*"
display all the C, CPP, Header files in the kat folder </s> find kat -type f \( -name "*.c" -o -name "*.cpp" -o -name "*.h" \)
Find all regular files under  $somedir directory and print each of their paths after a string literal 'Found unexpected file ' </s> find "$somedir" -type f -exec echo Found unexpected file {} \;
Mount "/windows" using /etc/fstab entry </s> mount /windows
Delete files in /var/tmp/stuff and below that have not been modified in over 90 days </s> find /var/tmp/stuff -mtime +90 -exec /bin/rm {} \;
Get the total size of all files under dir1 directory </s> find dir1 ! -type d -printf "%s\n" | awk '{sum += $1} END{printf "%f\n", sum}'
find all the files in the current folder which are smaller than 9MB </s> find . -size -9k
find all normal/regular files in current folder and replace a word in all these files </s> find . -type f -print0 | xargs -0 sed -i '' 's/2013/2012/g'
Find all regular files with name pattern $filename under $fileloc directory tree </s> find "$fileloc" -type f -prune -name "$filename" -print
Checks compressed file integrity. </s> bzip2 -t file.bz2
Count the number of .java files in all folders rooted in the current folder </s> find . -name "*.java" | wc -l
Recursively copies 'src' to 'dest' preserving overwriting the existing files. </s> cp -nr src_dir dest_dir
Format "file.txt" as space separated columns 28 characters in width </s> cat file.txt | column -c 28 -s "\ "
Find all directories that start with stat </s> find . -type d –iname stat*
List all files/directories under current directory with 'FooBar' in their names ensuring white space safety </s> find . -name 'FooBar' -print0 | xargs -0
Represent current date in RFC 3339 format with precision to seconds and save it to 'timestamp' variable </s> timestamp=`date --rfc-3339=seconds`
Add variable 'v' with value '5' to a temporary environment, list this environment using 'less' to interactively view it. </s> v=5 env|less
Find all the files in file system which are modified 50 days back </s> find / -mtime 50
Find files in entire file system that are writable by group or other </s> find / -perm /g+w,o+w
split content all files file1..40000 into pieces per 1445 lines named as outputprefixNNN as digital prefix </s> cat file1 file2 ... file40000 | split -n r/1445 -d - outputprefix
Open all files named 'filename' with 'nano' editor in the entire filesystem </s> find / -name filename -exec nano '{}' \;
Locates 'gcc' executable file, strips last two parts of the full path, adds '/lib' to the end and saves result in 'libdir' variable. </s> libdir=$(dirname $(dirname $(which gcc)))/lib
Send SIGTERM signal to entire process tree starting from ID 24901 and below. </s> kill `pstree -p 24901 | sed 's/(/\n(/g' | grep '(' | sed 's/(\(.*\)).*/\1/' | tr "\n" " "`
Find all files/directories under '/var/tmp' directory tree that belong to a user with user id 1000 </s> find /var/tmp -uid 1000
display all the files in the current folder that have been modified in the last 24 hours </s> find  -mtime -1
Print first field from semicolon-seprated line <line>. </s> echo "<line>" | cut -d ";" -f 1
Print the /proc directory tree, ignoring the PID-process things </s> find /proc -type d | egrep -v '/proc/[0-9]*($|/)' | less
Creates temporary folder in a $temp_dir folder with name pattern defined by $template, and stores path to created folder in 'my_temp' variable. </s> $ my_temp_dir=$(mktemp -d --tmpdir=$temp_dir -t $template)
Removes all files like '*.bak' in a current folder, and prints messages about what is being done. </s> rm -v *.bak
Find all files in the home directory tree that are owned by another user </s> find ~ ! -user ${USER}
Remount "/dev/block/mtdblock3" on "/system" with read and write permission </s> mount -o remount,rw -t yaffs2 /dev/block/mtdblock3 /system
find all the files in the file system which belong to the user "pat" and with the name "dateiname" </s> find / -user pat -iname "Dateiname"
Find and the 5 largest regular files in the Downloads folder of tecmint's home directory and output the file sizes in bytes. </s> find /home/tecmint/Downloads/ -type f -printf "%s %p\n" | sort -rn | head -n 5
List all mounted filesystems </s> mount
Display differences between directories dir1 and dir2, treating absent files as empty. </s> diff -Naur dir1/ dir2/
display all the normal/regular files in the current folder and do not go beyond 3 levels </s> find . -maxdepth 3 -type f
find all the text files in the entire filesystem which belong to the user root and display the ten files. </s> find / -user root -iname "*.txt" | head
display all the files in the current folder that end with ".ksh" </s> find . -name "*.ksh" -prune
Find all regular files in the current directory tree that have been modified within the last 10 minutes </s> find . –type f -mmin -10
Prints line count of each file within current directory. </s> find . -type f -print0 | xargs -0L1 wc -l
Change permissions to u=rw,g=r,o= for all files in the current directory tree </s> find . -type f -exec chmod u=rw,g=r,o= '{}' \;
Saves location of file $1 in 'dir_context' variable. </s> dir_context=$(dirname -- "$1")
Find all files/directories that start with 'onlyme' in their names under maximum 2 levels down the current directory </s> find . -maxdepth 2 -name 'onlyme*'
Copy all files matching "*failed.ipynb" in the current directory tree to "./fails" preserving the directory hierarchy </s> find . -name "*failed.ipynb" | cpio -pd ./fails
Get the disk space used by all *.txt (case insensitive) files/directories under folder 1 and folder2 </s> find folder1 folder2 -iname '*.txt' -print0 | du --files0-from - -c -s | tail -1
find all regular files which have been modified in the last 48 hours in home folder </s> find ~ -type f -mtime -2
Search for all files newer than file /tmp/t </s> find / -newer /tmp/t
display all the regular/normal files in the current directory which are atleast 2 levels deep </s> find . -mindepth 2 -type f
Create a symbolic link relative to link location named "$dest_dir/$orig_name" to "$orig_dest" </s> ln -r -s "$orig_dest" "$dest_dir/$orig_name"
Find files that were accessed in less than a day ago </s> find / -atime -1
Find all files under current directory and search for 'something' in those files </s> find . -print | xargs grep something
display all the text files in the current folder </s> find -name “*.txt”
delete all the files in the current folder which are bigger than 1KB </s> find . -size +1024 ?print|xargs -i rm \;
Search the entire file hierarchy for files ending in '.old' and delete them. </s> find / -name "*.old" -delete
finda all the hidden files excluding those having the extension htaccess </s> find . -type f \( -iname ".*" ! -iname ".htaccess" \)
Find all configration files in Home directory & Subtitute permanently in files </s> find $HOME -name "*.conf" -exec sed -i 's/vermin/pony/g' {} \;
find all regular files exclude .o and exclude *.swp and output line number of soc_attach if it has </s> find .  \( ! -path "./output/*" \) -a \( -type f \) -a \( ! -name '*.o' \) -a \( ! -name '*.swp' \) | xargs grep -n soc_attach
extract /path/to/my_archive.tar.xz to /path/to/extract and preserve permissions. </s> tar xpvf /path/to/my_archive.tar.xz -C /path/to/extract
Add "Line of text here" on top of each *.py files under current directory </s> find . -name \*.py | xargs sed -i '1a Line of text here'
Search the files from the current directory tree for "chrome" </s> find . | xargs grep 'chrome'
find all the files in the current folder that have been accessed in today from the start of the day </s> find -daystart   -atime 0
Gets string with MAC addess of network interface eth0. </s> ifconfig eth0 | grep HWaddr
Send 4 ping requests to host "google.comz", displaying only the summary info after the last request completed. </s> ping -c 4 -q google.comz
Change to directory listed in file '$HOME/.lastdir' </s> cd `cat $HOME/.lastdir`
find all files with pattern` '*.mp3' </s> find / -name *.mp3
Find files/directories that isn't owned by the user 'apache' under /var/www </s> find /var/www ! -user apache -print0 | xargs -0
Print every two lines in "file" on a single line separated by a space </s> cat file | paste -d' ' - -
find all the directories in the different folders excluding search in the sub directories and create these folders in the current directory </s> find /media/New\ Volume/bhajans -maxdepth 1 -type d | xargs -0 mkdir -p
Delete recursively empty files named 'bad' </s> find . -name bad -empty -delete
Find regular files matching pattern "*oraenv*" and excecute the "file" utility for each of them </s> find . -name "*oraenv*" -type f -exec file {} \;
Page through the contents of yourFile, adding a $ at the end of each line and replacing tab characters by ^I. </s> cat -vet file | less
Find empty files and directories </s> find . -empty
Grab the output of "basename" (the last slash-separated section of variable "filename") and echo it to stdout, which basename would do by default anyway. </s> echo `basename "$filename"`
display all the directories in the current folder which start with processor followed by digit and ends with .1 or .2 </s> find . -type d -regextype posix-egrep -regex '\./processor[[:digit:]]*/10\.(1|2)'
Find all files/directories named 'apt' in the entrie filesystem </s> find  / -name "apt"
Run an awk program on every TXT file found in the current directory tree </s> find . -name "*.txt" -print -exec awk '$9 != "" {print; if(NR > 9) exit; }' {} \;
Remove all files named tmp or ending in .xx that have not been accessed for seven or more 24-hour periods </s> find / \( -name tmp -o -name '*.xx' \) -atime +7 -exec rm {} \;
Find all directories in the current one with "linkin park" in their names and copy them to /Users/tommye/Desktop/LP </s> find . -maxdepth 1 -type d -iname "*linkin park*" -exec cp -r {} /Users/tommye/Desktop/LP \;
Print whether the sorted contents of "set1" and "set2" differ </s> diff -q <(sort set1) <(sort set2)
Print a minimal set of differences between files in directories "a" and "b", ignore the first 3 lines of output, and print any line starting with "-" with the first character removed </s> diff -dbU0 a b | tail -n +4 | grep ^- | cut -c2-
Query about which keys invoke the named function </s> bind -q complete
Add "Line of text here" on top of each *.py files under current directory </s> find . -name \*.py -print0 | xargs -0 sed -i '1a Line of text here'
display a long listing of all the empty files in the entire file system which are empty </s> find / -type f -size 0 -exec ls -l {} \;
display all the files in the file system which have been modified in the last 10 minutes </s> find / -mmin -10
List files larger than 10MB under /var/log /tmp that haven't changed in a month </s> find /tmp /var/tmp -size +30M -mtime 31 -ls
Change permissions to 0755 for all directories in the /path directory tree </s> find /path -type d -exec chmod 0755 "{}" \;
find all the files in the current folder which end with .o or with the name a.out and display them. </s> find . ( -name a.out -o -name *.o ) -print
Find SQL files with text `expression' </s> find . -name "*.sql" -print0 -type f | xargs -0 grep "expression"
Copies file 'file.txt' to each top-level directory in the current directory. </s> ls -d */ | xargs -iA cp file.txt A
find all the files that are not modified in the last 7 days </s> find -daystart -mtime +7
Change to directory 'foo' and print to terminal all received on standard input </s> cd foo | cat
create directory /var/svn as user root </s> sudo mkdir /var/svn
Create a symbolic link in "/bar/tmp/" for each file in directory "/foo" that does not start with "runscript" </s> find /foo -maxdepth 1 -type f ! -name 'runscript*' -exec ln -s {} /bar/tmp/ \;
Search everywhere for a file called `httpd.conf' that is newer than /etc/apache-perl/httpd.conf </s> find / -name httpd.conf -newer /etc/apache-perl/httpd.conf
Show manual of the find utility </s> man find
Search the current directory for all files with no 'read' privilege for 'others' </s> find . -maxdepth 1 ! -perm  -o=r
Prints week day of a 31 day in a current month. </s> cal | awk -v date=31 -v FIELDWIDTHS="3 3 3 3 3 3 3 3" 'NR==2 {split($0,a)} {for (i=1;i<=NF;i++) if ($i==date) print a[i]}'
find all the files which have the write permission to the group and remove the write permission. </s> find . -perm -20 -exec chmod g-w {} ;
Recursively add ".jpg" to all files in the current directory tree </s> find . -type f -exec mv '{}' '{}'.jpg \;
Compress every file in the current directory tree that matches "*cache.html" and keep the original file </s> find . -type f -name "*cache.html" -exec gzip -k {} \;
change the permissions of all the directories in the folder root_dir to 555 </s> find root_dir -type d -exec chmod 555 {} \;
find all the mp3 files in the current folder and move them to another folder </s> find . -name "*.mp3" -exec mv {} "/Users/sir/Music//iTunes/iTunes Media/Automatically Add to iTunes.localized/" \;
Find all *.gz files/directories under asia and emea directory </s> find asia emea -name \*.gz
Execute all arguments to a shell script and write the output to console and "$FILE" </s> $@ | tee $FILE
find all the files in the entire file system that have been accessed exactly  50 days ago </s> find / -atime 50
Create an empty file called "emptyfile.c" </s> cp /dev/null emptyfile.c
Find all foo.mp4 files in the current directory tree </s> find ./ -name "foo.mp4" -exec echo {} \;
Prints current directory name </s> pwd | grep -o "\w*-*$"
find files in the users home directory and for each one, ask the user to confirm to delete the file. </s> find $HOME/. -name *.txt -ok rm {} \;
Delete all files/directories with inode number 117672808 under current directory tree </s> find -inum 117672808 -exec rm {} \;
display list of all the hidden files in the directory "/dir/to/search/" </s> find /dir/to/search/ -name ".*" -ls
Give rwx permissions to the user and group of the directory named "files" leaving others without any privileges </s> find . -type d -name files -exec chmod ug=rwx,o= '{}' \;
Moves the file that named like file $1 from '/tmp' folder to the folder where $2 file is located. </s> mv "/tmp/`basename $1`" "`dirname $2`"
Make directory "~/practice" </s> mkdir ~/practice
find Texinfo source files in /usr/local/doc </s> find /usr/local/doc -name '*.texi'
Find all directories under /var/www directory and set their permission to 755 </s> sudo find /var/www -type d -print0 | xargs -0 chmod 755
Move all files that contain "Subject: \[SPAM\]" to "your_file" </s> mv $(grep -l 'Subject: \[SPAM\]' | awk -F ':' '{print $1}') your_file
Find all *.ogg (case insensitive) files/directories under your home directory that are not greater than 20MB in size </s> find $HOME -iname '*.ogg' ! -size +20M
Count number of users logged in </s> who | awk -F' ' '{print $1}' | sort -u | wc -l
Find all files under /path/to/dir and change their permission to 644 </s> find /path/to/dir -type f -exec chmod 644 {} +
List all SGID and SUID files in entire file system </s> find / -type f \( -perm -4000 -o -perm -2000 \) -ls
Processes all files recursively in /var/spool/cron/tabs folder and filters out all strings with '#'. </s> grep -v "#" -R  /var/spool/cron/tabs
Print out the contents of all *.txt files in the home directory </s> find ~/ -name '*.txt' -exec cat {} ;
Merge lines whose first comma-separated field in file 'in1' also appears as a first comma-separated in file 'in2' - both files must be sorted. </s> join -t, in1 in2
Show the number of lines for each .php and .phtml file in the current directory tree </s> find . -type f \( -name "*.php" -o -name "*.phtml" \) -exec wc -l {} +;
find all raw images in the current folder and pass them one at a time to the xargs command and enable parallel processing of the files </s> find . -type f -iname '*.CR2' -print0 | xargs -0 -n 1 -P 8 -I {}
Remove trailing white spaces from all files under current directory ignoring .git and .svn directories </s> find . -not \( -name .svn -prune -o -name .git -prune \) -type f -print0 | xargs -0 sed -i '' -E "s/[[:space:]]*$//"
Find the "param1" string in regular files under and below /var </s> find /var  -type f -exec grep "param1" {} \; -print
Counts all files in a current folder and subfolders. </s> find -type f -printf '\n' | wc -l
Remount "/dev/stl12" on "/system" as read and write </s> mount -o rw,remount /dev/stl12 /system
display all the html files in the current folder </s> find . -name "*.html" -print
Delete all *.zip files under current directory that are older than 2 days </s> find . -name "*.zip" -mtime +2 orint0 | xargs -0 rm
Find all regular files on the system whose size is greater than 20000k and print their names and sizes </s> find / -type f -size +20000k -exec ls -lh {} \; | awk '{ print $8 ": " $5 }'
Copy a comlex directory tree from one machine o another while preserving copy permissions and ownership </s> find . -depth -print | cpio -o -O /target/directory
ssh into "hostname" as user "buck" </s> ssh -l buck hostname
Archive "src" to "dst" without overwriting existing files in "dst" </s> rsync -a -v --ignore-existing src dst
Archive "path/to/working/copy" to "path/to/export" excluding files or directories named ".svn" </s> rsync -a --exclude .svn path/to/working/copy path/to/export
Find all file paths under current directory, perform a reverse sort and show first 10 file paths with their status change time </s> find . -type f -printf "%C@ %p\n" | sort -r | head -n 10
Search the current directory tree for files whose names match regular expression '.*packet.*', ignoring the case </s> find . -iregex ".*packet.*"
Remove all 'a.out', '*.o', and 'core' files in the current directory tree </s> find . \( -name a.out -o -name '*.o' -o -name 'core' \) -exec rm {} \;
Find all regular files starting from level 3 of directory tree ~/container and move them one level up </s> find ~/container -mindepth 3 -type f -execdir mv "{}" ./.. \;
Remove with prompting all files that have not been accessed in over 100 days </s> find /mydir -atime +100 -ok rm {} \;
Search for all files with either "sitesearch" or "demo" in their path names </s> find . | grep -i demo | grep -i sitesearch
find all the files in the home folder which are bigger than 2MB and zip them </s> find ~ -size +2000000c -regex '.*[^gz]' -exec gzip '{}' ';'
Recursively finds strings with 'word-1' or 'word-2' in any file under 'directory-path', following symlinks, and prints found strings. </s> egrep -R "word-1|word-2” directory-path
Count number of A records of domain '$domain' on nameserver '$server' and save value in 'result' variable </s> result="$(dig +short @"$server" "$domain" | wc -l)"
Finds all files in a '/path' folder and prints long listing for them. </s> find /path -type f -exec ls -l \{\} \;
Remove all files with names like "vmware-*.log" from the current directory tree </s> find . -name vmware-*.log -delete
Find all files in the /home/myuser directory recursively that are older than 7 days </s> find /home/myuser -mtime +7 -print
Display the contents of file 'filename' excluding lines starting with # or empty/space-only lines, waiting for user interaction after each page. </s> grep -v '^$\|^#\|^\s*\#' filename | grep -v "^[[:space:]]*$" | more
Search all *.c files from the current directory tree for "hogehoge" </s> find . -name \*.c -exec grep hogehoge {} \;
Adjust the timestamp of 'filename' by subtracting 2 hours from it. </s> touch -d "$(date -r filename) - 2 hours" filename
Find absolute path of command with PID "$pid" </s> readlink -f `ls --dereference /proc/$pid/exe`
Find all files/directories under current directory that are 10MB in size </s> find . -size 10M
Display the count of regular files for which the owner has read and execute permission under 'home/magie/d2' directory tree </s> find home/magie/d2 -type f -perm -u+rx | wc -l
Read a line from standard input into variable "i" with the prompt " Again? Y/n " </s> read -p " Again? Y/n " i
Rename recursively all files in the current directory tree that are called "article.xml" to "001_article.xml" </s> find . -name "article.xml" -exec rename 's/article/001_article/;' '{}' \;
kill all jobs </s> kill $(jobs -p)
Remount "/path/to/chroot/jail/usr/bin" as read only </s> mount -o remount,ro /path/to/chroot/jail/usr/bin
Find all build* directories under current directory and reverse sort them </s> find . -type d -name "build*" | sort -r
Print out the contents of all *.txt files in the home directory </s> find ~ -name '*.txt' -print0 | xargs -0 cat
Execute awk command '{ ...}' on compressed file "FILE" </s> zcat FILE | awk '{ ...}'
display all the files in the folders /etc /srv excluding the paths /etc/mtab and  /srv/tftp/pxelinux.cfg </s> find /etc /srv \( -path /srv/tftp/pxelinux.cfg -o -path /etc/mtab \)  -prune -o -print
Gets IP address of 'eth0' network interface. </s> ifconfig eth0 | grep -oP '(?<= inet addr:)[^ ]+'
Print lines 16225 to 16482 in file "file" </s> cat file | head -n 16482 | tail -n 258
Remove all *.log files from the current directory tree </s> find ./ -name '*.log' | xargs rm
display all the users in the current folder that belong to the group "sunk" </s> find . -type f -group sunk
Convert relative symbolic link "$link" to absolute symbolic link </s> ln -sf "$(readlink -f "$link")" "$link"
Find SGID files </s> find / -perm +g=s
Make directory "dir1" </s> mkdir dir1
Calculate the md5 sum of the list of files in the current directory </s> find . -maxdepth 1 -type f | md5sum
find all files in etc which have been changed in the last 25 hours </s> find /etc -ctime -1
Find all regular files named 'Waldo' under 'Books' directory tree that is located in user's home directory </s> find ~/Books -type f -name Waldo
Rename file extension '.andnav' (case insensitive) to '.tile' for all files/directories under current directory tree </s> find . -name "*.andnav" -exec rename -v 's/\.andnav$/\.tile/i' {} \;
Find all .txt files in the /home/user directory tree and copy them to /home/backup </s> find /home/user -name '*.txt' | xargs cp -av --target-directory=/home/backup/ --parents
Variable PID contains a process ID, send SIGTERM to this process if it exists. </s> kill $PID
Prints the Nth line of output from 'ls -1' </s> ls -1 | tail -n +N | head -n1
Find all files/directories named 'имя_файла' in the entire filesystem </s> find / -name "имя_файла"
Change permissions of directory "/home/sshtunnel/" to 555 </s> chmod 555 /home/sshtunnel/
Run .makeall.sh in an empty environment. </s> env -i ./makeall.sh
Remove directories in /media/1Tb/videos modified more than 7 days ago </s> find /media/1Tb/videos -maxdepth 1 -type d -mtime +7 -exec rm -rf {} \;
Find all empty directories under $somedir and copy /my/configfile into those directories </s> find "$somedir" -type d -empty -exec cp /my/configfile {} \;
Find all catalina* files/directories under current directory </s> find -name 'catalina*'
Mount "vfat" filesystem "/dev/sda7" to "/mnt/my_partition" with read and write permission, umask of files and directories set to "0000", and save in fstab and allow ordinary users to mount </s> sudo mount -t vfat -o rw,auto,user,fmask=0000,dmask=0000 /dev/sda7 /mnt/my_partition
find all the regular/normal files in the current direcoty which have not been accessed in the last 30 days. </s> find . -type f -atime +30 -print
Get the path of running Apache </s> ps -ef | grep apache
Create intermediate directories as required </s> mkdir -p $2
find all log files larger then 100MB  in /home directory and delete them . </s> find /home -type f -name *.log -size +100M -exec rm -f {} \;
Recursively finds all files older than 7 minutes under the current directory, saves list of found files, and compresses them, executing at most 10 compress process at a time. </s> find . -type f  -mtime +7 | tee compressedP.list | xargs -I{} -P10 compress {} &
Remove all *bak files under current directory with confirmation prompt </s> find . -name '*bak' -exec rm -i {} \;
Sets shell option 'globstar'. </s> shopt -s globstar
Search the files from directory tree "dirname" for string "foo" </s> find dirname  -print0 | xargs -0 grep foo
Find all files/directories under $1 which have at least read permission for their owner and set read permission for group for these files/directories </s> find "$1" -perm -u+r -print0 | xargs chmod g+r
List all *.txt files/directories under current directory </s> find . -name "*.txt" -print
show all the files in the entire file system which are bigger than 1.1GB </s> find / -size +1.1G
Delete all '-' character from $1 and save the resultant string to variable 'COLUMN' </s> COLUMN=`echo $1 | tr -d -`
Search for the case insensitive pattern 'PATTERN' in all files under current directory tree and display the matched files </s> find . -print | xargs grep -l -i "PATTERN"
Make directories to "/my/other/path/here/" as needed </s> mkdir -p /my/other/path/here/
Gets MAC address of 'eth0' network interface. </s> ifconfig eth0 | head -n1 | tr -s ' ' | cut -d' ' -f5
List (in long list format with inode number) the file under the current directory that has the oldest modification time </s> find . -type f -ls | sort +7 | head -1
Go to directory /some/where/long </s> cd /some/where/long
Search the current directory tree for files that are less than 50kb </s> find . -size -50k
Print the host name </s> hostname
prints the last non-empty line of a file </s> tac $FILE | grep -m 1 '.'
Replace all spaces with underscores in directory names under current directory. </s> find /tmp/ -depth -name "* *" -execdir rename 's/ /_/g' "{}" \;
Set 644 permission to all regular files under current directory </s> chmod 644 `find . -type f`
Find all the files whose name is FindCommandExamples.txt in the current working directory </s> find /root -name FindCommandExamples.txt
Sets 'extglob' shell variable. </s> shopt -s extglob
Save number of strings with $expression pattern in 'foo.txt' to 'big_lines' variable. </s> big_lines=`cat foo.txt | grep -c "$expression"`
Find all .java files starting from the current folder </s> find * -name "*.java"
Force create a hard link named "non_secret_file.txt" to "secret_file.txt" </s> ln -f secret_file.txt non_secret_file.txt
search for all the files in the current folder and sort them in the order of their depth and display the file names </s> find -type d -printf '%d\t%P\n' | sort -r -nk1 | cut -f2-
Send SIGWINCH process to current shell, causing it to update the LINES and COLUMNS variables which describe the size of the screen/window in characters. </s> kill -s WINCH $$
list all the ".ksh" files in the current directory </s> find . -ls -name "*.ksh"
List the directory paths of all file.ext files under present working directory </s> find . -name "file.ext" -execdir pwd ';'
Determine the user associated with stdin </s> who -m
Remove last two underscore-delimited fields and following characters in "t1_t2_t3_tn1_tn2.sh" keeping only "t1_t2_t3" </s> echo t1_t2_t3_tn1_tn2.sh | rev | cut -d_ -f3- | rev
display all the files in the directory modules </s> find . -name modules
Force delete all jpg files in current directory which are less than 50KB and do not search in the sub directories </s> find . -maxdepth 1 -name "*.jpg" -size -50k | xargs rm -f
search for a word in all the files in the current directory </s> find . -type f -exec grep 'needle' {} \;
Archive "/home/path" to "path" on host "server" showing progress and statistics and remove files in the destination not found in the source </s> rsync -a --stats --progress --delete /home/path server:path
Write output and error of "bash myscript.sh" to standard output and to "output.log" </s> bash myscript.sh 2>&1 | tee output.log
dispaly a long listing of all the files in the current folder which have been modified in the last 14 days </s> find . -mtime -14 -ls
Remove files under current directory with inode number $inum </s> find . -inum $inum -exec rm {} \;
Find all Subscription.java files/directories under current directory and enter into the parent directory of the first one found </s> cd $(find . -name Subscription.java -printf '%h\n')
Find all files under and below /dir that were changed or created less than 60 minutes ago </s> find /dir -cmin -60
Find all *.txt files under / and print their sizes and paths </s> find / -name '*.txt' -exec du -hc {} \;
Find all hidden directories starting from the current directory </s> find . -type d -name ".*"
display a long listing of all regular files  in current folder which have been modified in the last 60 minutes </s> find . -mmin -60 -type f -ls
Split standard input into files with at most 75 lines each </s> split --lines=75
Save directory "../../lib" relative to the executable "gcc" to variable "libdir" </s> libdir=$(dirname $(dirname $(which gcc)))/lib
Search the files from the current directory tree for "chrome" </s> find . -exec grep chrome {} \;
Find all directories in current directory without going into sub-directories </s> find . -type d -maxdepth 1
Show current date in "%Y-%m-%d" format </s> date "+%Y-%m-%d"
find all the files (under root file system /) that were changed within the last 24 hours </s> find / -ctime -1
Read a line from standard input into variable "dir" </s> read dir
Collapse double slashes in variable "dir" into a single one. </s> dir="`echo $dir | sed s,//,/,g`"
Find all *.csv files under /foot/bar/ and move them to some_dir </s> find /foot/bar/ -name '*.csv' -print0 | xargs -0 mv -t some_dir
Find all files owned by the user daniel in the current directory and below. </s> find . -user daniel
Saves exit statuses of piped commands in a system variable PIPESTATUS='([0]="0" [1]="0" [2]="1" [3]="0" [4]="1")' </s> true | true | false | true | false
find all the normal/regular files in the current folder which have been accessed in the last 24 hours and display a long listing of them </s> find . -type f -atime -1 -exec ls -l {} \;
Find all directories under $d directory and set read-write-execute permission for owner and group and no permission for other for those directories </s> find $d -type d -exec chmod ug=rwx,o= '{}' \;
Find all the files on the system that have been accessed within the last hour </s> find / -amin -60
Update the archive '2009.tar' with the files from the data/ directory tree that match pattern 'filepattern-*2009*' </s> find data/ -name filepattern-*2009* -exec tar uf 2009.tar {} ;
find all data files in current folder which have not been changed in the last 60 minutes and display their name without extension </s> find . -iregex "./[^/]+\.dat" -type f -cmin +60 -exec basename {} \;
Create a symbolic link in directory "new" for each file in "original" directory tree </s> find original -type f -exec ln -s {} new/{} \;
Archive "/path/to/copy" on host "remote.host" as user "user" to "/path/to/local/storage" updating files with different checksums, showing human readable progress and statistics, and compressing data during transmission </s> rsync -chavzP --stats user@remote.host:/path/to/copy /path/to/local/storage
Lists all manual pages. </s> apropos -r '.*'
Look for *.jpg files on the system </s> find / -name “*.jpg”
Print ls output for all non-empty files under under current directory </s> find . -type f ! -size 0 -exec ls -l '{}' \;
Print a randomly sorted list of numbers from 1 to 10 to file "/tmp/lst" and the screen followed by " -------" </s> seq 1 10 | sort -R | tee /tmp/lst |cat <(cat /tmp/lst) <(echo '-------')
find all the directories with the name "DIRNAME" in the current folder and force delete them </s> find . -type d -name “DIRNAME” -exec rm -rf {} \;
Give all directories in the /path/to/base/dir tree read and execute privileges </s> find /path/to/base/dir -type d -exec chmod 755 {} +
find all the files that have been modified in the last 12 hours </s> find ./ -mtime -0.5
change the owner of all the files in folder /u/netinst to netinst </s> find /u/netinst -print | xargs chown netinst
Find all *.txt files under /foo and delete them </s> find /foo -name "*.txt" -delete
Find all files/directories that start with 'a1a2' and end with 'txt' in their names and move their parent directories to '/home/spenx/dst/' directory </s> find /home/spenx/src -name "a1a2*txt" | xargs -n 1 dirname | xargs -I list mv list /home/spenx/dst/
Calculate the md5 sum of "password" </s> echo "password" | md5sum
Print a sorted list of the extensions of the regular files from the current directory tree </s> find . -type f | sed -e 's/.*\.//' | sed -e 's/.*\///' | sort -u
Read a line from standard input into variable "foobar" and suppress showing user input </s> read -s foobar
Print all unique file paths under "dir1" compared to "dir2" </s> comm -23 <(find dir1 -type f | sed 's/dir1/\//'| sort) <(find dir2 -type f | sed 's/dir2/\//'| sort) | sed 's/^\//dir1/'
Count the number of lines in every regular .rb file in the current directory tree </s> find . -name "*.rb" -type f -exec wc -l \{\} \;
Connect to host "remotehost" as ssh user "user" to copy remote file "/location/KMST_DataFile_*.kms" to current directory on local host. </s> scp -v user@remotehost:/location/KMST_DataFile_*.kms
Search the /root directory recursively for the regular file named "myfile" </s> find /root/ -name myfile -type f
find all the png files in current folder which are present in the pattern list file "search.txt" and copy them to another directory </s> find . -name '*.png' | grep -f <(sed s?^?/[0-9]_[0-9]_[0-9]_? search.txt) | xargs -i{} cp {} /path/to/dir
Find all directories under /var/www/some/subset and set their SGID bit </s> sudo find /var/www/some/subset -type d -print0 | xargs -0 chmod g+s
Extract protocol part from URL. </s> echo "$url" | cut -d':' -f1
Print file type of the executable file of command "foo" </s> file $(which foo)
Find all files/directories with 'my key phrase' in their names under current directory </s> find . -name '*my key phrase*'
searches through the root filesystem ("/") for the file named Chapter1. </s> find / -name Chapter1 -type f
find all the files in the file system which hae set uid enabled and save them to /root/suid.txt and those which have size greater than 100MB save them to /root/big.txt </s> find /    \( -perm -4000 -fprintf /root/suid.txt '%#m %u %p\n' \) , ( -size +100M -fprintf /root/big.txt '%-10s %p\n' \)
Print a NULL-separated list of all hidden regular files from the home directory </s> find $HOME -maxdepth 1 -type f -name '.*' -print0
Recursively change the user and group of all files in "/var/log/jenkins" to "root" </s> chown -R root:root /var/log/jenkins
Copy all .patch files from the current directory tree to patches/ </s> find -name '*.patch' -print0 | xargs -0 -I {} cp {} patches/
Compress all files with '.txt' extension under current directory </s> echo *.txt | xargs gzip -9
Display the named characters in "line1\r\nline2" </s> echo -e "line1\r\nline2" | awk '{ print $0; }' | od -a
Find all level 1 subdirectories of the current directory </s> find . -maxdepth 1 -type d
Copy directory structure from directory 'olddir' to 'newdir' </s> find olddir -type d -printf "newdir/%P\0" | xargs -0 mkdir -p
Find files larger than 100MB in /var/www and exclude files with /download/ in their path from the output </s> find /var/www/ -type f -name "*" -size +100M -exec du -h '{}' \;|grep -v /download/
Count the number of non localhost users </s> who | grep -v localhost | wc -l
display all files in current folder using regular expression </s> find -regex "$rx"
search for a word in all the regular files in the current folder. </s> find -type f -print0 | xargs -r0 grep -F 'example'
Search for all .html files in directory "www" and output only the basename (without containing path) of each. </s> find www -name \*.html -type f -exec basename {} \;
Search the current directory tree for files whose names begin with "my" and end with "p" followed by any character </s> find . -regex ".*/my.*p.$"
Copy all .txt files from the dir/ directory tree along with their parent directories hierarchy </s> find dir/ -name '*.txt' | xargs cp -a --target-directory=dir_txt/ --parents
Copy all files named 'script.sh' in directory 'olddir' to directory 'newdir' </s> find olddir -name script.sh -printf "%p\0" -printf "newdir/%P\0" | xargs -0L2 cp -n
Connect to host "${HOSTNAME}" as user "${USERNAME}" and execute "${SCRIPT}" non-interactively </s> ssh -l ${USERNAME} ${HOSTNAME} "${SCRIPT}"
Make directory "certs" </s> mkdir certs/
List all *.txt files/directories under current directory </s> find . -name '*.txt' -exec echo "{}" \;
Recursively change ownership of "/usr/local/lib/node_modules" to the current user </s> sudo chown -R `whoami` /usr/local/lib/node_modules
Change directory to the directory containing the "oracle" executable </s> cd $(dirname $(which oracle))
Count total number of lines in all *txt files  in current directory </s> wc -l `find . -type f -name '*.txt' `
Display kernel release name. </s> uname -r
Find all regular files 1 level down the $dir directory </s> find $dir -maxdepth 1 -type f
Show a listing of files not modified in over 20 days or not accessed in over 40 days </s> find /mydir \(-mtime +20 -o -atime +40\) -exec ls -l {} \;
Prints number of files with extension "${EXTENSION}" in the "${SEARCHPATH}" directory. </s> echo "Number files in SEARCH PATH with EXTENSION:" $(ls -1 "${SEARCHPATH}"/*."${EXTENSION}" | wc -l)
Save a unique list of the currently logged in usernames to variable "line" </s> line=$(who | cut -d' ' -f1 | sort -u)
Find all directories under ~/code excluding hidden directories and replace all newlines with : in the output then remove the last : </s> find ~/code -type d -name '[^\.]*' | tr '\n' ':' | sed 's/:$//'
For each item in array "alpha", display the basename, that is the part following the last slash, or the whole item if no slash is present. </s> basename -a "${alpha[@]}"
Find all files called "file1.txt" that reside under and below /home/wsuNID/ </s> find /home/wsuNID/ -name file1.txt
List all files in entire file system that are newer than the file $newerthan and older than the file $olderthan and sort them according to file modification time </s> find / -type f -name "*" -newermt "$newerthan" ! -newermt "$olderthan" -printf "%T+\t%p\n" | sort | awk '{print $2}'
find httpd.conf file in /etc directory </s> find /etc -name "httpd.conf"
Delete all files with '.old' extension under current directory tree </s> find . -name “*.old” -exec rm {} \;
Change permissions of all files ending in ".php" under the current directory to 755 and print a count of modified files </s> find . -name "*.php" -exec chmod 755 {} \; -exec /bin/echo {} \; | wc -l
Remount the root file system with read and write permission </s> mount -o rw,remount -t rootfs /
find all the core files in the temp folder and force delete them </s> find /tmp -name core -type f -print | xargs /bin/rm -f
Search for the extened regex 'expr' in all files with '.c' and '.h' extension under current directory tree </s> find . -name '*.[ch]' | xargs grep -E 'expr'
List all regular files from the current directory tree that were modified less than 60 minutes ago </s> find . -type f -mmin -60 -print0 | xargs -r0 ls -l
display all the files in the folder /mp3-collection which are bigger than 10MB or which start with the name "Metallica" </s> find /mp3-collection -name 'Metallica*' -or -size +10000k
Create empty files (or update timestamps if they exist) with names matching each word in variable "correctFilePathAndName" </s> echo -e "$correctFilePathAndName" | xargs touch
Find files patching "pattern" </s> find . -name "pattern" -print
Set variable PING to 1 if it's possible to ping host ADDRESS, to 0 otherwise. </s> PING=$(ping ADDRESS -c 1 | grep -E -o '[0-9]+ received' | cut -f1 -d' ')
find all files in current folder and display the total lines in them </s> find . | xargs wc -l
Find all files/directories under current directory tree that are newer than backup.tar.gz by modification time </s> find . -newer  backup.tar.gz
Count the *.html files residing in the /usr/src directory tree and containing string "foo" </s> find /usr/src -name "*.html" | xargs grep -l foo | wc -l
Find all *.rb files/directories under current directory </s> find . -name '*.rb'
Replace each new line in "INPUT.txt" with ":" </s> paste -sd: INPUT.txt
find all the files in the home folder which have not been modified in the last 1 year. </s> find $HOME -mtime +365
search for files in current folder using regular expressions </s> find ./ -regex '.*\..*'
Rotates the dirs stack so that the second directory (counting from the right of the list shown by `dirs', starting with zero) is at the top. </s> pushd -2
find all text files in current folder; which have been modified exactly 5 days ago </s> find . –name "*.txt" –mtime 5
Make directory "/tmp/imaginary/" on remote host before archiving "file" to "user@remote:/tmp/imaginary/" </s> rsync -aq --rsync-path='mkdir -p /tmp/imaginary/ && rsync' file user@remote:/tmp/imaginary/
Save list of groups which user $line belongs to and not matching pattern "_unknown|sciences|everyone|netaccounts" in 'results' variable </s> results=$(groups "$line" | tr ' ' '\n' | egrep -v "_unknown|sciences|everyone|netaccounts")
Make directory "TestProject" </s> mkdir TestProject
Move all files from the `sourceDir' directory to the `destDir' directory </s> find sourceDir -mindepth 1 -maxdepth 1 -print0 | xargs -0 mv --target-directory=destDir
Find all directories under $1/.hg and set their SGID bit </s> find "$1"/.hg -type d -print0 | xargs chmod g+s
Find all regular files under current directory tree whose names end with 'cache' or 'xml' or 'html' </s> find . -type f \( -name "*cache" -o -name "*xml" -o -name "*html" \)
Print unique lines of sorted file "A.txt" compared to sorted file "B.txt" </s> comm -23 <(sort -u A.txt) <(sort B.txt)
Output all lines that have a common first colon-separated field in files 'selection2.txt' and 'selection1.txt' by displaying the common (first) field of each line, followed by the extra fields in both lines. </s> join -t: selection2.txt selection1.txt
Search the current directory tree for regular files that contain "string" </s> find . -type f -printf '"%p"\n' | xargs grep string
Search all regular files in the current directory tree for "string" </s> find . -type f | xargs -d '\n' grep string
Report only total size of file systems in terabytes. </s> df -m | awk '{ SUM += $2} END { print SUM/1024/1024"TB" }'
List all files from the current directory tree that were modified less than 60 minutes ago </s> find . -mmin -60 | xargs -r ls -l
remove all the core files in the temp file after user confirmation </s> find /tmp -name core -type f -print0 | xargs -0 /bin/rm -i
find all the files that have been modified in the last 24 hours </s> find . -type f -mtime -1
Saves value '1' in the $PIPESTATUS variable and returns 0. </s> false | tee /dev/null
display all files in the folder /usr and its sub directory(do not search beyond the sub directory) </s> find /usr -maxdepth 1 -print
Find the .groovy files outside the "./target" directory path </s> find .  -name "*.groovy" -not -path "./target/*" -print
Find all directories under media/ directory and change their permission to 700 </s> find media/ -type d -exec chmod 700 {} \;
Display hardware platform, ie. x86_64 even if current kernel uses 32-bit addressing. </s> uname -i
Search the current directory tree for *.c and *.sh files </s> find . -type f \( -name "*.c" -o -name "*.sh" \)
Converts all windows line endings to unix line endings </s> find $(pwd) -type f | xargs -I xxx sed -i 's/\r//g' xxx
Find all files under /home/myfolder that match the regex 'abc.*def.*ghi' in their contents </s> find /home/myfolder -type f -print0 | xargs -0 grep -l -E 'abc.*def.*ghi'
List *.pl directories in the current directory tree </s> find . -name "*.pl" -exec ls -ld {} \;
change user and group of the file bin to user and group root:wheel </s> sudo chown root:wheel bin
Find and remove all .core files </s> find / -name "*.core" | xargs rm
tar all the regular java files to myfile.tar </s> find . -type f -name "*.java" | xargs tar cvf myfile.tar
Find files that were modified more than 7 days ago but less than 14 days ago and archive them </s> find . -type f -mtime +7 -mtime -14 | xargs tar -cvf `date '+%d%m%Y'_archive.tar`
Wrap each line in "file.txt" to fit in 80 characters </s> fold -w 80 file.txt
Gets IP address of ${NET_IF} network interface. </s> NET_IP=`ifconfig ${NET_IF} | grep -Eo 'inet (addr:)?([0-9]*\.){3}[0-9]*' | grep -Eo '([0-9]*\.){3}[0-9]*' | grep -v '127.0.0.1'`
Pipe content of 'somedata.txt' file to the input of command "$outfile" </s> cat somedata.txt | "$outfile"
Create an empty index.html in each directory under the current one, updating timestamps of already existing index.html files. </s> find . -type d -exec touch {}/index.html \;
Find all files under current directory with their size and paths, reverse sort them numerically, then print the 2nd field (with space as the delimiter) of the first 4 entries </s> find -type f -printf "%s %p\n" | sort -nr | head -n 4 | awk "{print $2}"
find all the regular/normal files in the /path folder and delete them </s> find /path -type f -delete
Print a line of 10 '#' characters </s> seq  -f "#" -s '' 10
Find all *.java files in the current directory tree </s> find . -name  \*.java
Search all variables and their values for "NAME" </s> env | grep NAME
Move "phantomjs-1.8.1-linux-x86_64.tar.bz2" to "/usr/local/share/" directory </s> sudo mv phantomjs-1.8.1-linux-x86_64.tar.bz2 /usr/local/share/.
search files  in the file system excluding those in the paths "10_Recommended" and "/export/repo" </s> find / -name whatever -not -path "/10_Recommended*" -not -path "/export/repo/*"
Append "\r" on each line of file "input" and display the printable characters </s> sed 's/$/\r/g' input |od -c
Set the bash environmental variable "PROMPT_COMMAND" to save the output of the last executed command to variable "LAST" and file '/tmp/x" </s> PROMPT_COMMAND='LAST="`cat /tmp/x`"; exec >/dev/tty; exec > >(tee /tmp/x)'
Update the archive '2009.tar' with the files from the data/ directory tree that match pattern 'filepattern-*2009*' </s> find data/ -name filepattern-*2009* -print0 | xargs -0 tar uf 2009.tar
Find files on the system whose names begin with either x or X </s> find / -name "[Xx]*"
Find files on the system modified more than 90 minutes ago </s> find / -mmin +90
Find files/directories with exactly read,write and execute permission for all (owner, group and others) under /path </s> find /path -perm ugo+rwx
Search for files/directories with the case insensitive pattern anaconda.* in /var/log </s> find /var/log/ -iname anaconda.*
Find all directories under /path/to/base/cache, /path/to/base/tmp, /path/to/base/logs  and change their permission to 755 </s> find /path/to/base/cache /path/to/base/tmp /path/to/base/logs -type d -exec chmod 755 {} +
Compare column 3 with column 2 of the next line in "file" and format output as a table </s> awk 'NR==1 { print; next } { print $0, ($1 == a && $2 == b) ? "equal" : "not_equal"; a = $1; b = $3 }' file | column -t
Find files under current directory that are newer than $date_time in regards of modification time </s> find . -type f -newermt "$date_time"
Find all files/directories with 664 permission under current directory tree </s> find -perm 664
Find all .sql files in the current directory recursively and print their path names separated by zeroes </s> find . -name '*.sql' -print0
Greps DNS zone transfer info on domain localdomain.com from NS @dc1.localdomain.com, finds strings with any-cased word 'Lawler' and strips last letter from each string. </s> VAR=`dig axfr @dc1.localdomain.com localdomain.com | grep -i Lawler | awk '{ getline ; $1=substr($1,1,length($1)-1); print $1 ; exit }'`
Change user to "amzadm" and group to "root" of "/usr/bin/aws" </s> chown amzadm.root  /usr/bin/aws
Delete all regular files under $DIR directory tree that have been modified before file $a </s> find "$DIR" -type f \! -newer "$a" -exec rm {} +
Find all files/directories under current directory that were modified exactly 30 minutes ago </s> find . -mmin 30
Find all files under /home/username/public_html/sites/default/files and set their permission to 660 </s> find /home/username/public_html/sites/default/files -type f -exec chmod 660 {} +
Display the first 10 lines of the byte hex dump with no file offset data for "/bin/ls" </s> od -t x1 -An /bin/ls | head
Move all regular files under current directory to ./newdir </s> find ./ -type f -print | xargs    -i mv -f {} ./newdir
Create a new directory "existing-dir/new-dir/" on host "node" </s> rsync /dev/null node:existing-dir/new-dir/
Search the files residing in the current directory tree whose names contain "bills" for "put" </s> find . -name '*bills*' -exec grep -H "put" {} \;
Remove files that are less than 1MB in size under current directory </s> find . -type f -size -1M -exec rm {} +
List all files with their modification time in entire file system that are newer than the file $newerthan and older than the file $olderthan in regards of modification time and sort them according to file modification time </s> find / -type f -name "*" -newermt "$newerthan" ! -newermt "$olderthan" -printf "%T+\t%p\n" | sort
Search for utility "foo" in PATH, display its file type description. </s> file $(which foo)
List all nfs mounts </s> mount -l -t nfs4
Interactively display all lines containing 'word' in all files whose name ends with .properties in the current directory, waiting for user input after each page. </s> grep -R 'word' *.properties | more
Make a copy of file.txt in all directories in current directory - names may not contain spaces. </s> ls -d */ | xargs -iA cp file.txt A
Change all directories under "./bootstrap/cache/" to owner "apache" and group "laravel" </s> sudo find ./bootstrap/cache/ -type d -exec chown apache:laravel {} \;
Search for files/directories with the case insensitive pattern anaconda.* in var/log directory and create an archive (file.tar) of all the files found </s> find var/log/ -iname "anaconda.*" -exec tar -rvf file.tar {} \;
search in the current folder for all the regular/normal file with the name "test" </s> find . -type f -name test
Find all files/directories in entire file system for which owner has at least read/write permissions, or the group has at least read permission, or others have at least read permission </s> find / -perm /u+rw,g+r,o+r
Print the names of all files in or below the current directory, with all of the file permission bits S_ISUID, S_ISGID, and S_IWOTH set </s> find . -perm -o+w,+s
Get the number of regular files in the directory given as the bash script argument $1 </s> find $1 -type f | wc -l
Look for regular files in the directory trees 'deferred', 'active', 'maildrop', 'incoming' under /var/spool/postfix/ </s> find /var/spool/postfix/{deferred,active,maildrop,incoming}/ -type f
Send 5 pings to broadcast address "10.10.0.255" and print the unique IPs who responded </s> ping -c 5 -b 10.10.0.255 | grep 'bytes from' | awk '{ print $4 }' | sort | uniq
Display all lines containing PROBES in the current kernel's compile-time config file. </s> grep PROBES /boot/config-$(uname -r)
Search for files/directories which are writable by both their owner and their group </s> find . -perm -g+w,u+w
Find all the files whose permissions are 777 under current directory </s> find . -type f -perm 0777 -print
find all the ".c" files in the folder "/home/you" which have been accessed in the last 30*24 hours </s> find /home/you -iname "*.c" -atime -30 -type -f
Find & calculate total number of worlds in all .txt file from current directory </s> find .  -type f  -name '*.txt' -exec wc -w {} \; | awk '{total += $1} END{print total}'
Print the list of files and directories of the current directory </s> find . ! -name . -prune
Remove files that are greater than 1MB in size under current directory </s> find . -type f -size +1M -exec rm {} +
display all the directories in the current folder excluding those that are present in the aa directory tree </s> find . -type d -name aa -prune -o -print
Finds strings matching pattern '^fields=\\\|^var=' in a 'set' output. </s> set | grep ^fields=\\\|^var=
Search for 'foo' in all regular files under 'sources' directory tree and show the matched lines with filenames </s> find sources -type f -exec grep -H foo {} +
Recursively finds strings with"text string to search” in any file within the 'directory-path', following symlinks, and prints found strings with file names. </s> grep -r -H "text string to search” directory-path
Find all *text files/directories under current directory </s> find -name "*text"
Prints process tree of a current process with parents processes and id numbers. </s> pstree --show-parents -p $$ | head -n 1 | sed 's/\(.*\)+.*/\1/' | less
Find all directories under minimum 1 level down the current directory and set their permission to 755 </s> find  . -type d -mindepth 1 -print -exec chmod 755 {}/* \;
Count the number of characters in the list of regular files from the current directory tree </s> find . -type f | xargs | wc -c
Find all directories under /home/mywebsite/public_html/sites/all/modules and set their permission to 750 </s> find /home/mywebsite/public_html/sites/all/modules -type d -exec chmod 750 {} +
Print which files differ in "/tmp/dir1" and "/tmp/dir2" recursively </s> diff -qr /tmp/dir1/ /tmp/dir2/
find all the links in the current folder which are broken </s> find /target -type l -xtype l
Overwrite a file 'my-existing-file' with random data to hide its content </s> shred my-existing-file
List the directory paths of all *.ext (case insensitive) files under /path directory </s> find /path -type f -iname "*.ext" -printf "%h\n"
Find all text files in the home directory </s> find ~/ -name '*.txt'
change owner and group of the file "/path/to/yourapp" to root </s> chown -v root:root /path/to/yourapp
find all the files in the entire file system that have been modified exactly 7 days before which end with "conf" </s> find / -name "*conf" -mtime 7
Print the names of all hidden regular files from the current directory </s> find . -maxdepth 1 -type f -name '.*' -exec basename {} \;
Find all directories under /path/to/base/dir and change their permission to 755 </s> find /path/to/base/dir -type d -exec chmod 755 {} +
Find all the files which are modified in last 1 hour in entire file system </s> find / -mmin -60
Count non-blank lines in a file 'foo.c' </s> cat foo.c | sed '/^\s*$/d' | wc -l
Mount "/path/to/device" on "/path/to/mount/location" as a loop back device </s> mount /path/to/device /path/to/mount/location -o loop
Search for "ifconfig" in the output of "history" and print 5 lines that precede and follow </s> history | grep ifconfig -A5 -B5
Find all files under current directory and append a null character at the end of each of their paths </s> find -type f -print0
Find all files/directories under current directory tree that belong to the group 'compta' </s> find -group compta
Search the current directory and all of its sub-directory for any PDF files being careful to prevent the shell from expanding "*"  before it's passed to find. </s> find . -name \*.pdf -print
find all files under the current directory, filtering the output through a regular expression to find any lines that contain the word foo or bar. </s> find ./ | grep -E 'foo|bar'
Mount partition with label "WHITE" on "/mnt/WHITE" with read and write permission and have it accessible by user and group "test" </s> mount -L WHITE /mnt/WHITE -o rw,uid=test,gid=test
Change the owner of all files in "/empty_dir/" to "root" using at most 10 files at a time </s> ls /empty_dir/ | xargs -L10 chown root
Search the .VER files from the current directory tree for string "Test_Version=' </s> find . -name "*.VER" -exec grep 'Test_Version=' '{}' ';' -print;
Find all broken symlinks under current directory </s> find -xtype l
find all the files in the current folder which are bigger than 10MB and less than 50MB </s> find . -size +10M -size -50M -print
find all files in the file system which have not been accessed in the last 2 days </s> find / -atime +2
Find all *.pdf.marker files under ${INPUT_LOCATION} and move them to ${OUTPUT_LOCATION} also move any *.pdf files with the same name under current directory to ${OUTPUT_LOCATION} </s> find ${INPUT_LOCATION}/ -name "*.pdf.marker" | xargs -I file mv file $(basename file .marker) ${OUTPUT_LOCATION}/.
Find all *.srt files under directory named 'working' and show the first one found </s> find working -type f -name "*.srt" | head -1
find all the files in the current directory which are bigger than 1000MB </s> find . -size +1000M
display all the .sh scripts in the folder /usr </s> find /usr -name \*.sh
Print the character representations of 65 to 90 </s> seq 65 90 | awk '{printf("%c",$1)}'
Compress all files under current directory tree with gzip </s> find . -type f -print0 | xargs -0r gzip
Creates temporary file in a current folder with name formatted like 'templateXXXXXX', and saves path to it in 'tempfile' variable. </s> tempfile=$(mktemp $(pwd)/templateXXXXXX)
display all the files in the file system which are smaller than 20 bytes </s> find / -size 20
find all files in current folder having the name pattern "some_pattern" and move them to the folder target_location (GNU VERSION) </s> find . -name some_pattern -print0 | xargs -0 -i mv {} target_location
search for the file, filename.txt in the current folder ( case insensitive search ) </s> find . -iname filename.txt
Print a NULL-separated list of all directories of the current directory tree </s> find . -type d -print0
List all files in the /var directory tree whose size is greater than 10 megabytes </s> find /var/ -size +10M -exec ls -lh {} \;
Back up all *.txt files/directories in new files/directories with a .bak extension in their names under /etc directory </s> find /etc -name "*.txt" | xargs -I {} mv {} {}.bak
find md5sum of 'string to be hashed' </s> md5 -s 'string to be hashed'
Search for files/directories named 'fileName.txt' under '/path/to/folder' directory tree without traversing into directories that contain the string 'ignored_directory' in their paths </s> find /path/to/folder -path "*/ignored_directory" -prune -o -name fileName.txt -print
Prints the absolute directory path of the current script preceded by the string "dirname/readlink: " </s> echo "dirname/readlink: $(dirname $(readlink -f $0))"
search for the word "put" in all the files in the current folder which have the word "bills" in their name and display the matched line along with the filename. </s> find . -name '*bills*' -exec grep -H "put" {} \;
List environment variables whose name contains "X" </s> set | grep -oP '^\w*(?==)' | grep X
search for all the files in the current folder which start with "my" </s> find . -name 'my*'
Print numbers from 1 to 30 with equalized 0 padding </s> seq -w 30
Find regular non-hidden files containing `some text' in their names with hidden directories optimization </s> find . -type d -path '*/\.*' -prune -o -not -name '.*' -type f -name '*some text*' -print
Archive all *html files using tar. </s> find . -type f -name "*html" | xargs tar cvf htmlfiles.tar -
List unique series of 3 characters in file "$1" prefixed by the number of occurrences and sorted from most frequent to least frequent </s> fold -w3 "$1" | sort | uniq -c | sort -k1,1nr -k2
display all the header files  and cpp files in the current folder </s> find . -regex '.*\.\(cpp\|h\)'
Make directorie(s) 'es/LC_MESSAGES' as needed in the current directory </s> mkdir -p es/LC_MESSAGES
Find all files/directories named 'query' (case insensitive) under current directory </s> find -iname "query"
display all file in the home folder except ".c" files </s> find $HOME \! -iname "*.c" print
Print the contents of "foo.txt" starting with line 2 </s> tail -n +2 foo.txt
Delete all directories in the /myDir directory tree </s> find /myDir -type d -delete
Print the input "hello world" to the console followed by a swap of the first two awk fields </s> echo hello world | tee /dev/tty | awk '{print $2, $1}'
Print the last 10 commands in history </s> history | tail -n 10
display long listing of all the files that have been changed in the last 4 days, daystart is used to compare from the starting of day i.e, at 00:00 </s> find . -daystart -ctime 4 -ls -type f
Copy "/path/to/source" to '/path/to/dest' in remote "username@computer" </s> rsync -r /path/to/source username@computer:/path/to/dest
Finds only parts of echoed string that match with regex 'run-parts (-{1,2}\S+ )*\S+', and saves them in $match variable, each matched part on a separate line. </s> match=$(echo "${line}" | egrep -o 'run-parts (-{1,2}\S+ )*\S+')
Change directory to the download directory specified in the current user's user-dirs.dirs file </s> cd "$(grep DOWNLOAD $HOME/.config/user-dirs.dirs | cut -f 2 -d "=" | tr "\"" "\n" | tr -d "\n")"
List all .svn files/directories under current directory </s> find . -name .svn -exec ls {} \;
Display detailed usage help of the 'cp' (copy) command. </s> cp --help
Copy all files in the current directory tree matching "textToSearch" to "$destination_path" </s> find . -type f | xargs grep -l "textToSearch" | cpio -pV $destination_path
Find all *.c files on the system and feed the output to wc </s> find / -name *.c | wc
Search the /mnt/raid/upload directory tree for files that have not been modified within the last 5 days </s> find /mnt/raid/upload -mtime +5 -print
List the current directory recursively ignoring ./src/emacs/ and all its contents </s> find . -path ./src/emacs -prune -o -print
Replace all occurrence of "toreplace" with "replaced" in all files under /home/www </s> find . -maxdepth 1 -type f -print0 | xargs -0 sed -i 's/toreplace/replaced/g'
display all the files in the current folder </s> find . | xargs echo
find  js file which name is not  'glob-for-excluded-dir'  under current directory. </s> find . -name '*.js' -\! -name 'glob-for-excluded-dir' -prune
Search for the regex '->get(\|#hyphenate' in all files with '.pl' or '.pm' extension under '/users/tom' directory tree and only show the filenames </s> find /users/tom -name '*.p[lm]' -exec grep -l -- '->get(\|#hyphenate' {} +
list symbolic links under the directory "$directory" using contents of the $IFS variable between output of each one </s> find $directory -type l -printf "%p$IFS"
Print inode, permissions, size, and modification date of all files in the current directory tree as a list with an extra column prepended </s> tree -afispugD --inodes | awk '{FS="./"; ORS=""; printf("%-60s%s\n",$NF,$0)}'
Look for "filename" in the current directory and below </s> find -name filename
get md5sum of an iso file without displaying the filename, save value to 'md5' variable </s> md5=`md5sum ${my_iso_file} | awk '{ print $1 }'`
Find all files with the SUID bit set beginning with the root directory </s> find / -perm -u+s
Make directory "/etc/cron.15sec" </s> mkdir /etc/cron.15sec
Find files with the extension .conf in the /etc directory </s> find /etc -name '*.conf'
Print "I am USER and the program named ls is in LS_PATH" where "USER" is the current user's user name and "LS_PATH" is the full path of the command "ls" </s> echo I am $(whoami) and the program named ls is in $(which ls).
Recursively copy all (non-hidden) files and directories in current dir except "foo" to location specified by variable "other" </s> rsync --recursive --exclude 'foo' * "$other"
Search for file "file" with minimum depth set to 4 </s> find -mindepth 4 -name file
Find *.txt files in the current directory tree, ignoring paths ./Movies/*, ./Downloads/*, and ./Music/* </s> find . -type f -name "*.txt" ! -path "./Movies/*" ! -path "./Downloads/*" ! -path "./Music/*"
Search the current directory tree for files whose names do not end in "1" and "2" </s> find . -type f ! -name "*1" ! -name "*2" -print
Execute python script "test.py" with "LD_PRELOAD=./linebufferedstdout.so" and write the output to console and append to "test.out" </s> LD_PRELOAD=./linebufferedstdout.so python test.py | tee -a test.out
Search appended data in "logfile.log" for "something" with a timeout of 3 seconds </s> tail -f logfile.log | grep --line-buffered "something" | read -t 3
Remove all *~ files under current directory with confirmation prompt </s> find . -name '*~' -ok rm {} \;
Add executable permission to "pretty-print" </s> chmod +x pretty-print
find all the files (under root file system /) that were updated in the last 24 hours </s> find / -mtime -1
Calculate the total size of all *.jpg files in the directory tree </s> find . -name "*jpg" -exec du -k {} \; | awk '{ total += $1 } END { print total/1024 " Mb total" }'
Run command specified by $line, replace space (' ') with newline and save the output to variable 'arr' </s> arr=$( $line | tr " " "\n")
Look for files with wide open permissions </s> find . -type f  -perm a=rwx -exec ls -l {} \;
print all files in the current directory and all subdirectories </s> find .
Extract all gzip-compressed files from tar archives beginning with 'myfiles_split.tgz_*' </s> cat myfiles_split.tgz_* | tar xz
Find all files/directories with 777 permission under '/apps/audit' and strip write permission for 'other' from them </s> find /apps/audit -perm -7 -print | xargs chmod o‑w
Removes all files from current folder but 3 newest ones </s> ls -tQ | tail -n+4 | xargs rm
Search the /home/pankaj directory for regular files whose status has changed within the last 5 minutes </s> find /home/pankaj -maxdepth 1 -cmin -5 -type f
show all the files in the folder /etc which have been modified in the last 24 hours </s> find /etc -mtime -1
Read a line from standard input into variable "response" ignoring backslash escapes and using the prompt "Are you sure? [y/N] " </s> read -r -p "Are you sure? [y/N] " response
display all the normal/regular files in the directory FOLDER1 </s> find FOLDER1 -type f -print0
List the regular files of the current directory tree that contain string "texthere" </s> find -type f -exec grep -l "texthere" {} +
Move all *.data files/directories in $S directory to $S/data/ directory </s> find "${S}" -name '*.data' -exec mv '{}' "${S}/data/" \;
Print the current directory name without full path </s> echo "$PWD" | sed 's!.*/!!'
Recursively delete all files/folders named '.svn' in a current folder. </s> find . -name .svn -delete
Change the permissions of all regular files whose names end with .mp3 in the directory tree /var/ftp/mp3 </s> find /var/ftp/mp3 -name '*.mp3' -type f -exec chmod 644 {} \;
Find all directories under the current directory that is on the same filesystem, execute "/tmp/count_em_$$" with the directory as an argument, sort the result numerically from least value to greatest value </s> find . -mount -type d -print0 | xargs -0 -n1 /tmp/count_em_$$ | sort -n
Create compressed archive of all the files in the current directory tree that have been modified in the last 7 days </s> find . -type f -mtime -7 -print -exec cat {} \; | tar cf - | gzip -9
Counts lines in file 'filename' ignoring empty lines and lines with spaces only. </s> cat 'filename' | grep '[^ ]' | wc -l
search for the file "myfile" in the current folder and display all errors apart from permission denied error </s> find . -name myfile |& grep -v 'Permission denied'
Prints total count of lines of all *.py files in a current folder and subfolders. </s> find . -name "*.py" -exec wc -l {} \; | awk '{ SUM += $0} END { print SUM }'
Finds matched text in defined path recursively, but not follows symlinks. </s> grep -r "string to be searched"  /path/to/dir
Display the 5 largest files in the current directory and its sub-directories. </s> find . -type f -exec ls -s {} \; | sort -n -r | head -5
Find recursively the latest modified file in the current directory </s> find . -type f | sed 's/.*/"&"/' | xargs ls -E | awk '{ print $6," ",$7 }' | sort | tail -1
Force create a symbolic link named "$pdir" to "$pluginpath" with verbose output </s> sudo ln --symbolic --verbose --force "$pluginpath" "$pdir"
find all the files in the file system which have been modified in the last 30*24 hours </s> find / -mtime -30 -print
Calculate the md5 sum of all files in "/your/dir" including content and filenames and following symbolic links </s> grep -aR -e . /your/dir | md5sum | cut -c-32
display all the .sh scripts and perl files in the current folder </s> find . -type f \( -iname "*.sh" -or -iname "*.pl" \)
Save the system host name in variable "HOSTNAME" </s> HOSTNAME="`hostname`"
Find .java files in the current directory tree that contain 'TODO', and print their pathnames </s> find . -name "*.java" -exec grep -Hin TODO {} + | cut -d ":" -f 1
Find all the files whose permissions are 777 in the current directory </s> find . -type f -perm 0777 -print
Print all unique file paths under "dir1" compared to "dir2" </s> comm -23 <(find dir1 | sed 's/dir1/\//'| sort) <(find dir2 | sed 's/dir2/\//'| sort) | sed 's/^\//dir1/'
change the ownership of all regular/normal files in the current directory </s> find . -type f | xargs chown username
Print the commands that would execute "myfile" on all .ogv files from the current directory tree </s> find ./ -name *.ogv -exec echo myfile {} \;
Finds the folder where temporary files would be written to, and save path to it in a 'TMPDIR' variable. </s> TMPDIR=`dirname $(mktemp -u -t tmp.XXXXXXXXXX)`
Find all files under /mountpoint and below which have hard links </s> find /mountpoint -type f -links +1
Remove all *.mp3 files in tmp directory but not in it's subdirectories </s> find tmp -maxdepth 1 -name *.mp3 -print0 | xargs    -0 rm
Find all regular files under $FOLDER directory tree that start with '".' and end with '"' in their names and were modified in less than $RETENTION days excluding the files whose contents match one of the regular expressions defined per line in file $SKIP_FILE </s> find ${FOLDER} -type f ! -name \".*\" -mtime -${RETENTION} | egrep -vf ${SKIP_FILE}
Enables shell option 'nocasematch'. </s> shopt -s nocasematch
create a symbolic link named "www" to file "www1" </s> ln -s www1 www
remove all core files in the file system </s> find / -name "*.core" -print -exec rm {} \;
Search the current directory recursively for files containing "needle text" </s> find . -type f | xargs grep -I "needle text"
search for all regular/normal files in current folder and display all the files which contain 16 lines </s> find . -type f -print0 | xargs -0 grep -cH '' | awk -F: '$2==16'
Change the timestamp of symbolic link "somesymlink" to current date/time </s> touch -h somesymlink
copy all the regular/normal files from temp folder which have been modified in the last 30*24 hours to /tmp/backup </s> find /tmp -type f -mtime -30 -exec cp {} /tmp/backup \;
Print IP addresses of the host name </s> hostname --ip-address
Find all files and directories in the current directory tree except those whose name is "dirname", case insensitive </s> find ./ -iname ! -iname dirname
find all the files ending with undo in the current folder and calculate the total size of these files </s> find . -name "*.undo" -ls | awk '{total += $7} END {print total}'
Find all 777 permission directories and use chmod command to set permissions to 755 </s> find . -type d -perm 777 -print -exec chmod 755 {} \;
Print only the line "foo///" given two empty directories foo and bar </s> find foo/// bar/// -name foo -o -name 'bar?*'
List all *.txt files/directories under current directory ensuring white space safety </s> find . -name '*.txt' -print0|xargs -0 -n 1 echo
Display the number of regular files under current directory tree </s> find . -type f -print0 | tr -dc '\0' | wc -c
Report all files in /mydir1 and /mydir2 larger than 2000 blocks and accessed in over 30 days </s> find /mydir1 /mydir2 -size +2000 -atime +30 -print
Perform a dry run to recursively copy "test/a" to "test/dest" excluding "test/a/b/c/d" </s> rsync -nvraL test/a test/dest --exclude=a/b/c/d
Archive all ".txt" files in the current directory to "/path/to/dest" keeping partially transferred files </s> rsync -aP --include=*/ --include=*.txt --exclude=* . /path/to/dest
Print file name without extension assuming there is only one dot in the file name. </s> echo "$FILE" | cut -d'.' -f1
change the word "GHBAG" to "stream-agg" in all the file names in current folder which have the word "-GHBAG-" in their name </s> find . -name '*-GHBAG-*' -exec rename 's/GHBAG/stream-agg/' {} +
Search PATH for utilities called "rename", display the type of file (script, executable, ...) for each match found. </s> which -a rename | xargs readlink -f | xargs file
create an archive using pbzip2 as a compress program </s> tar -I pbzip2 -cf OUTPUT_FILE.tar.bz2 paths_to_archive
Delete all *txt files under current directory </s> find . -name "*txt" -type f -print | xargs rm
Print linker search path using gcc formatted on new lines </s> gcc -print-search-dirs | sed '/^lib/b 1;d;:1;s,/[^/.][^/]*/\.\./,/,;t 1;s,:[^=]*=,:;,;s,;,;  ,g' | tr \; \\012
Display the last dot-separated field, in this case "com". </s> echo 'maps.google.com' | rev | cut -d'.' -f 1 | rev
Recursively finds all "*.pas" and "*.dfm" files and prints strings with "searchtext" ignoring text distinctions, suppressing error messages, highlighting found patterns and preceding each found string with file name and string number. </s> find . -type f \( -name "*.pas" -o -name "*.dfm" \) -print0 | xargs --null grep --with-filename --line-number --no-messages --color --ignore-case "searchtext"
find the "MyCProgram.c" file (case insensitive find) under the current directory </s> find -iname "MyCProgram.c"
Find all *.page (case insensitive) files/directories under current directory and run ~/t.sh for each of them with the file path as argument, then sort the output </s> find . -iname *.page -exec ~/t.sh {} \; | sort
Search directory /path/to/check/ for regular files </s> find /path/to/check/* -maxdepth 0 -type f
Find the core files and  remove them </s> find . -name “core” -exec rm -f {} \;
Print "new.txt" with line numbers prepended and lines 3 and 4 deleted </s> cat new.txt  |  nl |sed  "3d;4d"
change user of the direct public_html to user owner and group nobody </s> chown owner:nobody public_html
Find all empty files in /tmp </s> find /tmp -type f -empty
Find all files/directories with '.js' extension under current directory tree excluding paths that contain the directory './directory' </s> find -name "*.js" -not -path "./directory/*"
Print a time stamp for each successful ping to "host" </s> ping host | awk '{if($0 ~ /bytes from/){print strftime()"|"$0}else print}'
Display the files/directories under current directory tree matching the regex '/$prefix$ypatt' where $prefix and $ypatt expands in the current shell </s> find . -print | grep "/${prefix}${ypatt}"
List the unique parent directories of all .class files found under "/root_path" </s> find /root_path -type f -iname "*.class" -printf "%h\n" | sort -u
Count non-blank lines in a file 'foo.c' </s> sed '/^\s*$/d' foo.c | wc -l
Find all *.p[lm] files under /users/tom directory that matches the regex '->get(\|#hyphenate' in their contents </s> find /users/tom -name '*.p[lm]' -exec grep -l -- '->get(\|#hyphenate' {} +
find all the files in the entire file system that have been modified between 50 to 100 days and display ten files </s> find / -mtime +50 -mtime -100 | head
Remove all empty sub-directories under current directory </s> find . -depth  -type d  -empty -exec rmdir {} \;
find all text files which have extra extensions in the current folder </s> find . -name '*.text' -exec $SHELL -c '[ ! -f ${1%.*} ]' $SHELL '{}' ';' -print
create directory dir1 </s> mkdir dir1
Compress all ".txt" files in all sub directories with gzip </s> gzip */*.txt
Print the user name of the current user </s> echo `whoami`
Find & Write Changes to a File and Print the Changes Using sed s//gpw </s> find . -type f -name "*.txt" -exec sed -n 's/Linux/Linux-Unix/gpw output' thegeekstuff.txt
List all *jsp and *java regular files found in the current directory tree </s> find . \( -name '*jsp' -o -name '*java' \) -type f -ls
Delete all __temp__* directories under maximum 1 level down the current directory tree </s> find . -maxdepth 1 -type d -name '__temp__*' -print0 | xargs -0 rm -rf
find all the html files in the current folder which have been modified excatly 7 days before </s> find . -mtime 7 -name "*.html" -print
Discard the first letter from every line in $line and calculate the md5 sum of the remaining </s> echo $line | cut -c2- | md5sum
Find all files/directories named 'testfile.txt' under current directory tree </s> find . -name testfile.txt
Extract, sort and print only group names from /etc/group. </s> cut -d: -f1 /etc/group | sort
find all the directories in the entire file system whose size is greater than 50KB </s> find / -type d -size +50k
Find all files under /somefolder matching the extended case insensitive regex '\./(.*\.error.*|second.*log|.*FFPC\.log)$' in their paths </s> find -E /somefolder -type f -iregex '\./(.*\.error.*|second.*log|.*FFPC\.log)$'
find all the files in the current folder which belong to the user root. </s> find . -user root -perm -4000 -print
Find all files under /var/www directory and set their permission to 644 </s> sudo find /var/www -type f -print0 | xargs -0 chmod 644
Search all *.txt files under ~/documents for the word "DOGS" </s> find ~/documents -type f -name '*.txt' -exec grep -s DOGS {} \; -print
Search for 'specific string' in all files matching the name pattern '“*.[txt|TXT]”' under current directory tree </s> find . -name “*.[txt|TXT]” -print | xargs grep “specific string”
Find all *foo* files/directories under current directory and copy them to /your/dest </s> find . -name "*foo*" | sed -e "s/'/\\\'/g" -e 's/"/\\"/g' -e 's/ /\\ /g' | xargs cp /your/dest
Copy "./export" recursively to "/path/to/webroot" preserving permissions </s> rsync -pr ./export /path/to/webroot
Finds strings with text "searched-string" recursively in all files of current folder. </s> grep -r "searched-string" .
Print a sorted list of the extensions of the regular files from the current directory tree matching pattern '*.???' </s> find . -type f -name "*.???" | awk -F. '{print $NF}' | sort -u
long list the detials of all the shell scripts in current directory </s> find . -name "*.sh" -exec ls -ld {} \;
Find all Read Only files </s> find / -perm /u=r
display all the files in the home folder that have been modified in the last 7*24 hours </s> find $HOME -mtime -7
Delete all empty directories and directories that contain only empty directories under current directory </s> find -type d -empty -exec rmdir -vp --ignore-fail-on-non-empty {} +
search for a word in all the regular/normal files in the entire filesystem. ( + is used to give more than one file as input to the grep command. </s> find / -type f -exec grep -i 'the brown dog' {} +;
Delete all files/directories in minimum 2 levels down the root directory </s> find root -mindepth 2 -delete
Filnd all files in root directory with 777 permission and change permision 644  with chmod commad . </s> find / -type f -perm 777 -print -exec chmod 644 {} \;
Gets a job with defined number back to the foreground. </s> fg 1
Recursively removes all files and folders named '.svn' in a current folder. </s> find . -name .svn -exec rm -rf {} \;
Find symlinks under and below the "test" directory and replace them with the content of the linked files </s> find test -type l -exec cp {} {}.tmp$$ \; -exec mv {}.tmp$$ {} \;
Find broken links using the file command on each symlinks in the system and searching for the keword 'broken' with grep </s> find / -type l -print0 | xargs -0 file | grep broken
Make directory "/var/svn" </s> sudo mkdir /var/svn
Find empty files in the test directory </s> find test -empty
split the file "file" into pieces per 2 lines </s> split -n2 infile
find all text files in the current folder </s> find -name "*.txt"
Convert Unix `cal` output to latex table code. </s> cal -h 02 2012| cut -c4-17 | sed -r 's/(..)\s/\0\t\&/g' | sed 's/$/\t\\\\/' | head -n-1 | tail -n +2
Find all 2*.data files/directories under jcho directory </s> find jcho -name 2*.data
Search the directory tree given as variable $root_dir for regular files </s> find $root_dir -type f
Force decompress all files into '/etc' </s> gzip -d --force * /etc
find all the configuration files in /etc folder along with the last access & modification time </s> find /etc -name "*.conf" -printf "%f %a, %t\n"
Print a listing of the `other' directory </s> find other -maxdepth 1 -printf "%P\n"
Print the contents of "xx.sh" </s> cat xx.sh
Replace newline with "_" in "file" then search for "_foo_" and output with "_" characters deleted </s> grep -o "_foo_" <(paste -sd_ file) | tr -d '_'
Creates temporary file by template provided in option '-t'. </s> mktemp -t identifier.XXXXXXXXXX
find all files in current folder which are exactly 300MB </s> find . -size 300M
List the commands in /usr/bin, pausing for user input after each page. </s> more <( ls /usr/bin )
Counts lines with all-cased word 'null' in file 'myfile.txt'. </s> grep -n -i null myfile.txt | wc -l
Find all SUID set files in the file system </s> find / -perm /u=s
Find all *.foo files under current directory and search for 'bar' in those files </s> find . -name '*.foo' -exec grep bar {} \;
Find the files in the current directory that match pattern '*.JUKEBOX.*.txt' and move them to folder ./JUKEBOX </s> find . -name '*.JUKEBOX.*.txt' -maxdepth 1 -print0 | xargs -0 -IFILE mv FILE ./JUKEBOX
find the file "dateiname" in the entire file system ( case insensitive search) </s> find / -iname "Dateiname"
Search for all non-hidden files </s> find . -name '*'
Print the lines of file "strings" not specified in file "index" </s> join -v 2 index <(nl strings)
Search for the pattern '^use strict' in all *.pl files under current directory </s> find . -name '*.pl' | xargs    grep -L '^use strict'
Find all files under $root_dir </s> find $root_dir -type f
Display the host's ECDSA fingerprint using the sha256 hasing algorithm. </s> ssh-keygen -l -f /etc/ssh/ssh_host_ecdsa_key.pub
display all the ".c" files in the current folder excluding those that are present in all the sub directories </s> find . \( ! -name . -prune \) -name "*.c" -print
list the details of all the directories in the current folder </s> find . -type d -exec ls -ld {} \;
Find symbolic links in directory /etc and below </s> find /etc -type l
find file which name like 'foo.*' in current directory. </s> find . -name "foo.*"
Displays status of currently active network interfaces. </s> ifconfig
list all javascipts file which whole name does not contain "directory" </s> find . -name '*.js' -and -not -path directory
Search for files/directories with the case insensitive pattern anaconda.* in var/log directory and create an archive (somefile.tar) of all the files found ensuring white space safety </s> find var/log -print0 -iname 'anaconda.*' | tar -cvf somefile.tar -T -
Print a list of all files and directories in the /var/log directory tree </s> find /var/log/
Greps domain $domain IP name from long dig listing. </s> dig $domain | grep $domain | grep -v ';' | awk '{ print $5 }'
Change user ownership to `foo' for files with UID=1005 </s> find / -user 1005 -exec chown -h foo {} \;
Find all directories under current directory and replace all null delimiters with : in the output then remove the last : </s> find -type d -print0 | sed -e "y/\d0/:/;s/:$//;"
remote copy all text files from one location to another </s> find .  -name '*.txt' -exec rsync -R {} path/to/dext \;
Copy permissions from "version2/somefile" to "version1/somefile" </s> chmod --reference version2/somefile version1/somefile
Search the "test1" directory recursively for regular files </s> find test1 -type f -print
Archive "_vim/" to "~/.vim" suppressing non-error messages and compressing data during transmission </s> rsync -aqz _vim/ ~/.vim
Search the current directory tree for files whose names are not "a.txt" </s> find . ! -name "a.txt" -print
display all the files  in the current folder excluding the current folder and do not search in the sub directories </s> find . -maxdepth 1 -type d \( ! -name . \)
Find all SGID files in entire file system </s> find / -perm +2000
search  in current directory downwards all files whose status has changed more then 7  days ago </s> find .  -ctime +7 -print
List all the .c files under the current directory and below in a 3 column format </s> find . -name "*.c" | xargs -n3 echo
Raise an error if there is a reference to a non-existent environment variable and exit the shell immediately if there is any error </s> set -eu
Find all files under /myfiles with read-write access for others </s> find /myfiles -type f -perm -o+rw
Make directory "dir" and do not cause an error if it exists </s> mkdir -p dir
search for the file ".user.log" in a folder </s> find /nfs/office -name .user.log -print
Search for "pattern" in all the .c files in the current directory tree </s> find . -name "*.c" | xargs grep pattern
display the names without extensions of all the data files in current folder and do not search in sub folders and which have not been changed in the last 60 mins </s> find . -maxdepth 1 -name '*.dat' -type f -cmin +60 -exec basename {} \;
Print whether "$file" and "${file/${dir1}/${dir2}}" differ </s> diff -q "$file" "${file/${dir1}/${dir2}}"
List all hidden regular files from the current directory separating them with zeroes </s> find . -maxdepth 1 -type f -name '.*' -printf '%f\0'
Find all *.mp4 files under /foo/bar and move them to /some/path </s> find /foot/bar/ -name '*.mp4' -exec mv -t /some/path {} +
Print common lines in sorted files "ignore.txt" and "input.txt" </s> comm -12 ignore.txt input.txt
search for the file "file_name" in the folder /path </s> find /path -name file_name
Remove regular files whose names match Perl regular expression '\w+-\d+x\d+\.\w+$' from the current directory tree </s> find -type f  |  grep -P '\w+-\d+x\d+\.\w+$' | sed -re 's/(\s)/\\\1/g' | xargs rm
Find all the files in file system which are greater than 50MB and less than 100MB </s> find / -size +50M -size -100M
Mount remote "cifs" filesystem "//192.168.0.111/serv_share" on "/mnt/my_share" with username "me" and password "mine" </s> sudo mount -t cifs -o username=me,password=mine //192.168.0.111/serv_share /mnt/my_share
Enable history and history expansion within a script </s> set -o history -o histexpand
Make "file.sh" executable </s> chmod +x file.sh
Count the number of files in the current directory and below </s> find . -type d -exec basename {} \; | wc –l
Find all symlinks under current directory </s> find ./ -type l
find all the ".c" files in the folder /home/david which have been modified in the last 48 hours </s> find /home/david -mtime -2 -name '*.c'
Sort "some_data" by the first and second ";" delimited entries and stabilizing the sort </s> sort -k1,1 -k2,2 -t';' --stable some_data
Add execute permission to "ComputeDate", "col", and "printdirections" for all users </s> chmod a+x ComputeDate col printdirections
Execute "ls" every second </s> watch -n 1 ls
execute a command in 10 seconds </s> true | sleep 10
find all the files in home folder which have been modified in the last 24 hours </s> find $HOME -mtime -1
Send 5 ping requests to address 12.34.56.78 and print only the last 2 lines of the summary output. </s> ping -c 5 -q 12.34.56.78 | tail -n 2
Delete files in /var/tmp/stuff and below that have not been modified in over 90 days </s> find /var/tmp/stuff -mtime +90 -print | xargs /bin/rm
Print which files differ in "PATH1/" and "PATH2/" recursively excluding any files that match any pattern in "file1" </s> diff PATH1/ PATH2/ -rq -X file1
create an archive using pbzip2 as a compress program </s> tar -I pbzip2 -cf OUTPUT_FILE.tar.bz2 /DIR_TO_ZIP/
Finds string with text "string to be searched" in any cased files like "*.cs" recursively in a current folder. </s> find ./ -type f -iname "*.cs" -print0 | xargs -0 grep "content pattern"
Remove everything in the current directory except files matching regular expression "exclude these" </s> find . -maxdepth 1 | grep -v "exclude these" | xargs rm -r
Recursively list all files and directories in "coreutils-8.9" with "DIR: " prepending directory names </s> tree -F coreutils-8.9 | sed -r 's|── (.*)/$|── DIR: \1|'
Print the last mounted drive </s> mount | tail -1 | sed 's/ on .* ([^)]*)$//'
Mount a read only ntfs filesystem </s> mount -t ntfs
Find all directories under $x directory and set read-write-execute permission for owner and group and no permission for other for those directories </s> find ${x} -type d -exec chmod ug=rwx,o= '{}' \;
Print file size with the file name </s> find . -name '*.ear' -exec du -h {} \;
Print the number of entries (files, directories, symlinks, etc.) in the subdirectories of the current directory, stopping search at any device mount points. </s> sudo find . -xdev -type f | cut -d "/" -f 2 | sort | uniq -c | sort -n
Read a line from an interactive shell's standard input into variable "message" without backslash escapes and prompt $'Please Enter a Message:\n' </s> read -rep $'Please Enter a Message:\n' message
compress all the non-compressed  files in the current directory. </s> find . \! -name "*.Z" -exec compress -f {} \;
force delete all the regular/normal files in the current folder </s> find . -type f -exec rm -fv {} \;
Number each non-blank line of standard input </s> nl
Find all files under current directory and set their permission to 775 </s> find . -type f -exec chmod 775 {} +
delete all the mp3 files in the home folder </s> find /home/ -exec grep -l “mp3” {} \; | xargs rm
Remove all files from the current directory tree whose names contain whitespaces </s> find . -name "* *" -exec rm -f {} \;
find all the files in the current folder which have been modified in the last one minute </s> find . -type f -mmin 0
Delete all files in the /TBD directory that were modified more than 1 day ago </s> find /TBD/* -mtime +1 -exec rm -rf {} \;
Count all the lines of all '*.c' files in current directory recursively </s> find . -name "*.c" -print0 | xargs -0 cat | wc -l
Print 3 space separated '%' </s> echo $(yes % | head -n3)
Find all empty files in the current directory and delete them </s> find . -empty -maxdepth 1 -exec rm {} \;
Print your/dir if it's an empty directory </s> find your/dir -prune -empty -type d
Find all files/directores under /etc filter them by searching for 'test' in their name and run the file command on each of them </s> find /etc -print0 | grep -azZ test | xargs -0 file
Delete all files that have not been accessed in the last 30 days </s> find . -type f -atime +30 -exec rm {} \;
Test if a file named 'file' in the current directory is more than 1 hour old </s> find file -chour +1 -exit 0 -o -exit 1
Filnd all directory in root directory with 777 permission and change permision755  with chmod commad . </s> find / -type d  -perm 777 -print -exec chmod 755 {} \;
Print a list of differing files </s> diff -q /dir1 /dir2|cut -f2 -d' '
Display mime type of file specified by variable "file" </s> file -ib "$file"
Creates random file name formatted like expression in variable ${str// /X} and saves it in 'rand_str' variable. </s> rand_str=$(mktemp --dry-run ${str// /X})
Find files on the system bigger than 50MB but smaller than 100MB </s> find / -type f -size +50M -size -100M
find all files in the current folder which are bigger than 10bytes </s> find . — size +10 -print
list all regular files which path is not dir1 or dir2 </s> find dir -not \( -path "dir1" -o -path "dir2" -prune \) -type f
Remove the "^M" characters from all *.ext files under /home directory </s> find /home -type f -name "*.ext" -exec sed -i -e 's/^M$//' {} \;
Find all the files/directories under '/usr/local' directory tree which have been modified within the last day </s> find /usr/local -mtime -1
find all the files ending with .mp3 or .jpg </s> find . \( -name '*.mp3' -o -name '*.jpg' \) -print
Find all files/directores under /etc and run the file command on each of them </s> find /etc -print0 | xargs -0 file
display all the files in the file system which belong to the user "wnj" and which are modified after the file "ttt" </s> find / -newer ttt -user wnj -print
Remove all files that contain the word GUI in entire file system </s> find / -type f -print0 | xargs -0 grep -liwZ GUI | xargs -0 rm -f
Save the user name in upper case of the current user in variable "v" </s> v=$(whoami | tr 'a-z' 'A-Z')
Print variable "$module" in formatted columns with at most 80 characters per line </s> echo $modules | column -t | fold | column -t
Search the current directory tree for all .java files that were last modified at least 7 days ago </s> find . -name '*.java' -mtime +7 -print
Get the grandparent directory of each found 'pattern' file in $SEARCH_PATH </s> find "$SEARCH_PATH" -name 'pattern' | rev | cut -d'/' -f3- | rev
Find files/directories named blah (case insensitive) under current directory </s> find ./ -iname blah
Extract the second-to-last slash-separated path component, ie. "90_2a5" in this case. </s> echo 'test/90_2a5/Windows' | xargs dirname | xargs basename
Print what year it was 222 days ago </s> date '+%Y' --date='222 days ago'
Find all files/directories excluding paths that match '.git' or '.gitignore' </s> find -print0 | grep -vEzZ '(\.git|\.gitignore/)'
create directory aaa/bbb </s> mkdir aaa/bbb
display all the files in the current folder which have been modified in the last 14*24 hours </s> find . -mtime -14 -print
ssh into localhost on port 4444 </s> ssh -p 4444 localhost
Search for the string "ERROR" in all XML files in the current working directory tree </s> find . -name "*.xml" -exec grep "ERROR" /dev/null '{}' \+
Find all the files that were modified within the last day </s> find . -mtime -1
Count the number of lines in "myfile.txt" </s> cat myfile.txt | wc -l
Find files/directories named 'foo' in the current partition of the root filesystem </s> find -x / -name foo
Print the first line and lines with "f" as the third "," separated field in "input" and format the result as a "," delimited table </s> awk -F, '{ if (NR == 1)print}{if($3 == "f")print}' input | column -t -s,
Save the last modified time of file 'file_name' to variable 'STAMP' </s> STAMP=`date -r file_name`
Search the current directory tree for hidden files </s> find .*
Find files smaller than 40 blocks skipping directories on other file systems </s> find . -size -40 -xdev -print
change the permissions of all the directories  to 775 in the current folder </s> find . -type d -exec chmod 775 {} \;
Print the first line of "seq 1 10000" </s> seq 1 10000 | head -1
Overwirte file '/path/to/your/file' with zeroes and remove, showing progress while execution. </s> shred -v -n 0 -z -u /path/to/your/file #overwriting with zeroes and remove the file
Prints what year it was 222 days ago </s> date --date="222 days ago" +"%Y"
Find all files/directories that belong to the group 'audio' under '/dev' directory tree </s> find /dev -group audio
Print the directory name of the real full path of "relative/path/to/file" where each symbolic link component must exist </s> dirname `readlink -e relative/path/to/file`
display all text files in the current folder </s> find . -type f -name "*.txt"
Remove leading and trailing spaces or tabs from "   wordA wordB wordC   " </s> echo "   wordA wordB wordC   " | sed -e 's/^[ \t]*//' | sed -e 's/[ \t]*$//'
Display the total count of all the files/directories with '.old' extension under current directory tree </s> find . -name “*.old” -print | wc -l
find all text files in current folder and delete them </s> find . -name ".txt" -exec rm "{}" \;
find all the files ending with ".coffee" in the current folder and search for the words "re" in each line </s> find . -name \*.coffee -exec grep -m1 -i 're' {} \;
Rename all regular files under current directory tree with inode number 31467125 to 'new_name.html' </s> find . -type f -inum 31467125 -exec mv {} new_name.html \;
Forward port 3307 on localhost to port 3306 on 1.2.3.4 via 'user@gateway' on port 24222 </s> ssh -f user@gateway -p 24222 -L 3307:1.2.3.4:3306 -N
Find files/directories named 'foo.bar' in the root filesystem partition </s> find / -name foo.bar -print -xdev
print top 10 largest files and directories </s> du -a . | sort -nr | head
Print content of all files found regarding seach options '[whatever]' </s> find [whatever] -exec cat {} \;
Find all files/directories under /home/baumerf/public_html/ that were modified less than 60 minutes ago excluding error_log files/directories </s> find /home/baumerf/public_html/ -mmin -60 -not -name error_log
Split "/usr/bin/cat" into 10000 files of about equal size </s> split -n 10000 /usr/bin/cat
Change permissions of ".git/hooks/pre-commit" to 777 </s> sudo chmod 755 .git/hooks/pre-commit
List all .svn files/directories under current directory </s> find . -name .svn -exec echo {} \;
Find all files/directories under current directory and append a null character at the end of each path </s> find -print0
Delete all regular files that have not been modified in the last 60 weeks under $DIR directory tree </s> find $DIR -type f -mtime +60w -exec rm {} \;
Saves bytes count of the value of '$each' variable. </s> a=$(echo $each | wc -c)
Send one ping request to host whose name or IP address is specified by variable "remote_machine". </s> ping -c 1 $remote_machine
Look in /home/dm and below for files with 'uniform' in their names </s> find /home/dm -name "*uniform*"
display all the files in the current folder which have the word "bills" in their name </s> find . -name '*bills*' -print
display all the files and directories with the name "CVS"  from /usr/src folder that are at least seven levels deep and do not descend onto the folders </s> find /usr/src -name CVS -prune -o -depth +6 -print
List all regular files from the current directory tree that were modified less than 60 minutes ago </s> find . -mmin -60 -type f -ls
search for the files which contain the word start in their name excluding search in ./proc, ./sys, ./run folders </s> find . -path ./proc -prune -or -path ./sys -prune -or -path ./run -prune  -or -iname '*start*' -print
Print continuous characters '/' and '\' randomly from /dev/urandom </s> grep -ao "[/\\]" /dev/urandom|tr -d \\n
display all the files in the current folder </s> find . | awk '{ print "FILE:" $0 }'
Copy the current directory tree to "newdirpathname" preserving directory hierarchy </s> find ./ -depth -print | cpio -pvd newdirpathname
Copy the owner and group from "file.txt" to "$tempfile" </s> chown --reference=file.txt -- "$tempfile"
Search for files/directories with the case insensitive pattern anaconda.* in /var/log directory and create an archive (file.tar) of the last file found </s> find /var/log/ -iname anaconda.* -exec tar -cvf file.tar {} \;
Search the current directory tree for an html file having the text 'Web sites' in it </s> find . -type f -iname \*.html -exec grep -s "Web sites" {} \;
Force create a symbolc link named "/usr/local/bin/fpt" to "/usr/local/bin/findpdftext" </s> sudo ln -s -f "/usr/local/bin/findpdftext" "/usr/local/bin/fpt"
Print full path of command "gradle" </s> which gradle
Find *.conf files/directories only upto 1 level down under /etc directory and show a few lines of output from the end </s> find /etc -maxdepth 1 -name "*.conf" | tail
find all executable files in /home directory. </s> find  /home -type f -perm /a=x
find all regular files in current directory and replace the word searc to replace in them. </s> find . -type f -exec sed -i 's/searc/replace/g' {} \;
find all text files in the current directory and compress them to a cpio file </s> find . -name '*.txt' | cpio -pdm /path/to/destdir
Copy all files in current directory that do not match */not-from-here/* in their paths to /dest </s> find . -type f -not -path '*/not-from-here/*' -exec cp '{}' '/dest/{}' \;
Find file `Chapter1' on the system </s> find / -name Chapter1 -type f -print
Find all directories under $1/.hg and set their SGID bit </s> find $1/.hg -type d -exec chmod g+s {} \;
Search the current directory recursively for regular files last accessed less than 2 minutes ago </s> find . type -f -amin -2
Remove recursively Emacs backup files in the current directory </s> find . -name '*~' -print0 | xargs -0 rm
Unzip "file.gz" to standard output and execute in bash with arguments "-n wordpress" </s> gzip -d --stdout file.gz | bash -s -- "-n wordpress localhost"
Find all files/directories named $something under current directory </s> find -name "$something"
Find all files under current directory and make them read-only for owner, read & writable by group and remove read-write-execute permission </s> find . -type f -exec chmod u+r-wx,g+rw-x,o-rwx {} \;
Searches manual pages which descriptions contain 'postscript', and prints name and description of only ones that contain any-cased 'png' pattern. </s> apropos postscript | grep -i png
Rename "original.filename" to "new.original.filename" </s> mv {,new.}original.filename
Removes only lowest level subfolders from current directory tree (folders without files and another folders within). </s> find . -type d | xargs rmdir
Count the number of regular files in directory tree ${DIRECTORY} that contain a vowel in their names </s> find ${DIRECTORY} -type f -print | sed -e 's@^.*/@@' | grep '[aeiouyAEIOUY]' | wc -l
set MyVariable to the value of VARIABLE_NAME </s> myVariable=$(env  | grep VARIABLE_NAME | grep -oe '[^=]*$');
Interpret /etc/bashrc in the current shell, ignoring lines that contain "mesg". </s> source <(grep -v "mesg" /etc/bashrc)
find all the files in the home folder which are less than 300Bytes </s> find ~ -size -300b
Test if "file.tar.gz" is corrupt </s> gunzip -t file.tar.gz
Find all files in /home/user/ that were created or changed 10 minutes ago </s> find /home/user/ -cmin 10 -print
Read two bytes from "/dev/urandom" and print them as an unsigned integer </s> od -A n -N 2 -t u2 /dev/urandom
Executes 'sleep 10' in a subshell created by a pipeline of built-in function 'true'. </s> true | sleep 10
Prints a process tree for each process of user 'username'. </s> ps -aux | grep ^username | awk '{print $2}' | xargs pstree
Echo each command before running </s> set -x
Limits the number of results from grep to 2 lines </s> grep -o '1.' yourfile | head -n2
remove top-level domain (.com, .org) from URL's in urllist.txt </s> rev urllist.txt | cut -d. -f 2- | rev
SSH using parameters in $@ in master mode in the background without executing any commands and set the ControlPath to "$MASTERSOCK" </s> ssh -o ControlPath="$MASTERSOCK" -MNf "$@"
Make directories "$@" and replace "mkdir: created directory " with "$USER created folder " in the output </s> mkdir "$@" |sed -e"s/mkdir: created directory /$USER created folder /"
Print the percentage of packets lost of the 5 packets sent to "$host" </s> ping -c 5 -q $host | grep -oP '\d+(?=% packet loss)'
Create a symbolc link named "public_html" to "current/app/webroot" under the current working directory </s> ln -s `pwd`/current/app/webroot public_html
find all the php files </s> find -name '*.php'
Print unique lines of sorted "File 1" compared with sorted "File 2" </s> comm -23 "File 1" "File 2"
Compress "hello world" and save to variable "hey" </s> hey=$(echo "hello world" | gzip -cf)
Find all files/directories with '.pdf' extension excluding 'pdfs' directory and all of its contents </s> find . -name "*.pdf" -print | grep -v "^\./pdfs/"
Search all files in the current directory tree for "SearchString", ignoring .html files and skipping .svn directories </s> find . \( -name '*.svn*' -prune  -o ! -name '*.html' \) | xargs -d '\n' grep -Hd skip 'SearchString'
display all the files in the current folder along with the change time and display file names of the last 10 changed files </s> find . -type f -printf "%C@ %p\n" | sort -rn | head -n 10
find files in the current directory and sub-directories, that were accessed within last hour </s> find -amin -60
Report total file systems disk usage in 1T blocks. </s> df --total -BT | tail -n 1
display all the files in the current folder which hare in the sub directory trees of the folders which begin with the word "kt" followed by a digit </s> find . -path './kt[0-9] '
List any line in "f1" or "f2" which does not appear in the other and delete all tab characters in the output </s> comm -3 <(sort -un f1) <(sort -un f2) | tr -d '\t'
Back up all *.txt files/directories in new files/directories with a .bak extension in their names under /etc directory </s> find /etc -print0 -name "*.txt" | xargs -I {} -0 mv {} {}.bak
Find all *.$input_file_type files/directories under $source_dir with the null character as the delimiter </s> find "$source_dir" -name "*.$input_file_type" -print0
Find all regular files under $SOURCE directory tree that were modified more than $KEEP days ago and show only the names without the paths </s> find $SOURCE -type f -mtime +$KEEP | sed ‘s#.*/##'
login as user root </s> su -l
Compare each .xml file under the current directory with a file of the same name in "/destination/dir/2" </s> find . -name *.xml -exec diff {} /destination/dir/2/{} \;
Find all directories under and below /root that match pattern "*linux*", case insensitive </s> find  /root -type d -iname "*linux*"
Find all .c and .C files in the current directory tree that contain "main(" and copy them to directory test1/ </s> find -iname “*.c” -exec grep -l ‘main(‘ {} \; -a -exec cp {} test1/ \;
Find all files in and below all subdirectories of the current directory </s> find . -mindepth 2
Search all files in the current directory tree whose names contain "." for "SearchString" </s> find . -name '*.*' -exec grep 'SearchString' {} /dev/null \;
Finds all files in $LOCATION, prints file names, overwrite files with random content $TIMES times, and finally remove them. </s> find $LOCATION -print -exec shred $TIMES -u '{}' \;
check if there any files from the .git folder after excluding it using the prune command </s> find . -path ./.git -prune -o -print -a \( -type f -o -type l -o -type d \) | grep '.git'
Find all files/directories under current directory and print them twice in each line </s> find | xargs -i sh -c "echo {} {}"
List all ~/bin/FilesDvorak/.* (non-recursive) and ~/.PAST_RC_files/.* (recursive) files/directories and take common entries between these two lists </s> comm -12 <(find ~/bin/FilesDvorak/.* -maxdepth 0) <(find ~/.PAST_RC_files/.*)
Print the line with most consecutive repeats prefixed with its count from standard input </s> uniq -c | sort -n | tail -n1
only get md5sum of a file </s> md5 -q file
Write every two lines in "infile" on a single line separated by a comma </s> cat infile | paste -sd ',\n'
Move "$PHANTOM_JS" to "/usr/local/share" directory </s> sudo mv $PHANTOM_JS /usr/local/share
Find files/directories named 'document' in 'ext2' partitions in entire filesystem </s> find / -fstype ext2 -name document -print
Find all files/directories under current directory and print only 2nd field from output delimited by '/' </s> find . | awk -F"/" '{ print $2 }'
List all processes with detailed information </s> ps -ef
search for the directory "ora10" in the entire file system </s> find / -type d -name "ora10"
Find all python files (.py files) in $topdir directory tree and search for 'Makefile' in all these folders and display all distinct folders having 'Makefile' </s> find "$topdir" -name '*.py' -printf '%h\0' | xargs -0 -I {} find {} -mindepth 1 -maxdepth 1 -name Makefile -printf '%h\n' | sort -u
Report file systems disk space usage pretty formatted. </s> df -Ph | column -t
find all the html files in the current folder and delete a line </s> find ./ -type f -name '*.html' | xargs sed -i '1,/sblmtitle/d'
Print number of bytes in $file. </s> cat $file | wc -c
remove all the files in the current folder which have not been modified in the last 10 days </s> find . -mtime +10 | xargs rm
Find all regular files under ${S} directory </s> find "${S}" -type f
Search the .c files residing in the Lib/ directory tree for lines beginning with "PyErr" </s> find Lib/ -name '*.c' -print0 | xargs -0 grep ^PyErr
Count the occurrence of 2 in the string '1 1 2 2 2 5' </s> echo "1 1 2 2 2 5" | tr ' ' $'\n' | grep -c 2
find all the files which have not been modified in the last 1 year and display the total disk usage of them  in GB </s> find . -type f -mtime +356 -printf '%s\n'  | awk '{a+=$1;} END {printf "%.1f GB\n", a/2**30;}'
Saves list of logged in users in system together with 'USER' header in the 'b' variable. </s> b=`w|cut -d' ' -f1`;
display all files ending with "ini" in current folder </s> find . -type f -name '*.ini'
Create 1000 files each file having a number from 1 to 1000 named "file000" to "file999" </s> seq 1 1000 | split -l 1 -a 3 -d - file
Check whether "/full/path" is a mount point with no output and using the exit code </s> df /full/path | grep -q /full/path
find case-insentive example.com file, and whole dose not contain beta </s> find -iname example.com | grep -v beta
Split "complete.out" into files with at most "$lines_per_file" lines each </s> split --lines $lines_per_file complete.out
Find all regular files with '.txt' extension excluding 'README.txt' files under current directory tree </s> find . -type f -name "*.txt" ! -name README.txt -print
Show all lines in file2 that don't contain the first field of any line in file1. </s> awk '{print $1}' file2 | comm -1 -3 file1 - | join file2 -
List all regular files matching the name pattern "$1*" (where $1 is a positional parameter) under '/usr', '/bin', '/sbin' and '/opt' directory tree </s> find /usr /bin /sbin /opt -name "$1*" -type f -ls
Execute the first instance of "parallel" found in the PATH, passing it all parameters received by the script/function </s> `which parallel` "$@"
Split the contents of all ".txt" excluding the first 1000 lines into files of at most 1000 lines each </s> cat *.txt | tail -n +1001 | split --lines=1000
Find all files/directories starting with 'readme' (case insensitive) under '/usr/share/doc' directory tree </s> find /usr/share/doc -name '[Rr][Ee][Aa][Dd][Mm][Ee]*'
Find all files/directories under '/home/user/' directory tree whose status were changed 10 minutes ago </s> find /home/user/ -cmin 10 -print
Search the current directory recursively for regular files with the extension given as variable $extension </s> find . -type f -name "*.$extension"
Find all empty files (zero byte files) in your home directory and its sub-directories. </s> find ~ -empty
find all the files in the /usr folder which have modification date less than or equal to the file "/FirstFile" </s> find /usr ! -newer /FirstFile -print
Display the sizes and filepaths of all files/directories sorted in descending order of size </s> du -a -h --max-depth=1 | sort -hr
Correct permissions for directories in the web directory </s> find /your/webdir/ -type d -print0 | xargs -0 chmod 755
Display all lines in 'file' containing 'something', pausing for user input after each page. </s> grep something file | more
Find all TXT files in the current directory and copy them to directory "$HOME/newdir" </s> find "$HOME" -name '*.txt' -type f -not -path "$HOME/newdir/*" -print0 | xargs -0 cp -t "$HOME/newdir"
Find all files/directories under /myfiles following symlinks if needed </s> find -L /myfiles
Calculate the md5 sum of all the file metadata in the current directory tree excluding ".svn" </s> find . -name '.svn' -prune -o -type f -printf '%m%c%p' | md5sum
Print the drive and mount point of the last mounted drive </s> mount | tail -1 | sed 's/^.* on \(.*\) ([^)]*)$/\1/'
Search all regular files in the current directory tree for "example" </s> find -type f -print0 | xargs -r0 grep -F 'example'
Save IP addresses of the host name in variable "ip" </s> ip=$(hostname -I)
Delete all files/directories named test under maximum 2 level down the current directory </s> find . -maxdepth 2 -name "test" -exec rm -rf {} \;
Find all *.c files in /usr/src bigger than 100k </s> find /usr/src -name '*.c' -size +100k -print
find all the text files in the current folder </s> find . -name "*.txt" -print
Find and show all files in the current directory tree that are exactly 2000 kB </s> find . -size 2000k
Output the specified path removing all containing directories and the .txt suffix, in this case "filename". </s> basename /path/to/dir/filename.txt .txt
Copy all directories recursively from "source/" to "destination/" excluding all files </s> rsync -a -f"+ */" -f"- *" source/ destination/
Find all regular files in the current directory and search them for "example" </s> find -maxdepth 1 -type f | xargs grep -F 'example'
List all files/directories under current directory matching the posix-egrep type regex ".+\.(c|cpp|h)$" in their names </s> find . -regextype posix-egrep -regex ".+\.(c|cpp|h)$" | xargs -n 1 ls
Print unique lines in sorted file "A" when compared to sorted files "B", "C", and "D" </s> comm -2 -3 A B | comm -2 -3 - C | comm -2 -3 - D
Resolve any symlinks in working directory, and go to resulting pathname. </s> cd "`pwd -P`"
Find files bigger than 20 megabytes in the home directory tree </s> find ~ -size +20M
Find all .c and .h files in the current directory tree and search them for "expr" </s> find -name '*.[ch]' | xargs grep -E 'expr'
List all *.txt files/directories under /etc </s> find /etc -name "*.txt" -exec ls -l {} \;
split the file hugefile.txt into pieces per 100000 lines named as partNNN with digital prefixes </s> split -a4 -d -l100000 hugefile.txt part.
Remove the first 7 characters of every line in the output of "history" </s> history | cut -c 8-
Show ls's detailed output for all files named "something" </s> find . -name something -exec ls -l {} \;
Executes 'echo "$ret"' in a subshell that is opened by command 'true'. </s> true | echo "$ret"
Find all *.cgi (case insensitive) files/directories under current directory and change their permission to 755 </s> find . -iname '*.cgi' | xargs chmod 755
delete recursively, without prompting, any files or directories under the current directory that case insensitively match the filename ".svn" </s> find . -iname .svn -exec rm -rf {} \;
Report root file system disk usage human-readable. </s> df -h /
Search /dev/shm and /tmp for regular files not changed in two weeks </s> find /dev/shm /tmp -type f -ctime +14
Find all files named "file.ext" under the current working directory tree and print its filename </s> find `pwd` -name "file.ext" -printf "%f\n"
Find .java files in the current directory tree that contain 'TODO', and print their names </s> find . -name "*.java" -exec grep -Hin TODO {} + | basename `cut -d ":" -f 1`
List all files from the current directory tree that were modified less than 60 minutes ago </s> find . -mmin -60 -ls
Search for all the directories named 'm?' under current directory tree, add the extension ".mbox" to all, create a 'Messages' directories inside them and move all files with .emlx extension to 'Messages' directory </s> find . -name 'm?' -type d -exec mv '{}' '{}.mbox' ';' -exec mkdir '{}.mbox/Messages' ';' -exec sh -c 'mv {}.mbox/*.emlx {}.mbox/Messages' ';'
Load keybindings from a file ~/.inputrc </s> bind -f ~/.inputrc
Find all files under current directory excluding hidden directories </s> find -name '.?*' -prune -o \( -type f -print0 \)
Find all files under $dir directory </s> find "$dir" -type f
Mount "device_name" on "mount_point" </s> sudo mount device_name mount_point
List all files under current directory matching the regex '.*\(c\|h\|cpp\)' </s> find . -type f -regex '.*\(c\|h\|cpp\)' -exec ls {} \;
List all files bigger than 10000 blocks </s> find . -type f -size +10000 -exec ls -al {} \;
find all the files ending with .ini in the current directory. </s> find . -name *.ini
change owner of all files into current directory except  files named as  './var/foo*' to user www-data </s> find . -not -iwholename './var/foo*' -exec chown www-data '{}' \;
Print lines 15967 to 16224 in file "dump.txt" </s> cat dump.txt | head -16224 | tail -258
Rename "www_new" to "www" even if "www" directory exists </s> mv -T www_new www
Search /var for files matching regular expression '.*/tmp/.*[0-9]*.file' </s> find /var -regex '.*/tmp/.*[0-9]*.file'
display a long listing of all the files in the home folder which are bigger than 200MB </s> find /home -size +200M -exec ls -sh {} \;
Save all directories under the current directory as a comma separated list in variable "FOLDERS" </s> FOLDERS=$(find . -type d | paste -d, -s)
Finds IP address of 'eth0' network interface. </s> ifconfig eth0 | grep 'inet addr:' | awk '{print $2}' | awk -F ':' '{print $2}'
find all  files that match "[a-f0-9\-]{36}\.jpg" of grep </s> find . * | grep -P "[a-f0-9\-]{36}\.jpg"
Find all *.rb files/directories under current directory </s> find . -name \*.rb
Archive all directories in /path/to/directory/* (only command line arguments, no sub-directories) to files with .tar.gz extension transforming the full paths to relative paths </s> find /path/* -maxdepth 0 -type d -exec sudo tar -zcpvf {}.tar.gz {} \;
Display all lines contiaining 'funcname' in system map file matching current kernel. </s> cat /boot/System.map-`uname -r` | grep funcname
Find all files/directories named 'test' under current directory tree </s> find . -name test
Find all files/directories under current directory in maximum 3 levels deep </s> find -maxdepth 3
display all the files in the current directory excluding the paths "targert", "tools", "git" </s> find . \( ! -path "*target*" -a ! -path "*tools*" -a ! -path "*.git*" -print \)
Make directories to "/tmp/test/blah/oops/something" as needed </s> mkdir -p /tmp/test/blah/oops/something
Recursively prints all folders in a current folder that contain files like "*.class". </s> find . -name "*.class" -print0 | xargs -0 -n1 dirname | sort --unique
Remount "/dev/block/mtdblock3" on "/system" with read only permission </s> mount -o remount,ro -t yaffs2 /dev/block/mtdblock3 /system
Rename "blah2" to "blah2-new" </s> mv blah2 blah2-new
find all the files in the folder "myfiles" which have been modified exactly 48 hours back. </s> find /myfiles -mtime 2
Gets domain name from dig reverse lookup. </s> dig -x 8.8.8.8 | awk '/PTR[[:space:]]/{print $NF}'
display all the files in the folder "/Users/Me/Desktop" which have read permission to them </s> find /Users/Me/Desktop -readable
Find files starting with the word "file" in the current directory tree </s> find . -name "file*"
Answer "n" to any prompts in the interactive recursive removal of "dir1", "dir2", and "dir3" </s> yes n | rm -ir dir1 dir2 dir3
Make directories "./es/es_MX.utf8/LC_MESSAGES" as needed and do not error if it exists </s> mkdir --parents ./es_MX.utf8/LC_MESSAGES
Find all *.* files not within .git directory and run $SED_CMD -i "s/$1/$2/g" on each of them </s> find . -type f -name "*.*" -not -path "*/.git/*" -print0 | xargs -0 $SED_CMD -i "s/$1/$2/g"
Print "/tmp/myfile" starting at line 11 </s> tail -n +11 /tmp/myfile
download contents of a website "http://example.com/" </s> curl http://example.com/
remove all the ".core" files in the file system </s> find / -name "*.core" | xargs rm
Replace all occurrences of '2013 Magento Inc.' with '2012 Magento Inc.' in all files with '.php, '.xml' and '.phtml' extensions under current directory tree </s> find . -name '*.php' -print0 -o -name '*.xml' -print0 -o -name '*.phtml' -print0 | xargs -0 sed -i '' 's/2013 Magento Inc./2012 Magento Inc./g'
Make a POST request to "http://dweet.io/dweet/for/cycy42" with data "PiIP" set to the IP address of the system </s> wget --post-data="PiIP=$(hostname -I)" http://dweet.io/dweet/for/cycy42
Display a dump of "file" as floating point values of double size </s> od -t fD file
find all the files that have been modified exactly 24 hours ago </s> find . -type f -mtime 1
change group of the file myfile to group friends </s> chown :friends myfile
change owner and group of the file dir1 to user root and group  specialusers </s> chown root:specialusers dir1
Make directories "es/LC_MESSAGES" as needed and do not error if it exists </s> mkdir -p es/LC_MESSAGES
find all the files in the home folder which have been modified after a file </s> find $HOME -newer ~joeuser/lastbatch.txt
List each file or directory in the current directory prefixed by its filesize in bytes and sorted from smallest to largest </s> du -a --max-depth=1 | sort -n
search in the current folder for the file with the name "test" ( case insensitive search ) </s> find . -iname test
Search for file "file" between level 2 and 3 of the directory tree </s> find -mindepth 2 -maxdepth 3 -name file
Copy all *.mp3 files under the current directory to /tmp/MusicFiles/ </s> find . -type f -name "*.mp3" -exec cp {} /tmp/MusicFiles \;
Prints help on 'cp' utility. </s> cp --help
Find files/directories with exactly read,write and execute permission for all (owner, group and others) under /path </s> find /path -perm 777
Split the contents of "file1 file2 ... file40000" into 1445 files in a round robin fashion with prefix "outputprefix" and numeric suffixes </s> cat file1 file2 ... file40000 | split -n r/1445 -d - outputprefix
Read a line of standard input into variable "input_cmd" with prompt "command : " </s> read -p "command : " input_cmd
Search the current directory tree for filenames matching the pattern '[mM][yY][fF][iI][lL][eE]*' </s> find . -name '[mM][yY][fF][iI][lL][eE]*'
display list of all the regular/normal files in the current folder which start with "my" </s> find . -name 'my*' -type f -ls
Find ".c" and ".h" files in the current directory tree and print line numbers and lines containing "#include" </s> tree -if | grep \\.[ch]\\b | xargs -n 1 grep -nH "#include"
find all files starting with capital letter in the current folder </s> find . — name "[A‑Z]*" — print
Creates temporary folder in TMPDIR (if defined) or in '/tmp/', and stores path to created folder in 'tmpdir' variable. </s> tmpdir=$(mktemp -d)
display all the directories in the current folder excluding those that are present in the folder secret </s> find . -name secret -type d -prune -o -print
recursively change owner of the directory /usr/local/lib/node_modules/ to the current user </s> sudo chown -R $USER /usr/local/lib/node_modules
Reverse the order of lines in "myfile.txt" using BSD "tail" command </s> tail -r myfile.txt
Prints process tree, showing only strings with 'MDSImporte', and chopping output after ${WIDTH} characters. </s> pstree | grep MDSImporte | cut -c 1-${WIDTH}
Recursively removes all files and folders named '.svn' in a current folder, handling content of removed folder before folder inself. </s> find . -depth -name .svn -exec rm -fr {} \;
Display the last space-separated field of each line in file.txt </s> rev file.txt | cut -d ' ' -f1 | rev
Find all *.mp3, *.aif*, *.m4p, *.wav, *.flac files under $musicdir directory </s> find "$musicdir" -type f -print | egrep -i '\.(mp3|aif*|m4p|wav|flac)$'
Remove all regular files from the current directory tree that were modified a day ago </s> find . -type f -mtime 1 -exec rm {} +
Read a line from standard input with prompt "Are you sure you wish to continue?" </s> read -p "Are you sure you wish to continue?"
Prints a random line from $FILE </s> sort --random-sort $FILE | head -n 1
Go to last directory with name starting with a number, useful for timestamped directory names. </s> cd "$(ls -rd [0-9]*/ | tail --lines 1)"
Write the current date and time followed by " 1" to the console and append to "log.csv" </s> echo $(date) "1" | tee -a log.csv
Find all *.php (case insensitive) and *.js files (case insensitive) under /home/jul/here excluding  /home/jul/here/exclude/* paths </s> find /home/jul/here -type f \( -iname "*.php" -o -iname "*.js" \) ! -path "/home/jul/here/exclude/*"
Find all files that were not accessed in the past 100 days </s> find /home -atime +100
Finds users with X session in system and puts the result in USERS variable. </s> USERS=$(w | awk '/\/X/ {print $1}')
check the type of files in the folder /usr/bin </s> find /usr/bin | xargs file
Display the last 3 characters of variable foo. </s> echo $foo | rev | cut -c1-3 | rev
Find files associated with an inode </s> find . -inum 968746 -exec ls -l {} \;
Append the current date to variable 'LBUFFER' </s> LBUFFER+="$(date)"
List all files and directories residing in the current directory and below </s> find -print0 | xargs -0 ls
Display the first 32 bytes in "foo" as printable characters with 16 characters per line </s> od -c foo |head -2
Remove all broken symlinks from the /usr/ports/packages directory tree </s> find -L /usr/ports/packages -type l -delete
Find all *.xml files under current directory </s> find -name *.xml
Removes 55, adds a 10-digit line number, and rearranges the date for each line in "input" </s> nl -nrz -w10 -s\; input | sed -r 's/55//; s/([0-9]{2})-([0-9]{2})-([0-9]{4})/\3\2\1/'
View line 500 to line 1000 in gzipped file "bigfile.z" </s> zcat bigfile.z | sed -ne '500,1000 p'
Save number of lines in 'file.txt' file in 'nbLines' variable </s> nbLines=$(cat -n file.txt | tail -n 1 | cut -f1 | xargs)
Find apparent size of a target directory </s> du -hs /path/to/directory
looks for all files larger than 10 megabytes (10485760 bytes) within /home </s> find /home -type f -size +10485760c -print
Search /tmp/ for files smaller than 100 bytes </s> find /tmp -size -100c
Search "mygzfile.gz" for "string to be searched" </s> gunzip -c mygzfile.gz | grep "string to be searched"
Removes the last 2 lines from a file </s> head -n -2 myfile.txt
Show the subdirectories of the current directory </s> find . -maxdepth 1 -type d -print | xargs -I {} echo Directory: {}
Search for regular file foo ignoring case </s> find . -iname foo -type f
Save the current working directory with resolved symbolic links to variable "real1" </s> real1=$(pwd -P)
returns the first 100 bytes in the file </s> head -c 100 file
Find and delete all core files in the user's home directory and below. </s> find ~/ -name 'core*' -exec rm {} \
Check the environment variables generated by switching to the root account. </s> sudo env
Find all files/directories startring with 'onlyme' in their names under current directory without going into sub-directories </s> find . -maxdepth 1 -name 'onlyme*'
Delete all .svn files/directories under current directory </s> find . -name .svn -exec rm -rf '{}' \;
Copy all files below the current directory whose names contain "FooBar" to directory foo/bar/ in user's home directory. </s> find -name '*FooBar*' -print0 | xargs -0 cp -t ~/foo/bar
Print the last line of "$file1" to the console and append to "$file2" </s> tail -1 $file1 | tee -a $file2
Replace all spaces (' ') with comma (',') in ${TO_IGNORE[@]}, append with '--ignore ' and save the resultant string to variable 'ARGS' </s> ARGS="--ignore `echo ${TO_IGNORE[@]} | tr ' ' ','`"
display all the regular files in current folder </s> find . -type f
Report file systems inodes usage. </s> df -i
Find files modified at least 5 days in the future </s> find . -newermt "5 days"
Remove everything in a current folder prompting user on each action. </s> rm -ri *
File 'save_pid.txt' contains a process ID, instantly kill this process with SIGKILL signal. </s> kill -9 `cat save_pid.txt`
Save the current working directory and the directory name of the current script to variable "DIR" </s> DIR=`pwd`/`dirname $0`
Recursively change ownership of "~/.npm" to the current user </s> sudo chown -R $(whoami) ~/.npm
create a compressed archive "filename.tar.gz" with verbose output </s> tar -cvzf filename.tar.gz folder
Split "filename" into files of at most 200000 lines each </s> split -l 200000 filename
Find files using file-name </s> find -iname "MyCProgram.c"
display all the files in the current folder </s> find ./
display all the ".c" files in the current folder excluding those that are present in the .svn sub folder </s> find .  -name .svn -prune -o -name "*.c" -print
Instantly kill all processes whose command is 'myprocess'. </s> kill -9 \`pgrep myprocess\`
Recursively add user write permission to all files under "/path/to/git/repo/objects" </s> chmod -Rf u+w /path/to/git/repo/objects
archive all the normal/regular files in the current directory which have been modified in the last 24 hours. </s> find . -mtime -1 -type f -exec tar rvf "$archive.tar" '{}' \;
Send one ping request to host whose name or IP address is specified by variable "ip", using network interface eth9. </s> ping ${ip} -I eth9 -c 1
Decompress ${set1[@]} files with gzip </s> gzip -d ${set1[@]} &
Find all *.mp3 files in entire file system greater than 10MB and delete them </s> find / -type f -name *.mp3 -size +10M -exec rm {} \;
Make directory "saxon_docs" </s> mkdir saxon_docs
Calculate the md5sum of the executable file of command "gcc" </s> md5sum $(which gcc)
Continuously send "y" as input to "cat" which outputs to "more" </s> yes | cat | more
Finds strings with dot-separated sequence of numbers, and prints part of that sequence before the second and third dot. </s> echo "$f" | grep -Eo '[0-9]+[.]+[0-9]+[.]?[0-9]?' | cut -d. -f3
Search for the regex "\$wp_version =" in all the regular files that end with '/wp-includes/version.php' (case insensitive) in their paths in directories/files taken from the glob pattern '/home/*//public_html/' and show the matched lines along with the file names </s> find /home/*/public_html/ -type f -iwholename "*/wp-includes/version.php" -exec grep -H "\$wp_version =" {} \;
Move "file1", "file2", "..." to "target" directory </s> mv -t target file1 file2 ...
search for "message.txt" in the folder .cache/bower and display its contents </s> find .cache/bower/ -name "message.txt" | xargs cat
find all files in current folder which are bigger than 1 MB and move them to another folder </s> find . -size +1M -print0 | xargs -0 -I '{}' mv '{}' files
Force delete all jpg files in current directory which are less than 50KB and do not search in the sub directories </s> find . -maxdepth 1 -name "*.jpg" -size -50k -exec rm {} \;
Search the ~/Books directory recursively for regular files named "Waldo" </s> find ~/Books -type f -name Waldo
Changes to the directory where 'ssh' executable is located. </s> cd $(dirname $(which ssh));
find all files in the current folder with the permission 777 and modify the permissions as 755. </s> find . -type f -perm 777 -exec chmod 755 {} \;
Display the number of lines in all regular files under current directory tree and also show the total count </s> find . -type f -exec wc -l {} +
Recursively print all files and directories in the current directory tree </s> tree .
Replace all instances of "STRING_TO_REPLACE" with "REPLACE_WITH" in file "index.html" and make a backup with suffix "bak" </s> sed -ibak -e s/STRING_TO_REPLACE/REPLACE_WITH/g index.html
Find all directories that have been accessed $FTIME days ago under current directory tree </s> find . -type d -atime $FTIME
Try to determine the type of contents in "myfile" located in user's home directory. </s> file ~/myfile
find all the files in the entire filesystem which belong to the group root and display the ten files. </s> find / -group root | head
Find all regular files that contain 'linux' (case insensitive) in their names under '/root' directory tree </s> find  /root -type f -iname "*linux*"
Delete all regular files named 'IMAG1806.jpg' under current directory tree </s> find . -type f -name "IMAG1806.jpg" -exec rm -f {} \;
Search the current directory tree for file "a.txt" </s> find . -name "a.txt" -print
display all files in current folder </s> find .
List files in the current directory and below that are exactly 1234 bytes in size </s> find . -size 1234c
display list of all the files in the current directory </s> find | xargs ls
Find all fonts (in '/usr/local/fonts') that belong to the user 'warwick' </s> find /usr/local/fonts -user warwick
display a long listing of the files in current folder which have been modified in the last 60 minutes </s> find . -mmin -60 -type f -exec ls -l {} +
Find all *.rb files/directories under current directory </s> find . -name *.rb
Find files matching pattern $2 in the $1 directory recursively and search them for text $3, where $1, $2, $3 are the command line arguments to the Bash script </s> find $1 -name "$2" -exec grep -Hn "$3" {} \;
rename all the text files  in the current folder to html files </s> find -name "*.txt" -exec mv {} `basename {} .htm`.html \;
Print NS record for domain 'domain.' from 'some.other.ip.address' nameserver </s> dig @some.other.ip.address domain. ns
Search the current directory tree for files and directories with permissions 775 </s> find .  -perm 775 -print
Find all files in /var/www/html/zip/data/*/*/*/*/* that are older than 90 days and print only unique parent directory paths </s> find /var/www/html/zip/data/*/*/*/*/* -type f -mtime +90 -printf "%h\n" | sort | uniq
Move all *.php~ (case insensitive) files under current directory to /mydir </s> find . -iname "*.php~" -exec mv {} /mydir \;
Find files in the current directory tree whose status was changed within the last 60 minutes </s> find . -cmin -60
Print the top 10 commands with their use count </s> history | awk '{ print $2 }' | sort | uniq -c |sort -rn | head
find all c, cpp files in current folder </s> find -regex '.*\.\(c\|cpp\)'
Find all *.txt files under current directory with their timestamps and paths, sort them and print the last entry only </s> find . -name "*.txt" -printf "%T+ %p\n" | sort | tail -1
Change the owner of "$JBOSS_CONSOLE_LOG" to "$JBOSS_USER" </s> chown $JBOSS_USER $JBOSS_CONSOLE_LOG
Find file names *blast* in specfied directory </s> find /usr/local -name "*blast*"
Print the full path of a 'file.txt' file in the current folder. </s> ls "`pwd`/file.txt"
Search the .java files from the /Applications/ directory tree for TODO lines </s> find /Applications/ -name "*.java" -print0 | xargs -0 grep -i "TODO"
Read a line from standard input into variable "message" with prompt "Please Enter a Message: " followed by a newline </s> read -p "Please Enter a Message: `echo $'\n> '`" message
Display only first and second dot-separated numbers of kernel version, ie. 4.4 </s> uname -r | sed 's/\([0-9]\+\.[0-9]\+\)\..*/\1/'
Report file systems disk usage, elide all entries insignificant to available space, and produce a grand total. </s> df --total
List recursively all files and directories in /var/www </s> find /var/www
Runs `file' on every file in or below the current directory. </s> find . -type f -exec file '{}' \;
Print a count of each unique line in "ip_addresses.txt" sorted numerically </s> sort -n ip_addresses.txt | uniq -c
List all environment variables whose name or value contains current user's login name. </s> env | sed -n /"$USERNAME"/p
Find all the files/directories in the current directory tree which have been modified between 2014-08-25 and 2014-08-26 </s> find ./ -newermt 2014-08-25 ! -newermt 2014-08-26 -print
Find directories that have "755" permissions and modify them to have "700" permissions </s> find . -type d -perm 755 -exec chmod 700 {} \;
Find all files/directories under current directory </s> find | xargs
Find how many files are in a path </s> find . -type f -exec basename {} \; | wc -l
List all existing environment variables in the current shell. </s> env | awk -F= '/[a-zA-Z_][a-zA-Z_0-9]*=/ { if (!system("[ -n \"${" $1 "+y}\" ]")) print $1 }' | sort | uniq
Find all .zip files starting from the current directory which are owned by user tommye </s> find . -type f -user tommye -iname "*.zip"
Find all the files under /home directory with name tecmint.txt </s> find /home -name tecmint.txt
Find symlinks in the current directory tree </s> find . -type l | xargs ls -ld
search all undo files(ending with .undo) in the current folder and calculate the total size of them </s> find -name '*.undo' -exec wc -c {} + | tail -n 1 | cut -d' ' -f 1
Return the depth of the current directory tree </s> find . -type d -printf '%d:%p\n' | sort -n | tail -1
Find all files named "MyCProgam.c" (ignoring the case) and calculate each file's md5sum. </s> find -iname "MyCProgram.c" -exec md5sum {} \;
Print continuous lines of 100 random characters either "." or " " </s> cat /dev/urandom | tr -dc '. ' | fold -w 100
Search the home directory for files whose names begin with "test" </s> find ~ -name "test*" -print
Save the short DNS lookup output of $WORKSTATION to 'WORKSTATION_IP' variable </s> WORKSTATION_IP=`dig +short $WORKSTATION`
Find all files in the current directory tree and replace string $1 with string $2 in them </s> find ./ -type f -exec sed -i "s/$1/$2/" {} \;
Print the IP addresses for the current host name </s> hostname  -I
From the list of words (one per line) in list1.txt, display the number of occurrences of this word in list2.txt and sort the results from highest to lowest count. </s> grep -Ff list1.txt list2.txt | sort | uniq -c | sort -n
Remove all tmp/*.mp3 files </s> find tmp -maxdepth 1 -name '*.mp3' -maxdepth 1 | xargs -n1 rm
Show the list of files modified less than a minute ago </s> find / -mmin -1 -print
Print the first 10 files or directories found in the current directory tree by `find' </s> find | head
Search for first match of the regex 're' in all *.coffee files under current directory </s> find . -name \*.coffee -exec awk '/re/ {print;exit}' {} \;
Find all files/directories under current directory tree that contain '1' or 'k' in their names </s> find . -name "*[1k]*"
Find all directories by the name `httpdocs' on the system </s> find / -type d -name httpdocs
find regular files which modification time is  7 days ago </s> find . -mtime -7 -type f
Find all directories under minimum 2 levels down the mydir directory </s> find mydir -mindepth 2 -type d
Print all files and directories in the `.' directory tree skipping SCCS directories </s> find . -name SCCS -prune -o -print
Lists all files that matches path pattern with wildcards. </s> ls -l /lib*/ld-linux*.so.2
Remove trailing white spaces from all files under dir directory and keep backups of the originals </s> find dir -type f -print0 | xargs -0 sed -i .bak -E "s/[[:space:]]*$//"
Search the current directory for files whose names start with "messages." ignoring SVN and CVS files </s> find \( -name 'messages.*' ! -path "*/.svn/*" ! -path "*/CVS/*" \) -exec grep -Iw uint {} +
display all the files in the current folder. </s> find .
find all files in current folder having the name pattern "some_pattern" and move them to folder target_location (GNU VERSION) </s> find . -name some_pattern -print0 | xargs -0 -I % mv % target_location
create a tar.gz compress file with all the jpg files in the entire file system </s> find / -name *.jpg -type f -print | xargs tar -cvzf images.tar.gz
find all the files and folder that were created in 2012 on Friday of every month </s> find / -daystart -mtime +41 -mtime -408 \   -printf "%M %n %u %g %10s %TY-%Tm-%Td %Ta %TH:%TM:%TS %h/%f\n" | awk '($7=="Fri"){print}'
Search regular files from the /path/to/dir directory tree for lines that contain "_START" and are enclosed in lines "@GROUP" and "@END_GROUP" </s> find /path/to/dir -type f -exec sed '/@GROUP/,/@END_GROUP/!d' {} + | grep '_START'
Searches for 'something' in a large file and prints the matching line </s> grep -n 'something' HUGEFILE | head -n 1
Puts the job 1 in the background. </s> bg %1 [puts the job in the background]
Count the number of lines in all ".php" files in the current directory tree </s> wc -l `tree -if --noreport | grep -e'\.php$'`
find all the files in the current folder which have been modified for the ffiles that are at least one week old (7 days) but less then 30 days old </s> find . -mtime +30 -a -mtime -7 -print0
Print as many dots as there are files named "file.ext" in the /home/kibab directory tree </s> find /home/kibab -name file.ext -exec echo . ';'
find all normal/regular files in current folder which end with "~" or which begin and end with "#" and and move them to  temp folder </s> find . -maxdepth 1 -type f  -name '*~' -exec mv {} /tmp/ \;  -or  -name '#*#' -exec mv {} /tmp/ \;
Find all regular files in the current directory tree whose names end with ".DS_Store" and delete them </s> find . -type f -name '*.DS_Store' -ls -delete
Search the directory given as variable $d for empty subdirectories </s> find "$d" -mindepth 1 -prune -empty
Change onwer of "file" to "user_name" </s> chown user_name file
Archive directory "." to "server2::sharename/B" </s> rsync -av . server2::sharename/B
Find and remove all .mp3 regular files under the current directory and below </s> find . -type f -name "*.mp3" -exec rm -f {} \;
Rename file extension '.andnav' to '.tile' for all files/directories under current directory tree </s> find . -name "*.andnav" | rename "s/\.andnav$/.tile/"
Find files/directories named 'foo.bar' under './dir1' and './dir2' directory tree </s> find ./dir1 ./dir2 -name foo.bar -print
Search the current directory for files whose names start with "messages." ignoring SVN files </s> find \( -name 'messages.*' ! -path "*/.svn/*" \) -exec grep -Iw uint {} +
Find all files/directories with '.mp4' extension and all regular files with '.flv' extension, sort them according to their names and display the first 500 of them </s> find /storage -name "*.mp4" -o -name "*.flv" -type f | sort | head -n500
find all the files in the current folder and display them in the sorted order of their name </s> find . | sort
Locates bzip2 command in a system. </s> which bzip2
Recursively compress every file in the current directory tree and keep the original file </s> gzip -kr .
Search regular files under ~/mail for string "Linux" </s> find ~/mail -type f | xargs grep "Linux"
Use the first non-zero exit code (if any) of a set of piped commands as the exit code of the full set of commands </s> set -o pipefail
find  files which full path name is foo/bar under foo directory and print </s> find foo -path foo/bar -print
Make directory "dirname" with permissions set to 777 </s> mkdir -m 777 dirname
Move all files and directories in the current directory to "/tmp/blah/" </s> mv * /tmp/blah/
Search all files in the current directory tree whose names end in "1" for string "1" </s> find . -name "*1" -print0 |xargs -0 grep "1"
Reverse the order of lines in "dax-weekly.csv" keeping the first line the same </s> cat dax-weekly.csv | awk '1 { last = NR; line[last] = $0; } END { print line[1]; for (i = last; i > 1; i--) { print line[i]; } }'
display the number of lines in all the files in the current folder </s> find . -name '*' | xargs wc -l
Join columns in "file1" and "file2" if their first field matches and format the output as a table </s> join file1 file2 | column -t
list files found under the current directory ending in "txt" or ending in "html" </s> find . -name '*.txt' -o -name '*.html'
Print the list of non-hidden directories in the current directory </s> find -type d -maxdepth 1 ! -name ".*" -printf "%f\n"
Find all files under current directory </s> find . -type f
Find all the files in file system which are modified in last 1 hour </s> find / -mmin -60
Replace all non-punctuation characters with newlines from standard input </s> tr -sc '[:punct:]' '\n'
Recursively search for "string here" and write the output to the console followed by the number of matched lines </s> grep -r "string here" * | tee >(wc -l)
Subtract each column in File2 from matching column in File1, output the result in a similarly formatted table </s> awk 'FNR==NR { for(i=2;i<=NF;i++) a[$1][i]=$i; next } { for(j=2;j<=NF;j++) $j-=a[$1][j] }1' File2 File1 | rev | column -t | rev
List the combined path of the current working directory and "file.txt" </s> ls "`pwd`/file.txt"
Decompresses file 'xac.bz2', redirecting output to standard out. </s> bzip2 -dc xac.bz2
Find the unique owners of all the files in the /bin directory </s> find /bin -type f -follow | xargs    ls -al | awk ' NF==9 { print $3 }'|sort -u
Open a ssh connection to "user@host" with a control socket "/tmp/%r@%h:%p" </s> ssh user@host -S /tmp/%r@%h:%p
Find not-executable files under /home/www </s> find /home/www/ ! -executable
Locate files not owned by any user or group </s> find / -path /proc -prune -o -nouser -o -nogroup
SSH into server "app1" as the current user </s> ssh app1
Find the largest files in a particular location </s> find /home/tecmint/Downloads/ -type f -printf "%s %p\n" | sort -rn | head -n 5
Find all files/directories named 'myfile' under your home directory </s> find ~ -name myfile
List the current directory recursively ignoring the "dir1" subdirectory </s> find . -path ./dir1\*  -prune -o -print
display all the files having spaces in the current folder </s> find . -name "filename including space"
Find files under /some/path that are not executable </s> find /some/path -type f ! -perm -111 -ls
Forcibly removes all files like '*.bak' and '*~' </s> rm -f *.bak *~
Read a line from standard input with prompt "<Your Friendly Message here> : y/n/cancel" and save the response to variable "CONDITION" </s> read -p "<Your Friendly Message here> : y/n/cancel" CONDITION;
Recursively search through directory "test" in home directory, displaying names of all directories without full paths, ie. only the name part following the last slash of each directory. </s> find ~/test -type d -exec basename {} \;
Remove all broken symbolic links in /usr/ports/packages </s> find -L /usr/ports/packages -type l -delete
SSH with trusted X11 forwarding into "user@remoteToRemote_IP" from SSH connection "user@remote_IP" </s> ssh -XY -t user@remote_IP 'ssh -XY -t user@remoteToRemote_IP'
Remount "/dev/stl12" on "/system" as read only </s> mount -o ro,remount /dev/stl12 /system
Count the number of users logged in minus one </s> who | sed 1d | wc -l
Change owner to "$FUID" and group to "$FGID" of "$FILE2" </s> chown $FUID:$FGID "$FILE2"
Find all files under $1 directory excluding hidden files and append a null character at the end of each of their paths </s> find "$1" -path "*/.*" -prune -o \( -type f -print0 \)
Enables shell options 'nullglob' and 'dotglob'. </s> shopt -s nullglob dotglob
Find & calculate total number of caractor  in all .txt file from current directory </s> find .  -type f  -name '*.txt' -exec wc -c {} \; | awk '{total += $1} END{print total}'
SSH login in 'middle.example.org' via port 2222 as user 'deviceuser' using a private key file './device_id.pem' </s> ssh -i ./device_id.pem deviceuser@middle.example.org:2222
display all the files in the home folder which begin with "arrow" </s> find ~ -name 'arrow*'
Find files ending in "config" </s> find .  -path '*/*config'
List all files and directories residing in the current directory and below </s> find | xargs ls
reverse both words and lines in file </s> tac filename | awk '{for (i=NF; i>1; i--) printf("%s ",$i); printf("%s\n",$1)}'
Make directorie(s) 'es_MX.utf8/LC_MESSAGES' as needed in the current directory </s> mkdir --parents ./es_MX.utf8/LC_MESSAGES
Find symbolic links in /usr/lib and /usr/lib64 to files whose pathnames contain "libstdc++" </s> find  /usr/lib/ /usr/lib64/ -lname "*libstdc++*"
create directory /data/db </s> sudo mkdir /data/db
Display the 5 smallest files in the current directory and its sub-directories. </s> find . -type f -exec ls -s {} \; | sort -n  | head -5
Find all directories under $root and replace all newlines with : (colon) in the output </s> find $root -type d | tr '\n' ':'
Print numbers from 1 to 10 with 2 values per line </s> seq 10 | awk 'NR%2{printf("%s ", $0); next}1'
split $SOURCE_FILE" into pieces per 100 lines </s> split -l 100 "$SOURCE_FILE"
Recursively removes all files like '.DS_Store' from current folder. </s> rm `find ./ -name '.DS_Store'` -rf
Find recursively the latest modified file in the current directory </s> find . -type f -printf '%TY-%Tm-%Td %TH:%TM: %Tz %p\n'| sort -n | tail -n1
Create a gzip archive file ($tarFile) of all *.log files under $sourcePath </s> find $sourcePath -type f -name "*.log" -exec tar -uvf $tarFile {} \;
Display a sorted count of all the characters in "filename" </s> fold -w1 filename | sort | uniq -c | sort -nr
create a compressed archive "compressFileName.tar.gz" with verbose output </s> tar -zcvf compressFileName.tar.gz folderToCompress
Show the explanation of find's debugging options </s> find -D help
find all the files in the file system which have been accessed in the last 1 day </s> find / -atime -1
Find all regular files in and below the home directory that have been modified in the last 90 minutes </s> find ~ -type f -mmin -90
Search the /var/www/ tree for files owned by root or unknown group and change their group to 'apache' </s> find /var/www -group root -o -nogroup -print0 | xargs -0 chown :apache
Change the owner and group of "uid_demo" to "root" </s> sudo chown root:root uid_demo
Copy "6.3.3/6.3.3/macosx/bin/mybinary" to "~/work/binaries/macosx/6.3.3/" and create directory "~/work/binaries/macosx/6.3.3/" if "~/work/binaries/macosx/" exists </s> rsync 6.3.3/6.3.3/macosx/bin/mybinary ~/work/binaries/macosx/6.3.3/
list all the drectories present in the current directory and do not search in the sub directories. </s> find -maxdepth 1 -type d
Delete all .svn files/directories under current directory </s> find . -name .svn -exec rm -v {} \;
Search the system for directories named "needle" </s> find / -type d -name "needle"
create a symbolic link named "/usr/lib/jvm/default-java" to file "/usr/lib/jvm/java-7-oracle" </s> sudo ln -s /usr/lib/jvm/java-7-oracle /usr/lib/jvm/default-java
display long listing of all files in the current directory whose size is 24 or 25 bytes. </s> find . -size -26c -size +23c -ls
Print the path names of all .png files in the /home/kibab directory tree </s> find /home/kibab -name '*.png' -exec echo '{}' ';'
Check if a drive with UUID "$UUID" is mounted </s> mount | grep $(readlink -f /dev/disk/by-uuid/$UUID )
Find files/directories named 'file.txt' that belong to user 'tutonics' in the entire filesystem </s> find / -user tutonics -name "file.txt"
Count the number of files in the /usr/ports directory tree whose names begin with 'pkg-plist' and which contain 'etc/rc.d/' </s> find /usr/ports/ -name pkg-plist\* -exec grep -l etc/rc.d/ '{}' '+' | wc -l
List and remove all regular files named "core" that are larger than 500KB </s> find /prog -type f -size +1000 -print -name core -exec rm {} \;
Move all files and directories matching "*.boo" in the current directory to "subdir" </s> mv `ls *.boo` subdir
Delete all files not owned by valid users </s> find / -nouser | xargs -0 rm
display all the files in the current folder for the files which have been accessed in the last 24 hours </s> find . -type f -atime -1
search for all the mp3 files in the file system and move them to the folder /mnt/mp3 </s> find / -iname "*.mp3" -exec mv {} /mnt/mp3 \;
Search the /path directory tree for files missing g+w or o+w bits </s> find /path ! -perm -022
Immediately exit the shell if a command fails </s> set -e
Show the list of directories in the /mnt/raid directory tree </s> find /mnt/raid -type d -print
Find *.tex files in the current directory tree that contain text "documentclass" </s> find . -type f -name *.tex -print0 | xargs -0 grep -l 'documentclass'
Search for the Perl regex "[\x80-\xFF]" in *.xml files under current directory tree </s> find . -name *.xml | xargs grep -P "[\x80-\xFF]"
List all regular files in and below the home directory that were modified more than 5 years ago </s> find ~ -type f -mtime +1825 |xargs -r ls -l
Search the current directory recursively for regular files modified 2 days ago </s> find . type -f -mtime 2
List all regular files modified more than 61 days </s> find -type f -mtime 61 -exec ls -ltr {} \;
split result of the command "tar [your params]" into pieces per 500 mb named as "output_prefixNNN" </s> tar [your params] |split -b 500m - output_prefix
Find all directories under 'test' directory tree that match the regex '.*/course[0-9.]*' in their paths </s> find test -type d -regex '.*/course[0-9.]*'
Create intermediate directoriy path2 as required and directories a..z </s> mkdir -p path2/{a..z}
tar all files in the current folder and ask for user confirmation before creating the tar ball </s> find . -ok tar rvf backup {} \;
Search all *.c files from the current directory tree for "hogehoge" </s> find . -name \*.c -print | xargs grep hogehoge
Counts non-blank lines (lines with spaces are considered blank) in all *.py files in a current folder. </s> grep -v '^\s*$' *.py | wc
Find all files under $source_dir that match the regex .*\.\(avi\|wmv\|flv\|mp4\) in their paths and print them with null character as the delimiter </s> find "$source_dir" -type f -regex ".*\.\(avi\|wmv\|flv\|mp4\)" -print0
Search the current directory tree for all files except SVN ones </s> find . -not -iwholename '*.svn*'
Rename all directories under current directory by replacing all occurrences of 'Foo' (case insensitive) with 'Bar' in their names </s> find . -type d -iname '*foo*' -depth -exec rename 's@Foo@Bar@gi' {} +
Find all the files without permission 777 under current directory and show a few lines of output from the beginning </s> find . -type f ! -perm 777 | head
Find files containing string "#!/bin/ksh" and append their names and matching strings to /tmp/allfiles </s> find . -type f -execdir /usr/bin/grep -iH '#!/bin/ksh' {} \; | tee /tmp/allfiles
Find all *blue* files/directories under /myfiles </s> find /myfiles -name '*blue*'
Get the disk space used by all *.txt (case insensitive) files under /home/d directory </s> find /home/d -type f -name "*.txt" -printf "%s\n" | awk '{s+=$0}END{print "total: "s" bytes"}'
Recursively removes all files and folders named '.svn' in a current folder. </s> find . -name .svn |xargs rm -rf
Clear the terminal's search history </s> history -c
Find all files/directories that are bigger than 100 bytes under '/home/apache' directory tree </s> find /home/apache -size 100c -print
Print unique lines in sorted file "a.txt" compared to sorted file "b.txt" </s> comm -23 a.txt b.txt
delete all the regular files in the temp folder which have not been changed in the last 15*24 hours </s> find /tmp/ -ctime +15 -type f -exec rm {} \;
Remove all regular files found in and below /path </s> find /path -type f -exec rm '{}' \;
using exec in find command to dispaly the searched files </s> find . ... -exec cat {} \; -exec echo \;
Change string "searc" to "replace" in all files in directory hierarchy </s> find . -type f -exec sed -i 's/searc/replace/g' {} \;
Move all files/directories under current directory to ~/play </s> find . | xargs -I'{}' mv '{}' ~/play/
Remount "/" without writing in "/etc/mtab" </s> mount -n -o remount /
Find "*201512*" regular files in /home/myhome/data/ARCHIVE/ and move them to /home/myhome/ARCHIVE/TempFolder/ </s> find /home/myhome/data/ARCHIVE/. -name . -o -type d -prune -o -name '*201512*' -print | xargs -i mv {} /home/myhome/ARCHIVE/TempFolder/.
Add read and execute permission to command "node" </s> sudo chmod +rx $(which node)
Removes resursively all files and folders named ".DS_Store". </s> find . -name ".DS_Store" -print0 | xargs -0 rm -rf
List all regular files residing in the current directory tree and containing string "/bin/ksh" </s> find . -type f -exec grep -li '/bin/ksh' {} \;
Print the first 2 lines of tree's help message by redirecting it from standard error to standard output </s> tree --help |& head -n2
List all *.txt files/directories under /etc </s> find /etc -name "*.txt" | xargs ls -l
display all directories in a folder </s> find /etc -type d -print
display in a list of all the files that are bigger than 10KB in current folder </s> find . -size +10k -ls
Search the current directory tree for files last accessed more than 10 days ago </s> find . -atime +10
Delete the text matched by the regex '<script>if(window.*<\/script>' in all index.html files under current directory </s> find index.html | xargs -rt sed -i 's/<script>if(window.*<\/script>//g'
Find all files/directories with '.err' extension under '/home/username' directory tree </s> find /home/username/ -name "*.err"
Check if the file "somelink" links to exists </s> ls `readlink somelink`
Find all files in /dir1 and print only the filenames (not paths) </s> find ./dir1 -type f -exec basename {} \;
Find all files that have the SUID bit set </s> find / -perm -u+s -print
Counts lines in each of *.php files in a current folder and subfolders and prints total count as well. </s> find . -name "*.php" | xargs wc -l
Forcefully delete all files in the current directory </s> find . -name '*' | xargs rm
display all the files in the current folder which are present in the path "./sr*sc" </s> find . -path './sr*sc'
Rename file with inode number 31467125 to new_name.html </s> find . -type f -inum 31467125 -exec /bin/mv {} new_name.html \;
Gets MAC addresses of all IP4 network interfaces. </s> ifconfig -a | awk '/^[a-z]/ { iface=$1; mac=$NF; next } /inet addr:/ { print mac }' | grep -o -E '([[:xdigit:]]{1,2}:){5}[[:xdigit:]]{1,2}'
Read the history file $HISTFILE and append the contents to the history list </s> history -r "$HISTFILE"     #Alternative: exec bash
Change permissions to 0755 for all directories in the /path directory tree </s> find /path -type d | xargs chmod 0755
Print /some/dir/ if it's empty </s> find /some/dir/ -maxdepth 0 -empty
create directory new_dir </s> mkdir new_dir
delete all the files in the current folder </s> find . -delete
Delete all files with 128128 inode number under current directory tree </s> find . -inum 128128 | xargs rm
Prefix all files and directories in the current directory with "unix_" </s> ls | xargs -i mv {} unix_{}
Save the system host name into variable "HOST" </s> HOST=$(hostname)
search for all "tif" images in current folder </s> find . -name '*.tif ' -print
search for all the regular/normal mp3 files in the file system and move them to the folder /mnt/mp3 </s> find / -iname "*.mp3" -type f -print0 | xargs -0 -I '{}' /bin/mv "{}" /mnt/mp3/
Find recursively all regular .txt files in the current directory tree except README.txt </s> find . -type f -name "*.txt" ! -name README.txt -print
Sorts content of the $tmp file and filters out all strings with ':0'. </s> sort $tmp | grep -v ':0'  #... handle as required
Find all README's in /usr/share </s> find /usr/share -name README
Print the current date followed by ' doing stuff' </s> echo $(date) doing stuff
Remove all directories called "test" from the current directory tree </s> find -path "*/test" -type d -delete
Make a list of all files in the current directory tree, except *.png and *.class, and view it in the vim editor </s> find . | grep -E -v '\.png$|\.class$' | vim -
Find all executable files under current directory and reverse sort them </s> find . -perm -111 -type f | sort -r
Show all running processes with a name matching "postgres" </s> ps -ef | grep postgres
Execute awk script "script.awk" on "File2" and "File1" and format output as a table </s> awk -f script.awk File2 File1 | rev | column -t | rev
replace the word foo to bar in the current folder in all the regular/normal files containing the word "baz" in their name (does not update the file) </s> find . -type f -name "*baz*" -exec sed -i 's/foo/bar/g' {} +
Connect to host 'hostname' as user 'username' by forcing host key confirmation </s> ssh -o UserKnownHostsFile=/dev/null username@hostname
Search the /myfiles directory tree for files last accessed more than 30 days ago </s> find /myfiles -atime +30
Find all regular files with '.what_to_find' extension in the entire filesystem and move them to directory '/new_directory' </s> find / -iname "*.what_to_find" -type f -exec mv {} /new_directory \;
split file input.txt into pieces per 1 line named output.NNNNN </s> split --lines=1 --suffix-length=5 input.txt output.
Print the time to ping "8.8.8.8" followed by a time stamp if the ping is greater than 58 </s> ping 8.8.8.8 | awk '{split($7,a,"[=.]");if (a[2]>58) print a[2], strftime()}'
Find all files/directories under current directory that are greater than 10MB in size </s> find . -size +10M
display all the regular/normal files ending with ".mod" in a folder </s> find "$dir" -name "*.mod" -type f -print0
Find all *.ogg (case insensitive) files/directories in entire file system </s> sudo find / -iname '*.ogg'
Find all files in entire file system which are larger than 20000KB </s> find / -type f -size +20000k
find all the symbolic links in the current folder and follow to the pointing file </s> find -L
Print the names of all files in the home directory and its subdirectories recursively whose MIME type is video </s> find ~ -type f -exec file -i {} + | grep video
Sort ":" delimited lines in "test.txt" by the first and third field preserving only unique lines </s> sort -u -t : -k 1,1 -k 3,3 test.txt
Find all file.ext files/directories under /home/kibab directory and print . for each of them </s> find /home/kibab -name file.ext -exec echo . ';'
Show process tree with command-line arguments of a process that has id 20238. </s> pstree -a -p 20238
bind key "\x61" to insert itself </s> bind $'"\x61"':self-insert
List all active cron jobs, displaying only the command. </s> crontab -l | grep -v "^#" | awk '{print $6}'
Create a symbolic link named ".bash_profile" to ".bashrc" </s> ln -s .bashrc .bash_profile
Search the system for files and directories owned by user `admin' </s> find / -user admin -print
Search for 'Processed Files' in all $srch* (case insensitive) files under current directory </s> find . -iname "$srch*" -exec grep "Processed Files" {} \; -print
Display all files in a folder </s> find man5 -print
Print "new.txt" with line numbers prepended </s> cat new.txt  | nl
Delete all filename* files under /dir directory </s> find /dir -name "filename*" -type f -print | xargs rm
Create a ssh key and store it in the file ~/.ssh/apache-rsync </s> ssh-keygen -f ~/.ssh/apache-rsync
Find all files/directories under '/usr/share/doc' directory tree that contain 'readme' (case insensitive) at the beginning of their names </s> find /usr/share/doc -iname readme\*
Replace all occurrence of "log_errors = Off" with "log_errors = On" in all 'php.ini' files in the current directory tree </s> find . -name 'php.ini' -exec sed -i 's/log_errors = Off/log_errors = On/g' "{}" \;
Find all httpd.conf files in entire file system </s> find / -name httpd.conf
Silently read a line from standard input into variable "REPLY" without backslash escapes and using the prompt $'Press enter to continue...\n' </s> read -rsp $'Press enter to continue...\n'
Copies 'src' to 'dest' preserving overwriting the existing files. </s> cp -n src dest
display a long listing of all the xls or csv files in the entire file system </s> find / -regex ".*\.\(xls\|csv\)"
Delete all files/directories with node number $inum under current directory tree </s> find . -inum $inum -exec rm {} \
Remove what follows the forth occurrence of the character ":" in any field which contains it </s> sed -r 's/((:[^: \t]*){3}):[^ \t]*/\1/g' file | column -t
Find all files/directories with space in their names under  /tmp/ directory and rename them by replacing all spaces with _ </s> find /tmp/ -depth -name "* *" -execdir rename 's/ /_/g' "{}" \;
ssh into default vagrant host without running "vagrant ssh" by passing the configuration parameters vagrant uses for ssh </s> ssh vagrant@127.0.0.1 -p 2222 -o Compression=yes -o DSAAuthentication=yes -o LogLevel=FATAL -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o IdentitiesOnly=yes -i ~/.vagrant.d/less_insecure_private_key -o ForwardAgent=yes
Add directory "$HOME/Pictures" to the directory stack </s> pushd "$HOME/Pictures"
display the base name(name without extension) of all the ".NEF" files in the current folder </s> find . -name "*.NEF" -exec basename \{\} .NEF \;
Extract 8 bytes as an unsigned integer that is "$o" offset into "$pkg" </s> set `od -j $o -N 8 -t u1 $pkg`
Find a single file called tecmint.txt and remove it </s> find . -type f -name "tecmint.txt" -exec rm -f {} \;
Delete all hidden files/directories under $some_directory including $some_directory </s> find $some_directory '.*' -delete
Read a line from standard input with prompt "Continue (y/n)?" and save response in variable "CONT" </s> read -p "Continue (y/n)?" CONT
Find and print all PDF files in the current directory and its sub-directories except for any found in the ./pdfs directory. </s> find . -name "*.pdf" -print | grep -v "^\./pdfs/"
Find all regular files in current directory and /home/www directory </s> find * /home/www -type f
Print the current directory </s> find -maxdepth 0
Print flow of random data, showing all non-printing characters </s> cat -v /dev/urandom
Find all files/directories with '.in' extension in the directory $directory and its subdirectories </s> du -a $directory | awk '{print $2}' | grep '\.in$'
find the oldest normal file in the current directory and display its contents </s> find -type f -printf "%T+ %p\0" | sort -z | grep -zom 1 ".*" | cat
Search the current directory recursively for files containing "needle text" </s> find . -type f -print0 | xargs -0 grep -I "needle text"
find regular files under the current directory, whose name ends in .mbox and using awk run multiple system commands to rename each matched file, to the same name without .mbox at the end </s> find . -wholename \*.mbox | awk '{new=$0; gsub("\.mbox$", "", new) ; system("mv \"" $0 "\" \"" new "\"") }'
Saves printed calendar for $month, $year in positional variables. </s> set `cal $month $year`
display all the files in the current folder expect perl shell and python fiels </s> find . -not -name "*.pl" -not -name "*.sh" -not -name "*.py"
List each directory in the current directory prefixed with its disk usage in human readable format and sorted from smallest to largest </s> du -sh */ | sort -n
Prints processes with 'MDSImporte' in name, cutting off  lines longer than screen width, exiting from less after end of output and saving printed lines on terminal after exit. </s> pstree | grep MDSImporte | less -SEX
Determine if user "$USER" is logged in </s> who | grep $USER
display all files in the file system which are bigger than 50MB and having size "filename" in them </s> find / -size +50M -iname "filename"
Removes all files but 5 newest ones from current folder. </s> ls -tp | grep -v '/$' | tail -n +6 | xargs -I {} rm -- {}
Copy the 3 specified files to /tmp/package, preserving/creating directory structure of each file as specified on command line. </s> cp --parents src/prog.js images/icon.jpg /tmp/package
Find all regular files in the /path/to/base/dir tree </s> find /path/to/base/dir -type f
Shows status of a shell option 'dotglob'. </s> shopt dotglob
Locate OGG files under the home directory smaller than 100 megabytes </s> find $HOME -iname '*.ogg' -type f -size -100M
Change directory to "/lib/modules/" of the current kernel release </s> cd /lib/modules/$(uname -r)/
find all files ending with "js.compiled" in current folder </s> find . -type f -name "*.js.compiled"
List all files in entire file system that are newer than the file $newerthan and older than the file $olderthan in regards of modification time </s> find / -type f -name "*" -newermt "$newerthan" ! -newermt "$olderthan" -ls
Remove all files in and below the current directory whose names begin with "not" </s> find . -name not\* | xargs -d '\n' rm
find all the file which name (name can contains space) end with c or h and content contain 'thing' </s> find . -name '*.[ch]' -print0 | xargs -r -0 grep -l thing
Change permissions to 755 for all subdirectories of the current directory </s> find . -type d -print | sed -e 's/^/"/' -e 's/$/"/' | xargs chmod 755
list regular file which file name is NOT end with '.html' in current directory in current directory </s> find . -type f -not -name "*.html"
Recursively finds and compresses all files in the directory '/path/to/dir' </s> find /path/to/dir -type f -exec bzip2 {} \;
Find files which are more than 2 days old under  ${userdir}/${i}/incoming directory and remove them </s> find ${userdir}/${i}/incoming -mtime +2 -type f -exec rm {} \;
Split "database.sql" into files of at most 100000 lines each with prefix "database-" </s> split -l 100000 database.sql database-
Print summary of new/missing files, and which files differ between /path/to/folder1 and /path/to/folder2, sorted alphabetically. </s> diff -rq /path/to/folder1 /path/to/folder2
Remove adjascent duplicate lines from file 'input' comparing all but last space-separated fields </s> rev input | uniq -f1 | rev
Change directory to the real path of the directory containing the current script </s> cd $(readlink -f $(dirname $0))
display all the files in the current folder along with the hidden files with the depth </s> find . — name "*" — print -о -name ".*" — print -depth
find all files in the folder /etc which have been modified after /tmp/foo </s> find /etc -newer /tmp/foo
Print the home directory of "$username" </s> finger $username | awk '/^Directory/ {print $2}'
display all the files in the current folder which have been accessed in the last 60 minutes </s> find . -amin -60
Display differences between list of files in /bin and /usr/bin. </s> diff <(ls /bin) <(ls /usr/bin)
Print the absolute path of "$path" </s> readlink -f "$path"
Change directory to parent directory and do not resolve any symlinks in the resulting path </s> cd -L ..
Find all *.jpg files in */201111 paths </s> find */201111 -name "*.jpg"
Print line, word and byte count for each file recursively and also show the total counts </s> wc `find`
find all the files in the folder "/mp3-collection" which are bigger than 10MB excluding those that start with the word Metallica </s> find /mp3-collection -size +10000k ! -name "Metallica*"
Find all files under current directory and search for 'something' in those files </s> find . -exec grep something {} +
search for all the files in the current directory which have the group staff and have write permission enabled to the user and display them. </s> find . -group staff -perm -2000 -print
Print help on 'cat' command usage </s> cat --help
Remove files named "core" from the /work directory tree and write their names to /dev/stderr (the standard error </s> find /work \( -fprint /dev/stderr \) , \( -name 'core' -exec rm {} \; \)
Remove all files in the /myfiles directory tree that were accessed at least 30 days ago </s> find /myfiles -atime +30 -exec rm {} ;
Find all files/directories in entire file system with 644 permission </s> find / -perm 644
Delete file with inode number 314167125 </s> find . -type f -inum 314167125 -delete
Print the last white space separated field of every line in "file.txt" as a ", " separated list </s> awk '{print $NF}' file.txt | paste -sd, | sed 's/,/, /g'
Remove empty directories from directory tree /srv/${x} </s> find /srv/${x} -type d -empty -exec rmdir {} \;
change owner of the file /home/bob to user root </s> sudo chown root /home/bob
Search the current directory and all of its sub-directory for any PDF files. </s> find . -name "*.pdf" -print
search for all the directories ending with ".mp3" in the file system and move them to the folder /mnt/mp3 </s> find / -iname "*.mp3" -type d -exec /bin/mv {} /mnt/mp3 \;
Find all *.ogg (case insensitive) files under your home directory that are less than 100MB in size </s> find $HOME -iname '*.ogg' -type f -size -100M
Find root's files in the current directory tree </s> find ./ -user root
Find all CSS files </s> find . -name "*.css"
Find all Subscription.java files/directories under current directory and enter into the parent directory of the first one found </s> cd `find . -name Subscription.java | xargs dirname`
find all files in the current folder which start with pro </s> find . -name pro\*
Set variable GZIP to the full path of command "gzip" </s> GZIP="$(which gzip)"
Exclude directory from find . command </s> find ./ -path ./beta/* -prune -o -iname example.com -print
find all the mp3 files in the file system </s> find / -iname "*.mp3" -print
Execute "wget -qO-  http://fake.link/file.txt" every 5 seconds </s> watch -n 5 wget -qO-  http://fake.link/file.txt
Find all .sh files in the current directory tree and remove them </s> find . -name "*.sh" -exec rm -rf '{}' \
Grab the output of "basename" (in this case "stuff") and echo it to stdout, which basename would do by default anyway. </s> echo $(basename /foo/bar/stuff)
Display a long listing of all regular files that are less than 50 bytes in size under '/usr/bin' directory tree </s> find /usr/bin -type f -size -50c -exec ls -l '{}' ';'
Find all executables under /path directory </s> find /path -perm /ugo+x
Print the current working directory with resolved symbolic links </s> pwd -P
Search  in current directory downwards all files whose owner is aa1 or whose name is myfile . </s> find . \( -user aa1 -o -name myfile \) -print
Save full path of command "mktemp" to variable "MKTEMP" </s> MKTEMP=`which mktemp`
Send 5 pings to broadcast address "10.10.0.255" and print the unique IPs who responded </s> ping -c 5 -b 10.11.255.255 | sed -n 's/.* \([0-9]\+\.[0-9]\+\.[0-9]\+\.[0-9]\+\).*/\1/p' | sort | uniq
Search everywhere for files changed within the last minute </s> find / -newerct '1 minute ago' -print
Find all files named 'foo' under current directory tree without descending into directories named 'foo' </s> find . -name foo -type d -prune -o -name foo -print
Print mount point of the file system containing $path. </s> df "$path" | tail -1 | awk '{ print $6 }'
Add a line number to every line in "infile" </s> nl -ba infile
Remount "/system" with read and write permission </s> mount -o remount,rw /system
Print each line in "file1" and file2" separated by tabs and "file3" separated by a space </s> paste -d" " file1 file2 | paste -d'|' - file3 | sed 's,|, ,g'
Search directory tree $DIR for *.txt files </s> find "${DIR}" -name "*.txt"
display all the files in the entire file system which have set uid bit set. </s> find / -perm -u+s -print
Remove all .php files in the /var/www/ directory </s> find /var/www/*.php -type f -exec rm {} \;
Search for files/directories with the case insensitive pattern anaconda.* in var/log directory </s> find var/log/ -iname anaconda.*
Unzip "file.gz", list the unique lines matching regex pattern '"searchstring":"[^"]*"' prefixed by the number of occurrences, sort from least frequent to most frequent </s> zcat file.gz | grep -o '"searchstring":"[^"]*"'| sort | uniq -c | sort -n
Save the number of matching executables for "$cmd" in $PATH to variable "candidates" </s> candidates=$(which -a $cmd | wc -l)
list all active jobs and its IDs </s> jobs -l
show all files in /usr/tom and display only files ending with ".pl" or ".pm" </s> find /usr/tom | egrep '*.pl| *.pm'
Find all the SUID files in the current directory tree </s> find . -perm /u=s
Display "infile" as printable characters or backslash escapes </s> cat infile | od -c
Search the current directory tree for regular files that were accessed $FTIME days ago </s> find . -type f -atime $FTIME
Prints hierarchical process tree. </s> pstree
Search for "www.athabasca" in all files under current directory </s> find . -exec grep "www.athabasca" '{}' \; -print
Copy recursively "/source/backup" to "/destination" preserving symbolic links, modification times, and permissions </s> rsync -rtvpl /source/backup /destination
display all the directories in the folder /usr/share </s> find /usr/share -type d
Find writable regular files in the current directory </s> find -type f -maxdepth 1 -writable
List all files/directories in entire file system </s> find / -print
Search for files greater than 20MB in the entire file system and display the path and file size </s> find / -type f -size +20M -exec ls -lh {} \; | awk '{ print $NF ": " $5 }'
Set the 'xtrace' shell variable </s> set -x
Search PATH for utilities called "rename", display the type of file (script, executable, ...) for each match found. </s> which -a rename | xargs file -L
List each file or directory in the current directory prefixed with its filesize in MB and sorted from smallest to largest </s> du -smc * | sort -n
Find all files/directories owned by the user 'bob' under '/home' directory tree </s> find /home -user bob
The cpio command is a copy command designed to copy files into and out of a cpio or tar archive, automatically preserving permissions, times, and ownership of files and subdirectories. </s> find . | cpio -pdumv /path/to/destination/dirrectory
List .c files in the current directory </s> find . \( ! -name . -prune \) -name "*.c" -print
Recursively search for everything under the current directory, displaying human-readable file type description for each entry. </s> find . -exec file {} \;
find all of the executable files on your computer </s> find / -executable
Display standard input as printable characters or backslash escapes with no addressing radix </s> od -cAn;
Delete all files in the TBD directory that were modified more than 1 day ago </s> find /TBD/* -mtime +1 | xargs rm -rf
Search the current directory recursively for files last modified within the past 24 hours ignoring .swp files and "en" and "es" directories </s> find . \( -name en -o -name es \) -prune , -mtime 0 ! -name "*.swp"
Set permissions to ug=rwx,o= for directories inside the ./default/files tree </s> find ./default/files -type d -exec chmod ug=rwx,o= '{}' \;
Find all files/directories under current directory that match the case insensitive regex .*/\(EA\|FS\)_.* </s> find . -iregex '.*/\(EA\|FS\)_.*'
Search for empty files </s> find . -size 0k
Extract any line in "set1" which does not appear in "set2" </s> comm -23 <(sort set1) <(sort set2)
Recursively find the latest modified file in the current directory </s> find . -type f | xargs ls -ltr | tail -n 1
List all *fink* files/directories in entire file system </s> find / \( -type f -or -type d \) -name \*fink\* -ls
display all the files ending with ".user" or beginning with "admin" or ending with ".user.gz" in /var/adm/logs/morelogs/ and excluding  all regular files </s> find /var/adm/logs/morelogs/* -type f -prune \( -name "admin.*" -o -name "*.user" -o -name "*.user.gz" \) -print
Make directory "/cpuset" </s> mkdir /cpuset
Find all files/directories under current directory with null character as the delimiter and then replace the null characters with : </s> find -print0 | tr "\0" ":"
display all the files along with their group name in the folder /home which do not belong to the group test </s> find /home ! -group test -printf "%p:%g\n"
find all the regular/normal files in the current folder and do not search in the sub directories </s> find . -maxdepth 1 -type f
Split "input.txt" into files with 1 line each and use a prefix "output." and a suffix length of 5 </s> split --lines=1 --suffix-length=5 input.txt output.
Search all files in the current directory tree, except *.html and *.svn*, for "SearchString" </s> find . ! -name '*.html' ! -name '*.svn*' -exec grep 'SearchString' {} /dev/null \;
Read a single character from standard input with prompt "Is this a good question (y/n)? " and timeout of 3 seconds and save the response to variable "answer" </s> read -t 3 -n 1 -p "Is this a good question (y/n)? " answer
Recursively search through all files in all directories for any lines containing "pattern" and whose second word is not "Binary". </s> grep -Ri "pattern" * | awk '{if($1 != "Binary") print $0}'
Delete all files in directory $DIR that have not been accessed in at least 5 days </s> find "$DIR" -type f -atime +5 -exec rm {} \;
copy all files which do not have execute permission to another folder </s> cp `find -perm -111 -type f` /usr/local/bin
Get the disk space used by all *.txt (case insensitive) files/directories under current directory </s> find . -name "*.txt" -print0 |xargs -0 du -ch | tail -n1
Find all *.c files under and below the current directory that contain "wait_event_interruptible" </s> find . -name \*.c -exec grep wait_event_interruptible {} +
Change owner to "root" and group to "wheel" of "adbind.bash" </s> sudo chown root:wheel adbind.bash
Find regular non-hidden files containing 'some text' in their names </s> find . -not -path '*/\.*' -type f -name '*some text*'
Execute `find -type f | egrep -i "(jpg|bmp|png|gif)$"` every 300 seconds and display without title </s> watch -n 300 -t `find -type f | egrep -i "(jpg|bmp|png|gif)$"`
Locate logo.gif in the /var/www directory tree </s> find /var/www -name logo.gif
Display all files in the current directory tree that match "*foo" </s> tree -P "*foo"
dsisplay all files inthe current folder </s> find .
Prints real path of the folder containing $0 file. </s> $(readlink -f $(dirname "$0"))
Display a long listing of the oldest file under '/hom/backups' directory tree </s> find /home/backups -printf "%T@ %p\n" | sort -n | head -1 | cut -d" " -f2- | xargs ls -al
Find all files beneath the current directory that end with the extension .java and contain the characters String ignoring case.  Print the name of the file where a match is found. </s> find . -type f -name "*.java" -exec grep -il string {} \;
Find all *foo files/directories under current directory (error prone) </s> find . name *foo
Assigns MAC address 00:80:48:BA:d1:30 to interface eth0. </s> ifconfig eth0 hw ether 00:80:48:BA:d1:30
Copy all .png files from the home directory tree to imagesdir/ </s> find ~/ -name *.png -exec cp {} imagesdir \;
Find and print detailed information about all regular files in your home directory and below that have only the group permission set </s> find . -perm g=r -type f -exec ls -l {} \;
Show manual page of find utility </s> man find
Change the ownership of all aluno1's files in the current directory and below to aluno2 </s> find . -user aluno1 -exec chown aluno2 {}
Find all directories under '/nas' directory tree </s> find /nas -type d
Find all files/directories owned by user 'joebob' under '/some/directory' directory tree </s> find /some/directory -user joebob -print
find all the files ending with jpg in current folder and display their count ( case insensitive ) </s> find ./ -iname '*.jpg' -type f | wc -l
Find all .less files in the current directory tree </s> find . -name *.less
Find all files/directories that start with 'screen' (case insensitive) in their names under user's home directory tree </s> find ~ -iname "screen*"
remove all the files in the present directory which have special characters in their name and do not search in the sub directories of the current folder. </s> find . -name '*[+{;"\\=?~()<>&*|$ ]*' -maxdepth 0 -exec rm -f '{}' \;
change the extension of all the files in the current folder to html excluding those html files and those which are present in another disk partition </s> find . -xtype f \! -iname *.html   -exec mv -iv "{}"  "{}.html"  \;
Find files/directories under current directory that are modified exactly one hour ago </s> find . -mtime 1
Search the current directory tree for files whose names contain "bills" </s> find . -name '*bills*' -print
find all the fles that have .ssh in the end and redirect the output to ssh-stuff </s> find / -name .ssh* -print | tee -a ssh-stuff
list the regular files in your home directory that were modified yesterday </s> find ~/ -daystart -type f -mtime 1
Fetch a script from the web, and interpret it in the current shell. </s> source <(curl -s http://mywebsite.com/myscript.txt)
Print the list of files in the current directory tree ignoring .svn, .git, and other hidden directories </s> find . -type f -not -path '*/\.*'
Find all directories under ~/code without descending into hidden directories and print them appended with : (colon) </s> find ~/code -name '.*' -prune -o -type d -printf ':%p'
Count the number of lines in all ".php" files in the current directory tree </s> find . -name '*.php' -type f | xargs cat | wc -l
Replace "string1" with "string2" in all regular files in the current directory tree </s> find ./ -type f -exec sed -i 's/string1/string2/g' {} \;
find files in /usr directory which are modified after February 1 of the current year </s> find /usr -newermt "Feb 1"
Read a line from standard input and save received words sequentially in variables XPID XUSERID XPRIORITY XVIRTUAL XRESIDENT XSHARED XSTATE XCPU XMEM XTIME XCOMMAND </s> read XPID XUSERID XPRIORITY XVIRTUAL XRESIDENT XSHARED XSTATE XCPU XMEM XTIME XCOMMAND
Find all files in /var/www/html/zip/data/*/*/*/*/* that are older than 90 days and print their parent directory paths </s> find /var/www/html/zip/data/*/*/*/*/* -type f -mtime +90  | sed 's|/[^/]*$||'
Count the number of .gz files in the current directory tree </s> find -name "*.gz" | wc -l
search for files with the name "temp" in the /usr folder </s> find /usr -name temp -print
List all regular files in and below the home directory that were modified more than 5 years ago </s> find ~ -type f -mtime +1825 |xargs ls -l
Variable PID contains a process ID, check if this process exists - resulting exit status from this command will be zero if it does and current user has permission to send it signals. </s> kill -0 $PID
Find all ES* and FS_* files under current directory </s> find . -type f \( -iname "ES*" -o -iname "FS_*" \)
Find all files under /home/mywebsite/public_html/sites/all/modules and set their permission to 640 </s> find /home/mywebsite/public_html/sites/all/modules -type f -exec chmod 640 {} +
Delete all regular files with '.cache' extension that were accessed more than 30 days ago under $HOME/Library/Safari/Icons directory tree </s> find $HOME/Library/Safari/Icons -type f -atime +30 -name "*.cache" -print -delete
Search all files from the /tmp directory tree for the string "search string" </s> find /tmp -type f -exec grep 'search string' '{}' /dev/null \+
find files in /dir/path/look/up directory that names are dir-name-here </s> find /dir/path/look/up -name "dir-name-here" -print
Recursively copy "original_dir" to "copy_dir" preserving file/dir timestamps, displaying progress, and skipping files which match in size, keeps partially transferred files. </s> rsync -Prt --size-only original_dir copy_dir
Read a single character from standard input with delimeter '' and no echo </s> read -d'' -s -n1
delete all the ".doc" files in the current folder </s> find . -name '*.doc' -exec rm "{}" \;
print all PIDs of stopped processes </s> jobs -sl | awk '{print $2}'
display all the files in the current folder and do not search in sub directories and move them to the directory /directory1/directory2. </s> find . -maxdepth 1 -type f | xargs -I ‘{}’ sudo mv {} /directory1/directory2
Create symbolic links in current directory for all files located in "dir" directory and have filename extension "jpg" </s> find dir -name '*.jpg' -exec ln -s "{}" \;
display the count of total number of empty files in the current folder </s> find . -type f -empty | wc -l
Print the full path of command "cc" </s> which cc
Decompress "path/to/test/file.gz" to standard output and save all lines matching "my regex" to files with a 1000000 line limit </s> gzip -dc path/to/test/file.gz | grep -P --regexp='my regex' | split -dl1000000 - file
Repeat "image.png" 10 times on a single line </s> yes image.png | head -n10 | xargs echo
Read standard input until a null character is found and save the result in variable "line" </s> read -r -d $'\0'
Find all python files under current directory tree, save the list to 'output.txt' and search for 'something' in those files </s> find . -name '*.py' | tee output.txt | xargs grep 'something'
Find all 'test' directories in the current directory tree and remove them </s> find . -name test -type d -print0|xargs -0 rm -r --
Serach for all the files starting with grep in man pages </s> find /usr/share/man/ -regex grep.*
Removes everything from current folder but '*ddl*' and '*docs*' files. </s> ls -1|grep -v -e ddl -e docs| xargs rm -rf
Change the user to daisy for directories and subdirectories owned by harry </s> find . -type d -user harry -exec chown daisy {} \;
Finds recursively all files not having extension .o in '/path/' that contain 'pattern', and prints matched strings with string number and file name. </s> grep --exclude=*.o -rnw '/path/to/somewhere/' -e "pattern"
Search directories called ' backup ' from /usr directory downwards and print them. </s> find /usr -type d -name backup -print
Give the location of every hard link to file1 in the /home directory tree </s> find /home -xdev -samefile file1 | xargs ls -l
Copy all files ending in ".a" in directory trees matching "folder*" to "/path/to/dest" preserving directory hierarchy </s> find folder* -name '*.a' -print | cpio -pvd /path/to/dest
Find all .gz archives in the current directory tree and check if they are valid </s> find "*.gz" -exec gunzip -vt "{}" +
Pushes current folder to the directory stack. </s> pushd .
search for all empty directories in the folder /home </s> find /home -type d -empty
Filters only directories from long file listing of a current directory, and prints their names. </s> ls -l | grep "^d" | awk -F" " '{print $9}'
change cgi files to mode 755 </s> find htdocs cgi-bin -name "*.cgi" -type f -exec chmod 755 {} \;
find all directory list which have empty list in /tmp directory . </s> find /tmp -type d -empty
search  character special files called ' backup '  from  /usr directory downwards and print them . </s> find /usr -type c -name backup -print
Find all files ignoring hidden files under current directory and replace every occurrences of 'subdomainA.example.com' with 'subdomainB.example.com' in those files </s> find . -not -path '*/\.*' -type f -print0 | xargs -0 sed -i 's/subdomainA\.example\.com/subdomainB.example.com/g'
Print the names of all the files from directory tree ~/some/directory whose names end in "rb" </s> find ~/some/directory -name "*rb" -exec basename {} \;
find all sqlite files in the current directory. </s> find ./ -name "*.sqlite"
Gets string with IP4 address of en0 network interface. </s> ifconfig en0 | grep inet | grep -v inet6
search for a word in all the files in the current directory and display the file paths relative to the current directory </s> find . -exec grep -l foo {} +
Delete all in the current directory tree </s> find . -delete
Print numerically sorted list of unique strings from 'ip_addresses' file, with number of occurrences of each string. </s> sort -n ip_addresses.txt | uniq -c
Archive "src-dir" to "dest-dir" on "remote-user@remote-host" and delete any files in "dest-dir" not found in "src-dir" </s> rsync -av --delete src-dir remote-user@remote-host:dest-dir
Cut off three last symbols from string '1234567890  *' </s> echo '1234567890  *' | rev | cut -c 4- | rev
display the directory name along with the modified time  for all the files /var </s> find /var -maxdepth 2 -type d -printf "%p %TY-%Tm-%Td %TH:%TM:%TS %Tz\n"
Save "$N" number of '.' characters in variable "myvar" </s> myvar=`seq 1 $N | sed 's/.*/./' | tr -d '\n'`
Search the .py files residing in the current directory tree for "something" </s> find . -name "*.py" -type f -exec grep "something" {} \;
Gets all IP addresses from host network configuration and prints first one. </s> ifconfig | grep "inet addr:" | grep -v "127.0.0.1" | grep -Eo '[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}'  | head -1
Look for "testfile.txt" in the "/" directory and 1 level below </s> find / -maxdepth 2 -name testfile.txt
search for all the regular files in the folder /home which have the permission 077 </s> find /home -type f -perm 0777 -print
search for the folder .dummy in the entire directory structure of "test folder" and remove it. </s> find -depth "Test Folder" -type d -name .dummy -exec rm -rf \{\} \;
Find all files/directories greater than 100MB and print their list along with their size in /root/big.txt file </s> find \( -size +100M -fprintf /root/big.txt '%-10s %p\n' \)
Display a long listing of all the regular files under current directory tree that are newer than ‘Apr 18 23:59:59 EDT 2013’ and older than ‘Apr 20 00:00:00 EDT 2013’ by modification time </s> find . -type f -newermt ‘Apr 18 23:59:59 EDT 2013’ ! -newermt ‘Apr 20 00:00:00 EDT 2013’ -exec ls -l ‘{}’ \;
Find files that do not have a listing in the /etc/passwd or /etc/group in the file system </s> find / -nouser -o  -nogroup
Finds strings with dot-separated sequence of numbers, and prints part of that sequence between the first and second dot. </s> echo "$f" | grep -Eo '[0-9]+[.]+[0-9]+[.]?[0-9]?' | cut -d. -f2
Abort the shell or script on the first failed command </s> set -e
Write a random list of numbers to /tmp/lst and stdout. </s> seq 1 10 | sort -R | tee /tmp/lst |cat <(cat /tmp/lst) <(echo '-------') **...**
Find all directories under 'project' directory without going into subdirectories that do not match the POSIX egrep regex $PATTERN in their paths and are not empty </s> find project -maxdepth 1 -mindepth 1 -regextype posix-egrep ! -iregex  $PATTERN  ! -empty -type d
Find all files/directories named 'photoA.jpg' under current directory tree </s> find . -name photoA.jpg
prints a number stored among text in $filename </s> echo $filename | egrep -o '[[:digit:]]{5}' | head -n1
Saves in 'result' variable list of groups which user $line belongs to, and not matching pattern "_unknown|sciences|everyone|netaccounts" </s> result=$(groups "$line" | sed 's/ /\n/g' | egrep -v "_unknown|sciences|everyone|netaccounts")
Find all lines matching "$USER" in "file" and number the output </s> grep  $USER file |nl
Decompress and unarchive "hello-0.2.tar.gz" </s> gzip -dc hello-0.2.tar.gz | tar -xf -
Remove all text files in the home directory with confirmation </s> find $HOME/. -name *.txt -ok rm {} \;
Display difference between one.txt and two.txt side-by-side. </s> diff -y one.txt two.txt
search for the file in the entire file system which has the words "filename" in its name </s> find / -name ”*filename*”
find all png files in the current folder </s> find . -type f -name '*.png'
List all files in a current folder, separating names with comma </s> ls -1 | tr '\n' ','
Opens new tmux session. </s> tmux
find all the regular files in the current folder which start with a "some text" </s> find . -type f -name '*some text*'
Find all files/directories with '.js' extension under current directory tree without descending into './directory' </s> find . -path ./directory -prune -o -name '*.js' -print
find all the regular/normal files in the current folder which belong to the user "sedlav" </s> find . -user sedlav -type f
Search the current directory recursively for regular files last changed more than 2 days ago </s> find . type -f -ctime +2
List characters from standard input showing backslash escapes for non-displayables </s> od -cvAnone -w1
Create a symbolic link named "$1/link" to the current working directory </s> ln -s "`pwd`" $1/link
Find all directories in entire file system which are larger than 50KB </s> find / -type d -size +50k
Send SIGTERM signal to last process sent to background by the current shell. </s> kill $!
Send one ping request to local machine. </s> ping -c 1 127.0.0.1 #ping your adress once
Search for all files newer than file /tmp/t1 but not newer than file /tmp/t2 </s> find / -newer /tmp/t1 -and -not -newer /tmp/t2
List the directory paths of all file.ext files under present working directory </s> find `pwd` -name "file.ext" -exec dirname {} \;
Find all files/directories under current directory that were modified later than /reference/file </s> find . -newer /reference/file
Find files/directories that have not been modified in the last one day in directories or files taken from the glob pattern '/tmp/test/*' </s> find /tmp/test/* -daystart -mtime +1
change the permissions of all the regular files in the folder root_dir to 444 </s> find root_dir -type f -exec chmod 444 {} \;
Find all PHP files under current directory that contain only one line </s> find -name *.php -print | xargs -L1 awk 'NR>1{exit} END{if(NR==1) print FILENAME}'
Print the contents of "order.txt" </s> cat order.txt
get all the files that are exactly 30 days old </s> find . -mtime 30 -print
Output success.txt omitting lines whose first field appears in fail.txt - lines in fail.txt must appear in the same order as they do in success.txt. </s> join -v1 success.txt fail.txt
find all the files in the file system which have not been modified in the last 100*24 hours </s> find / -mtime +100 -print
Identify CMS version/releases accross all your Drupal websites </s> find /var/www/vhosts/*/httpdocs/ -type f -iwholename "*/modules/system/system.info" -exec grep -H "version = \"" {} \;
Search the local subdirectory tree of the current working directory and the /tmp directory tree for directories named mydir </s> find local /tmp -name mydir -type d -print
Find all *.txt files/directories under your home directory </s> find ~ -name "*.txt" -print
Remove all .mpg files in the /home/luser directory tree </s> find /home/luser -type f -name '*.mpg' | tr "\n" "\000" | xargs -0 rm -f
Create a compressed archive of "/home" and split the contents into files with at most 4000 MiB each and use prefix "/media/DRIVENAME/BACKUPNAME.tgz" </s> tar --one-file-system -czv /home | split -b 4000m - /media/DRIVENAME/BACKUPNAME.tgz
Find all files/directories under current directory that match the case insensitive regex ./\(EA\|FS\)_.* </s> find . -iregex './\(EA\|FS\)_.*'
keep only read access to all the files in a directory. </s> find /path/to/dir/ -type f ! -perm 0644 -print0 | xargs -0 chmod 644
Move all files not matching "Tux.png" in "~/Linux/Old" to "~/Linux/New/" using zsh with "EXTENDED_GLOB" </s> mv ~/Linux/Old/^Tux.png ~/Linux/New/
Find all the regular files under current directory tree that have not been modified in the last 31 days and delete them </s> find . -type f -mtime +31 -print0 | xargs -0 -r rm -f
Prints total count of lines of all *.php files in a current folder and subfolders. </s> find . -name '*.php' -type f -exec cat -- {} + | wc -l
Find all files/directories in directories/files taken from the glob pattern '/tmp/test/*' recursively that have not been modified from the start of the day </s> find /tmp/test/* -daystart -mtime +0
Send at most 3 ping requests to "8.8.8.8" with a timeout of 3 seconds on interface "eth9" </s> ping 8.8.8.8 -I eth9 -c 3 -w 3
Find all regular files starting from / that have permissions 777 </s> find / -type f -perm 0777
display all files in the entire file system excluding those that are in the transfer directory </s> find / -name /transfer -prune -o -print
Interpret backslash sequences and delete whitespace characters in variable $FOO and save the result to variable 'FOO_NO_WHITESPACE' </s> FOO_NO_WHITESPACE="$(echo -e "${FOO}" | tr -d '[[:space:]]')"
Show the files or directories in the current directory whose names are not "MyCProgram.c" </s> find -maxdepth 1 -not -iname "MyCProgram.c"
Set permissions of all directories under "/opt/lampp/htdocs" to 711 </s> find /opt/lampp/htdocs -type d -exec chmod 711 {} \;
Search directory /tmp/foo for files containing "/tmp/foo/bar" in their full names </s> find /tmp/foo -path /tmp/foo/bar -print
Search the current directory recursively for regular files last accessed less than 2 days ago </s> find . type -f -atime -2
create directories bravo_dir and alpha_dir </s> mkdir bravo_dir alpha_dir
Split the output of "tar [your params]" into files of at most 500 MiB in size and use prefix "output_prefix" </s> tar [your params] |split -b 500m - output_prefix
Calculate md5 sum of empty string </s> echo -n | md5sum
Make directories to "/some/path" as needed </s> mkdir -p ./some/path
Find all files under /mnt/naspath directory without descending into .snapshot directory that were modified in last 24 hours with null character as the delimiter </s> find /mnt/naspath -name .snapshot -prune -o \( -type f -mtime 0 -print0 \)
Copy the entire directory tree under t1 to t2, do not create a containing t1 directory in t2. </s> cp -R t1/ t2
Counts lines in each of *.php files in a current folder and subfolders and prints total count as well. </s> wc -l **/*.php
returns a list of  files create time is 1 minute ago under the root directory. </s> find / -newerct '1 minute ago' -print
Connect to port 2222 of example.com as ssh user "user", and copy local file "/absolute_path/source-folder/some-file" to remote directory "/absolute_path/destination-folder" </s> scp -P 2222 /absolute_path/source-folder/some-file user@example.com:/absolute_path/destination-folder
Find recursively the latest modified file in the current directory </s> find . -type f | xargs ls -ltr | tail -n 1
create directory es if it is not exist and create direcoty LC_MESSAGES </s> mkdir -p es/LC_MESSAGES
List all variables (names only) with names containing X. </s> env | awk -F= '{if($1 ~ /X/) print $1}'
find all files in the current folder which have been modified after /etc/passwd </s> find -newer /etc/passwd
find all the cpp files in the current folder and move them to another folder(plus takes the bulk output of the find command and gives it as input to the move command in exec) </s> find . -type f -iname '*.cpp' -exec mv -t ./test/ {} \+
display all the files in the current folder </s> find . -print
Split "mybigfile.txt" into files of at most 200000 lines each </s> split -l 200000 mybigfile.txt
Print a colon-separated list of all directories from the $root directory tree, except those matching pattern ".[a-z]*" </s> find "$root" -name ".[a-z]*" -prune -o -type d -printf '%p:'
Extract any line in "file1" or "file2" which does not appear in the other </s> comm -3 <(sort file1) <(sort file2)
find all the file that have not been modified in the last 3 days ( considers day starting not 24 hours ) </s> find ./ -daystart -mtime +3
Search for "YOURSTRING" in all files under current directory </s> grep YOURSTRING `find .`
Find files/directories that is under group 'root' or have no group and set their group to 'apache' </s> find /var/www -group root -o -nogroup -print0 | xargs -0 chown :apache
Recursively change owner and group of "/usr/local/rvm/gems/ruby-2.0.0-p481/" to the current user </s> sudo chown $(whoami):$(whoami) /usr/local/rvm/gems/ruby-2.0.0-p481/ -R
Remove all files last modified more than 10 days ago from the current directory tree </s> find . -mtime +10 | xargs rm
find all the backup files in the current folder and delete them </s> find . -type f -name “FILE-TO-FIND” -delete;
Removes 5 oldest files in the current folder. </s> ls -t *.log | tail -$tailCount | xargs rm -f
Creates temporary file in default folder and saves path to it in 'source' variable. </s> source=`mktemp`
Find UTF-8 files with BOM </s> find . -type f -print0 | xargs -0 awk '/^\xEF\xBB\xBF/ {print FILENAME} {nextfile}'
Prints a random number between 1 and 10 </s> grep -m1 -ao '[0-9]' /dev/urandom | sed s/0/10/ | head -n1
Find all regular files that were modified $FTIME days ago under current directory tree </s> find . -type f -mtime $FTIME
get second-to-last comma-separated field of each line in file.txt </s> cat file.txt | rev | cut -d ',' -f 2 | rev
change the permissions of all the directories in the current folder </s> find . -type d | xargs chmod 2775
Search the current directory tree for all regular files matching pattern "*.rb" </s> find . -name "*.rb" -type f
Recursively lists all *.py and *.html files in a current folder. </s> ls **/*.py **/*.html
find all files not ending in ".html" </s> find . -type f -not -name "*.html"
find all the directories in current folder and do not search in sub directories </s> find . -maxdepth 1 -type d -print0
Find all files/directories named 'text' under current directory </s> find -name "text"
Display permissions, user, group, and full path for each file in the current directory tree as a list </s> tree -p -u -g -f -i
Remove all but 5 last comma-separated fields from each line in 'data.csv' </s> cat data.csv | rev | cut -d, -f-5 | rev
Search for 'sometext' in all the files with '.txt' extension under current directory tree and also print the filenames </s> find . -name '*.txt' -exec grep 'sometext' '{}' \; -print
Print the sorted unique column of usernames of users who are currently logged in without the header </s> finger | tail -n +2 | awk '{ print $1 }' | sort | uniq
Prints list of folders containing '.git', searching recursively from a current folder. </s> find . -name '.git' | xargs -n 1 dirname
Set timestamp of old_file.dat to specified timestamp. </s> touch -t 200510071138 old_file.dat
Find all directories in the current directory tree with "music_files" in their names </s> find . -type d -iname \*music_files\*
recursively change owner of the directory testproject and all files into it to user ftpuser </s> chown ftpuser testproject/ -R
Returns 0 if user $1 belongs to group $2. </s> groups $1 | grep -q "\b$2\b"
Recursively counts non-blank lines in all files in a current folder, that match regex '\.php|\.as|\.sql|\.css|\.js', but skip folders './pma', './blog', './punbb', './js/3rdparty' and files like '*.svn'. </s> find . -path './pma' -prune -o -path './blog' -prune -o -path './punbb' -prune -o -path './js/3rdparty' -prune -o -print | egrep '\.php|\.as|\.sql|\.css|\.js' | grep -v '\.svn' | xargs cat | sed '/^\s*$/d' | wc -l
Search all files and   directories either of the directory /home/oracle and  /home/databse which  contain the "zip"  anywhere in the files or directory name . </s> find /home/oracle /home/database -name '*zip*'
Print the first line of each file under the home directory </s> find $HOME/. -name *.txt -exec head -n 1 -v {} \;
Decompresses each of "*bz2" files under the current folder, redirecting output to the standard out, and prints only fourth of comma-separated fields. </s> find . -name "*.bz2" -print0 | xargs -I{} -0 bzip2 -dc {} | cut -f, -d4
Set variable "b" to the first word of "a" converted to uppercase. </s> b=`echo "$a" | awk '{ print toupper($1) }'`
Print only unique lines of 'file_name' file </s> cat -n file_name | sort -uk2 | sort -nk1 | cut -f2-
Calculate md5 sum of file ${my_iso_file} and save it to variable 'md5' </s> md5="$(md5sum "${my_iso_file}")"
split the result of command "ping -c 25 google.com | tee " into pieces per 100000 bytes named as "/home/user/myLogFile.logNNN" </s> ping -c 25 google.com | tee >(split -d -b 100000 - /home/user/myLogFile.log)
Update the timestamp of 'filename', or create an empty file if it doesn't exist. </s> touch filename
Print the full real path of "/dev/disk/by-uuid/$1" followed by "is not mounted" </s> echo $(readlink -f /dev/disk/by-uuid/$1) is not mounted
Print and save the ping results of 25 requests to "google.com" in "/home/user/myLogFile.log" containing at most 100000 bytes </s> ping -c 25 google.com | tee >(split -d -b 100000 - /home/user/myLogFile.log)
display a long listing of all images with the name "articles" in the current folder ( print0 is used to preserve file names with new line in their name ) </s> find . -iname "Articles.jpg" -print0 | xargs -0 ls -l
Find all MP3 files in the home directory tree that were modified in the last 24 hours </s> find ~ -type f -mtime 0 -iname '*.mp3'
Changes group ownership of 'logdir' to 'loggroup'. </s> chgrp loggroup logdir
search for a word in all the files in the current directory </s> find . | xargs grep 'chrome'
Move all files that contain "Subject: \[SPAM\]" to "DIR" </s> grep -l 'Subject: \[SPAM\]' | xargs -I '{}' mv '{}' DIR
Print a list of all duplicate case insensitive filenames in the current directory tree </s> find . -type f | awk -F/ '{print $NF}' | sort -f | uniq -i -d
display all the files in the home folder except text files </s> find /home ! -name "*.txt"
Print current date as epoch seconds </s> date +%s
Find hard links to the same file lpi104-6/file1 in the directory tree lpi104-6 </s> find lpi104-6 -samefile lpi104-6/file1
Receive input and print it to terminal preceeding with line number </s> cat -n
search for the folder .dummy and remove it from the folder "Test folder" </s> find "Test Folder" -type d -name '.dummy' -delete
Show human-readable file type description of file "/mnt/c/BOOT.INI" </s> file /mnt/c/BOOT.INI
Move all *.mp4 files from directory /foo/bar and its subdirectories to /some/path </s> find /foo/bar -name '*.mp4' -print0 | xargs -0 mv -t /some/path {}
Report file system containing path to /some/dir disk usage in kilobytes. </s> df -k /some/dir
find files in the current directory with pattern` '*.[ch]' which are contain ‘thing’ string and print file names which can contain spaces </s> find . -name '*.[ch]' -print0 | xargs -r -0 grep -l thing
Recursively from current folder searches only files that names match ".*xxx" pattern, ignores binary files and prints file name before every string that contains "my Text to grep". </s> grep --include="*.xxx" -nRHI "my Text to grep" *
Find all files/directories under /home/baumerf/public_html/ that were modified less than 60 minutes ago excluding *.log files/directories </s> find /home/baumerf/public_html/ -mmin -60 -not -name \*.log
Move all files and directories not starting with "l" in "/mnt/usbdisk" to "/home/user/stuff/." </s> mv /mnt/usbdisk/[^l]* /home/user/stuff/.
Left justify number each non-blank line in "log.txt" as input to "sed ..." </s> nl -n ln log.txt | sed ...
search the word NEEDLE and substitute it with REPLACEMENT in all the php files of the current folder </s> find ./ -type f -exec sed -i '' 's#NEEDLE#REPLACEMENT#' *.php {} \;
Check md5sum of directory /path against the checksum saved in file 'file' </s> du -csxb /path | md5sum -c file
Change to the directory pointed by variable TAG </s> cd "$TAG"
find all the html files which are modified in the last 7 days </s> find . -mtime -7 -name "*.html"
Find *.avi and *.flv files in /path/to/your/directory and below and copy them to /path/to/specific/folder </s> find /path/to/your/directory -regex '.*\.\(avi\|flv\)' -exec cp {} /path/to/specific/folder \;
Check if the $somedir directory is empty </s> find "$somedir" -maxdepth 0 -empty -exec echo {} is empty. \;
Delete all .svn files/directories under current directory </s> find . -name .svn -delete
Find files named core in or below the directory /tmp and delete them, processing filenames in such a way that file or directory names containing single or double quotes, spaces or newlines are correctly handled. </s> find /tmp -name core -type f -print0 | xargs -0 /bin/rm -f
Print the second line of output of "ls -l" </s> ls -l | tail -n +2 | head -n1
Prints yesterday's date information </s> date --date yesterday "+%a %d/%m/%Y"
Create a ssh tunnel on local port 2222 through "bridge.example.com" to "remote.example.com" port 22 without executing any commands and run in the background </s> ssh -N -L 2222:remote.example.com:22 bridge.example.com&
Find all files starting from the current directory which are larger than 100MB </s> find . -size +100M
Print yesterday's date as yyy:mm:dd </s> date +%Y:%m:%d -d "1 day ago"
Find all SGID set files under current directory and show a few lines of output from the beginning </s> find . -perm /g+s | head
List all files under the current working directory last modified less than a day ago </s> find `pwd` -mtime -1 -type f -print
List files greater than 1024KB under /path/to/directory and print the time and size on stdout </s> find /path/to/directory -type f -size +1024k -exec ls -lh {} \; | awk '{ print $8 ": " $5 }'
Decompress and extract 'archive.tar.gz' into '/destination' </s> gzip -dc archive.tar.gz | tar -xf - -C /destination
find all files in the file system whose size is bigger than 3GB </s> find / -size +3G
Search /usr/local recursively for directories whose names end with a number 0-9 </s> find /usr/local -type d -name '*[0-9]'
Find all the files in the current directory recursively whose permissions are 777 </s> find . -type f -perm 0777 -print
Display a dump of standard input as floating point values of double size </s> od -t fD
display all the empty files in the current folder( files of size 0 bytes) </s> find . -empty
Prints current directory name </s> pwd | awk -F/ '{print $NF}'
Find files with 002 permission under /tmp and print them with the string 'Found world write permissions:' printed as the first line of output </s> find /tmp -type f -perm -002 | sed '1s/^/Found world write permissions:\n/'
List files in the current directory </s> find . \( ! -name . -prune \)
Execute md5sum command on files found by the find command </s> find -iname "MyCProgram.c" -exec md5sum {} \;
Find all files/directories under current directory tree excluding files/directories with name 'query_to_avoid' </s> find \! -name "query_to_avoid"
Creates temporary folder like '/tmp/tardir-XXXXXX' with 6-letter suffix and saves its path in 'tmpdir' variable. </s> tmpdir=$(mktemp -d /tmp/tardir-XXXXXX)
Find all files changed on the 29th of September, 2008, starting from the current directory </s> find . -type f -newerct 2008-09-29 ! -newerct 2008-09-30
Print each unique entry in "ip_addresses" followed by a count </s> cat ip_addresses | sort | uniq -c | sort -nr | awk '{print $2 " " $1}'
Find files and directories with group id 1003 </s> find . -gid 1003
Delete all files under user's home directory tree that were accessed more than 365 days after their status was changed </s> find ~ -used +365 -ok rm '{}' ';'
Recursively copies everything from '/source/path/*' to the '/destination/path/', preserving from overwriting existing files, and printing info message on each operation. </s> cp -Rvn /source/path/* /destination/path/
Find regular files modified within the last ten minutes under /etc </s> find /etc -type f -mmin -10
Recursively removes all empty folders under current path, printing info message on each operation, and suppressing error messages if folder is not empty. </s> find -type d -empty -exec rmdir -vp --ignore-fail-on-non-empty {} +
Find all files under current directory and print only the filenames (not paths) </s> find . -type f -execdir echo '{}' ';'
Find all regular files under current directory tree that were accessed $FTIME days ago </s> find . -type f -atime $FTIME
Save the day of the year from the time string "20131220" to variable 'DATECOMING' </s> DATECOMING=$(echo `date -d "20131220" +%j`)
display all normal/regular files in a folder </s> find teste1 -type f
Find the passwd file in the current directory and one level down </s> find -maxdepth 2 -name passwd
Find all files under current directory that were modified more than 1 day ago </s> find -mtime +1
Creates temporary folder, and saves current folder path   joined with created temporary folder path in 'tdir' variable. </s> tdir="$(pwd)/$(mktemp -d)"
find all the files in the file system which belong to the groep "users" and with the name "dateiname" </s> find / -group users -iname "Dateiname"
Archive any files changed in the last day from "remote_host" to "local_dir" </s> rsync -av remote_host:'$(find logs -type f -ctime -1)' local_dir
display the contents of all the files in the current folder which start with test ( case insensitive search ) </s> find . -iname '*test*' -exec cat {} \;
prints last part of a logfile since timestamp 423 </s> tac file.log | awk '{ if ($1 >= 423) print; else exit; }' | tac
Find all *.txt files/directories under current directory </s> find -name \*.txt
Remove junk files modified more than 31 days ago recursively </s> find /path/to/junk/files -type f -mtime +31 -print0 | xargs -0 -r rm -f
find all the files in the file system which have been changed 1 minute ago. </s> find / -newerct '1	minute ago' -print
test if the 2nd column in file A is in the reverse order of the second column of file B </s> diff --brief <(awk '{print $2}' A) <(tac B | awk '{print $2}')
Find all 0644 permission files/directories under current directory tree and show only the first 10 of them </s> find . -perm 0644 | head
prints the names of all files in the directory tree rooted in /usr/src whose name ends with ‘.c’ and that are larger than 100 Kilobytes. </s> find /usr/src -name '*.c' -size +100k -print
Search for the string 'magic' in all regular files under current directory tree and display long listing of them </s> find . -type f -exec grep "magic" {} \; -ls
Find all *.tex files/directories in maximum 2 levels down the current directory </s> find . -maxdepth 2 -name '*.tex'
Print lines in file 'file' that do not match any word specified in file 'blacklist' (one word per line) </s> grep -w -v -f blacklist file
display all files in a folder </s> find "/proc/$pid/fd"
Find all files/directories in entire file system that are owned by "shadow" group </s> find / -group shadow
Reversibly sorts content of the '${TMP}/${SCRIPT_NAME}.name' file </s> cat ${TMP}/${SCRIPT_NAME}.name|sort -r;
Print multiline text "ONBOOT=\"YES\"\nIPADDR=10.42.84.168\nPREFIX=24" to the terminal, replacing '\n' with newline symbol, and append that text to file /etc/sysconfig/network-scripts/ifcfg-eth4 as root user. </s> echo -e "ONBOOT=\"YES\"\nIPADDR=10.42.84.168\nPREFIX=24" | sudo tee -a /etc/sysconfig/network-scripts/ifcfg-eth4
find all the css files </s> find -name '*.css'
Finds all folders that contain 'ssh' file and have 'bin' in path. </s> find / -name ssh|grep bin|xargs dirname
Find all files which belong to user lal and change their ownership to ravi </s> find / -user lal -exec chown ravi {} \;
SSH with parameters specified in "$@" using key file "~/.ssh/gitkey_rsa" </s> ssh -i ~/.ssh/gitkey_rsa "$@"
find all the files in the folder /path/to/dir which have been modified after a specific date (Feb 07) </s> find /path/to/dir -newermt “Feb 07”
Find all files owned by user vivek </s> find / -user vivek
Copies '[MacVim_source_folder]/src/MacVim/mvim' to the  '/usr/local/bin', printing info message on each operation. </s> cp -v [MacVim_source_folder]/src/MacVim/mvim /usr/local/bin
Takes first text field from file 'file.txt' as a domain name and gets short A record for this one. </s> awk '{print $1}' file.txt | xargs dig +short
Find all executable files under the current directory and below </s> find . -perm /a=x
Find all empty directories in minimum 2 levels down the root directory </s> find root -mindepth 2 -type d -empty
Display file type description of 'file-name' based on contents. </s> file file-name
Find all files under current directory with 755 permission and change their permission to 644 </s> find . -type f -perm 755 -exec chmod 644 {} \;
List all files and directories from the current directory tree </s> find . -print | xargs ls
display all files in the current folder which do not belong to the user john </s> find . ! -user john
display all the log files in the folder /var/log, print0 is used to handle files with only spaces in their names or which have newlines in their names </s> find /var/log -name "*.log" -print0
Find string "STRING" in files residing in the current directory tree, case insensitive </s> find . -type f -print | xargs grep -ni "STRING"
Find all *.dbf files/directories in entire file system and print their sorted and unique parent directory paths </s> find / -name \*.dbf -print0 | xargs -0 -n1 dirname | sort | uniq
Look for files with wide open permissions </s> find . -type f  -perm 777 -exec ls -l {} \;
Rename "old" to "tmp" </s> mv old tmp
Find every directory under "0001" and make new directories replacing "0001" with "0002" at the beginning of their names. </s> find 0001 -type d | sed 's/^0001/0002/g' | xargs mkdir
Count the number of times that a single "-----------\n" separated record contains both "A=2" and "dummy=2" in compressed file "file.gz" </s> zcat file.gz | awk -v RS="-----------\n" '/A=2[ ,\n]/ && /dummy=2[ ,\n]/{count++} END{print "Final counter value=",count}'
search for all regular/normal files in current folder and display all the files which contain 16 lines </s> find . -type f -print0 | xargs -0 grep -cH '.' | grep ':16$'
Find all *.php files under current directory and change their permission to 640 </s> chmod 640 $(find . -name *.php)
Find users whose names begin with "ab" and ends with "1" </s> who | cut -d ' ' -f 1 | grep -e '^ab' -e '1$'
Find regular files under and below /path that match pattern "???-???_[a-zA-Z]*_[0-9]*_*.???" </s> find /path -type f -name "???-???_[a-zA-Z]*_[0-9]*_*.???"
find files which full path name is /tmp/foo/bar under /tmp/foo directory and print </s> find /tmp/foo -path /tmp/foo/bar -print
Saves calendar of $month, $year in the 'cal' variable. </s> cal=$(echo $(cal "$month" "$year"))
Find files/directories under current directory and force xargs to print them one by one </s> find . | xargs -n 1 echo
Remove a leading "machine" from the system host name and save the result to variable "machnum" </s> machnum=$(hostname | sed 's/^machine//')
Find *.java files under current directory and compress them to myfile.tar  (unsafe) </s> find . -type f -name "*.java" | xargs    tar cvf myfile.tar
Copy all regular files whose names end in "~" from the /path directory tree to ~/backups/ </s> find /path -type f -name '*~' -print0 | xargs -0 -I % cp -a % ~/backups
Return a list of files newer than file poop </s> find . -mnewer poop
Search for files which are writable by somebody </s> find . -perm /222
Search for the regex 'pattern_to_search' in all files under '/directory/containing/files' and show the matched lines as well as the file names </s> find /directory/containing/files -type f -exec grep -H 'pattern_to_search' {} +
display a list of all java or jsp files in the current folders </s> find . \( -name '*jsp' -o -name '*java' \) -type f -ls
Search for regular expression 'expr' in all .c and .h files from the current directory tree </s> find -name '*.[ch]' | xargs grep -E 'expr'
Remove the first 13 characters of each ".txt" filename in the "/tmp" directory tree and number the output </s> find /tmp -type f \( -name '*.txt' \) |cut -c14- | nl
list files that the user does not have permissions to read, do not try to descend into directories that cannot be read. </s> find . ! -readable -prune
Shows size of compressed file in .bz2 archive. </s> bunzip2 -c bigFile.bz2 | wc -c
find all the files that have been modified exactly 2 days ago </s> find -mtime 2
find all files in the current folder whose size is less than 50KB </s> find . -size -50k
Find user daniel's files of type jpeg </s> find . -user daniel -type f -name *.jpg
Find all files under current directory </s> find . -type f -print
find all the symbolic links in the current folder that are broken </s> find . -xtype l
List all non-hidden files in ~/junk </s> find ~/junk   -name "*" -exec ls -l {} \;
Search the current directory recursively for files last modified within the past 24 hours ignoring paths ./es* and ./en* </s> find . -mtime 0 | grep -v '^\./en' | grep -v '^\./es'
List all files/directories with spaces in their names under ~/Library directory </s> find ~/Library -name '* *' -exec ls {} \;
search for al cpp files in current folder and display distinct parent directory of these files in sorted order </s> find . -name "*.cpp" -exec dirname {} + | sort -u
Find all files/directories that contain the string literal '`$VERSION`' in their names under current directory tree </s> find . -name '*`$VERSION`*'
search for a word in all the regular/normal files in the current folder and display the filename along with the matched text </s> find . -type f -exec grep -l linux {} \;
Find all the files in entire file system  which are modified 50 days back. </s> find / -mtime 50
Find all files/directories not with the name 'query_to_avoid' under current directory </s> find \! -name "query_to_avoid"
Create 6-letter named temporary directory in a folder path that is provided as the first positional parameter, and save the path to it in a variable 'tmp' </s> tmp=$(mktemp -d $(dirname "$1")/XXXXXX)
Find all the regular files under $DIR directory tree which have been modified before the file $a excluding the file $a and delete them </s> find "$DIR" -type f \! -newer "$a" \! -samefile "$a" -delete
Find files ending in "f" </s> find .  -path '*f'
display all the configuration files in the current folder which are in the current tree structure </s> find .  -path '*/*config'
Find all files/directories named file in 2 and 3 levels down the current directory </s> find -mindepth 2 -maxdepth 3 -name file
Print revesed second from the end dot-bounded field in $i value </s> j=`echo $i | rev | cut -d "." -f2`;
Print input "your, text, here" formatted to fit 70 characters per line breaking at spaces </s> echo 'your, text, here' | fold -sw 70
Delete the files under the current working directory with inode numbers specified on standard input </s> xargs -n 1 -I '{}' find "$(pwd)" -type f -inum '{}' -delete
Show the epoch in default date/time format </s> date -ud@0
Search the current directory recursively for regular files last modified more than 2 days ago </s> find . type -f -mtime +2
Find all socket files in the current directory and its sub-directories. </s> find . -type s
Set variable "MAVEN_DEBUG_OPTS" to "-Xdebug -Xnoagent -Djava.compiler=NONE -Xrunjdwp:transport=dt_socket,server=y,suspend=y,address=8000" on Windows machines </s> set MAVEN_DEBUG_OPTS=-Xdebug -Xnoagent -Djava.compiler=NONE -Xrunjdwp:transport=dt_socket,server=y,suspend=y,address=8000
display all text files in current folder </s> find . -name "*.txt"
Find all files modified on the 7th of June, 2007, starting from the current directory </s> find . -type f -newermt 2007-06-07 ! -newermt 2007-06-08
Execute "date" every second </s> watch -n 1 date
Wrap standard input to fit in 10 characters per line </s> fold -w 10
Recursively finds all bzip2 compressed files in a current folder and decompresses them. </s> find ./ -iname "*.bz2" -exec bzip2 -d {} \;
Search for directories that contain the phrase "foo" but do not end in ".bar" </s> find . -name '*foo*' ! -name '*.bar' -type d -print
Delete all __temp__* files/directories under current directory tree </s> find . -depth -name '__temp__*' -exec rm -rf '{}' \;
Delete all filename* files under /dir directory </s> find /dir -name "filename*" -type f -exec rm {} \;
Monitor 3 specific process IDs: 18884, 18892, and 18919 (GNU specific) </s> top -p 18884 -p 18892 -p 18919
find all files in current folder which are bigger than 1 MB and move them to another folder </s> find . -size +1M -exec mv {} files \+
Make directories "tmp/real_dir1" and "tmp/real_dir2" as needed </s> mkdir -p tmp/real_dir1 tmp/real_dir2
Print the current date in '%H:%M:%S' format followed by the string ': done waiting. both jobs terminated on their own or via timeout; resuming script' </s> echo "$(date +%H:%M:%S): done waiting. both jobs terminated on their own or via timeout; resuming script"
Find all *.foo files under current directory and print their contents </s> cat $(find . -name '*.foo')
Go into the first directory whose name contains 1670 </s> cd `ls -d */ | grep 1670`
find all the files in the current folder with the name "test-a" and move them to the folder test-10 </s> find ~ -type f -name test-a -exec mv {} test-10 \;
Split "file" into 10 files of about equal size without splitting lines </s> split -n l/10 file
Find all regular files under current directory tree and replace all '1.2.3.4' with '5.6.7.8' in these files modiying the files in-place </s> find . -type f -exec sed -i "s/1\.2\.3\.4/5.6.7.8/g" {} \
display all the files in current folder which start with "file2015-0" </s> find . -name "file2015-0*"
display the sum of disk used by all the access.log files in /var/www folder </s> find /var/www/ -type f -name «access.log*» -exec du -k {} \;|awk '{s+=$1}END{print s}'
Search case insensitively for 'foo' in all the files with '.java' extension under current directory tree and show only the file names </s> find . -type f -name "*.java" -exec grep -il 'foo' {} \;
Remove all files with a txt extension under current directory </s> find . -type f -name "*.txt" -exec rm {} \; -print
Display differences between /tmp/test1 and /tmp/test2. </s> diff /tmp/test1  /tmp/test2
Print common lines in files "set1" and "set2" </s> comm -12 <(sort set1) <(sort set2)
create a zip of all the files in the current folder which are bigger than 100Kb and do not go more than 2 levels during search </s> find . -maxdepth 2 -size +100000 -exec bzip2 {} \;
display all the .sh scripts and perl files in the current folder </s> find . -type f \( -name "*.[sS][hH]" -o -name "*.[pP][lL]" \)
Display differences between directories repos1 and repos2, ignoring changes due to tab expansion, white spaces and treating absent files as empty. </s> diff -ENwbur repos1/ repos2/
find all jpg files in the folder which are in the path "/201111/" and sort them based on name </s> find */201111/* -name "*.jpg" | sort -t '_' -nk2
move all the files in the current folder  to temp folder and search atleast in one subfolder </s> find . -mindepth 1 -exec mv -t /tmp {} +
Print the file content of command "f" </s> cat "$(which f)"
Sets 'extglob' shell option. </s> shopt -s extglob
List all files that have not been read in thirty days or more </s> find . -type f -atime +30 -print
Find all files/directories under current directory tree whose paths start with './sr' and end with 'sc' </s> find . -path './sr*sc'
Find all 15MB files in entire file system </s> find / -size 15M
Find files in the current directory and below that are less than 500 kB in size </s> find . -size -500k -print
Calculate the md5 sum of the tar archive of "dir" </s> tar c dir | md5sum
Search the .java files from the /Applications/ directory tree for TODO lines </s> find /Applications/ -name "*.java" -exec grep -i TODO {} +
Change permissions to 700 for files and directories deeper than the current directory </s> find . -mindepth 2 | xargs chmod 700
Print each logged in user's full name </s> finger | awk 'NR>1{print $2,$3}'
Split "date.csv" into files with at most 100 lines each </s> split -l 100 date.csv
display a long listing of all the directories in the current folder </s> find . -type d -exec ls -algd {} \;
search all jpg,png,jpefg  files in the current folder and calculate the total size of them </s> find . \( -iname "*.jpg" -o -iname "*.jpeg" -o -iname "*.png" \) -ls | awk '{total += $7} END {print total}'
find all the png files in current folder which are present in the pattern list file "search.txt" </s> find . -name '*.png' | grep -f <(sed s?^?/[0-9]_[0-9]_[0-9]_? search.txt)
Split "data.tsv" into files of at most 100 MiB preserving lines and use a prefix of "data.tsv." and numeric suffixes </s> split -C 100m -d data.tsv data.tsv.
Time stamp every ping request to 8.8.8.8 in Unix epoch format </s> ping -D -n -O -i1 -W1 8.8.8.8
Find things changed today </s> find /path/to/search -daystart -ctime -1
Prints calendar for a current month without first day of a week. </s> cal | sed -e 's/^.\{3\}//' -e 's/^\(.\{15\}\).\{3\}$/\1/'
Measure the disk space taken up by all *.txt files in the current directory tree </s> find . -name "*.txt" -print0 |xargs -0 du -ch | tail -n1
Find all files/directories under '/usr' directory tree that have been modified exactly 5 minutes ago </s> find /usr -mmin 5
Find directories that are directly under /home/user/workspace directory (no-subdirectories) and were modified more than 30 days ago and print a message saying that the directory wasn't modified during last 30 days </s> find /home/user/workspace -mindepth 1 -maxdepth 1 -type d -mtime +30 -execdir echo "It seems that {} wasn't modified during last 30 days" ';'
Search for "search term" in a sorted list of all files under current directory </s> find . | awk '{FS = "/" ; print "", NF, $F}' | sort -n  | awk '{print $2}' | xargs grep -d skip "search term"
Find all hidden (regular) files under /tmp </s> find /tmp -type f -name ".*"
display all the normal/regular files in the current folder which are empty </s> find . -type f -empty
Print name of the file system containing $path. </s> df -h $path | cut -f 1 -d " " | tail -1
Delete all hidden files under $some_directory </s> find "$some_directory" -type f -name '.*' -exec rm '{}' \;
Search the .java files from the /Applications/ directory tree for TODO lines </s> find /Applications/ -name "*.java" -exec grep -i TODO {} \;
Remove files in the current directory tree modified more than 31 days ago recursively </s> find . -type f -mtime +31 -print0 | xargs -0 -r rm -f
display the name of all directories in the current folder and do not search in sub directories ( mindepth ensures that the current folder name is removed from the output) </s> find . -type d -maxdepth 1 -mindepth 1 -exec basename {} \;
Print all non-hidden files in the current directory and its subdirectories </s> find . -not -path '*/\.*'
find all the files in the current directory which have been accessed in the last 1 day and move them to TMP folder. </s> find . -atime +1 -type f -exec mv {} TMP \;
Find all files in your home directory and below that are smaller than 100M. </s> find ~ -size -100M
Delete all the .c files present in the current directory and below </s> find . -name "*.c" | xargs rm -f
display all the files in the current folder which have been modified after the files "/bin/sh" </s> find . -newer /bin/sh
search for all the ".c" files in the folder "/home/david" which have been modified in the last 10 minutes </s> find /home/david -mmin -10 -name '*.c'
Find files in the current directory tree whose permissions are 775 </s> find .  -perm 775
Read a single character from standard input into variable "key" without backslash escapes and using the prompt "Press any key to continue..." </s> read -n1 -r -p "Press any key to continue..." key
find all the files in the entire file system which have been modified in the last 48 hours </s> find / -mtime -2 -print
Find all empty files under a certain path </s> find /tmp -type f -empty
Find all files in maximum 1 level down the current directory that were modified less than 1 day ago </s> find -maxdepth 1 -type f -mtime -1
find all files in the entire file system whose size is more than 100MB </s> find / -size +100M
Find all the Sticky Bit set files whose permission are 551 </s> find / -perm 1551
Print sorted list of strings from 'ip_addresses' file, with number of occurrences of each string. </s> sort ip_addresses | uniq -c
find all the files that have the word "fstab" in their name in a folder </s> find /etc -name *fstab*
Search the current user's home directory and its sub-directories for any file that ends in .tar-gz and was modified after filename was last modified. </s> find ~/ -name *.tar.gz -newer filename
Find all files and directories in the current directory recursively that contain spaces in their names </s> find . -name '* *'
Find files/directories named 'aaa.txt' under current directory tree </s> find . -name aaa.txt
Change permissions of all files ending ".php" under the current directory to 755 and print a count of modified files </s> find . -name "*.php" -exec chmod 755 {} + -printf '.' | wc -c
Display the differences between "file1.cf" and "file2.cf" side-by-side with a width of 150 characters </s> diff -y -W 150 file1.cf file2.cf
Find all files that have additional permissions </s> find / -perm -644
Find all .txt files of user Tecmint under /home directory </s> find /home -user tecmint -iname "*.txt"
Go to directory /cygdrive/c/Program Files (x86)/$dollarsign using single quotes to escape special characters, including dollar signs </s> cd '/cygdrive/c/Program Files (x86)/$dollarsign'
Find files/directories under current directory matching the posix-egrep type regex ".+\.(c|cpp|h)$" in their names </s> find . -regextype posix-egrep -regex ".+\.(c|cpp|h)$"
Print all files and directories in the `.' directory tree skipping SCCS directories but printing out the SCCS directory name </s> find . -print -name SCCS -prune
Set variable "extract_dir" to list of top-level directories and files contained in tar archive specified by variable FILE. </s> extract_dir=$(tar -tf $FILE | cut -d/ -f1 | uniq)
Find files named 'fileName.txt' under '/path/to/folder' directory tree ignoring 'ignored_directory' </s> find /path/to/folder -name fileName.txt -not -path "*/ignored_directory/*"
Change directory to the directory containing the "oracle" executable </s> cd "$(dirname $(which oracle))"
Invoke a trusted X11 forwarding SSH connection with the server $ssh_server as user $ssh_user </s> ssh -Y $ssh_user@$ssh_server
Find all 400 permission files under /data directory and change their permission to 755 </s> find /data -type f -perm 400 -print | xargs chmod 755
find all files  that names are 'apt' </s> find  / -name "apt"
Findx all files having text "texthere" recursively in a current folder, and prints only file names with matching strings. </s> find -type f -exec grep -l "texthere" {} +
Find all directories in the /path/to/base/dir tree </s> find /path/to/base/dir -type d
find all the files in the folder /opt which have been accessed exactly 20 days ago </s> find /opt -atime 20
Set permissions of all directories under "/opt/lampp/htdocs" to 755 </s> find /opt/lampp/htdocs -type d -exec chmod 755 {} \;
search in the current directory for any file named Chapter1.txt </s> find . -name Chapter1 -type f
Close the master SSH control socket "my-ctrl-socket" to "jm@sampledomain.com" </s> ssh -S my-ctrl-socket -O exit jm@sampledomain.com
find all directories in the current directory which have the name foo and do not have the extension "bar" </s> find . -name '*foo*' ! -name '*.bar' -type d -print
Connect to port 1234 of specified IP address or hostname as ssh user "user", and copy all visible files in /var/www/mywebsite/dumps/ on this host to local directory /myNewPathOnCurrentLocalMachine - this directory must already exist on local host. </s> scp -P 1234 user@[ip address or host name]:/var/www/mywebsite/dumps/* /var/www/myNewPathOnCurrentLocalMachine
Find all directories under /home/me </s> find /home/me -type d
Save IP addresses of the host name in variable "ip" </s> ip=$(hostname -I | awk '{print $1}')
count all the html files having a specifc word in a folder. </s> find /usr/src -name "*.html" -exec grep -l foo '{}' ';' | wc -l
display the long listing detials of all the files in the folder junk which is in home folder. </s> find ~/junk   -name "*" -exec ls -l {} \;
Forward port 16186 on hello.com to 8888 on localhost using private key "privatekeystuffdis88s8dsf8h8hsd8fh8d" for login </s> ssh -N -i <(echo "privatekeystuffdis88s8dsf8h8hsd8fh8d") -R 16186:localhost:8888 hello.com
Set up SSH connection forwarding in the background with no terminal or command execution from localhost port 8888 to "proxyhost" port 8888 and a reverse connection from "officefirewall" port 22222 to "localhost" port 22 </s> ssh -fNT -L8888:proxyhost:8888 -R22222:localhost:22 officefirewall
search for a word in all the php files in the current folder and display the count of all matching lines. </s> find . -name \*.php -type f -exec grep -Hn '$test' {} \; | wc -l
search for the files with the name "temp" and which have not been accessed in the last 7*24 hours in the /usr folder </s> find /usr -name temp -atime +7 -print
Execute /usr/bin/find with $* arguments where current directory is the first argument </s> /usr/bin/find ./ $*
Find all *.c files under /home </s> find /home -name "*.c"
display a list of all the files in the file system which do not belong to any user and search only in jfs and jfs2 file systems </s> find / -nouser \( -fstype jfs -o -fstype jfs2 \) -ls
List the last modified file under "$DIR" </s> find $DIR -type f -printf "%T@ %p\n" | sort -n | cut -d' ' -f 2 | tail -n 1
Generates temporary file name with full path by template 'fifo.XXXXXX' and saves it to variable 'fifo_name' </s> fifo_name=$(mktemp -u -t fifo.XXXXXX)
Search the current directory recursively for regular files last changed less than 2 days ago </s> find . type -f -ctime -2
Execute zcat on every file matching "*20120805.gz" in the current directory and subdirectories </s> find . -name *20120805.gz -exec zcat {} \;
Find all hard links to file /path/to/file that exist under the current directory tree </s> find . -samefile /path/to/file
change owner and group of the file uid_demo to user and group root </s> sudo chown root:root uid_demo
Test if a file named 'file' in the current directory is more than 1 hour old </s> find file -prune -cmin +60 -print | grep -q .
change the group of all the files in the file system which belong to the group with the gid 999 </s> find / -group 999 -exec chgrp NEWGROUP {} \;
Find all *shp* directories under current directory and move '*' (literal) file/directory inside those directories to shp_all </s> find . -name '*shp*'   -execdir mv '{}/*' shp_all ';'
search for all regular/normal files in the current folder and display the number of lines in the file </s> find . -type f -print | xargs -L1 wc -l
Find all directories under current directory and change their permission to 700 </s> find . -type d -exec chmod 700 {} \;
Removes all empty folders under '/path/to/the/folder' path. </s> find /path/to/the/folder -depth -type d -print0 | xargs -0 rmdir
list directories owned by group ID 100 in the file system </s> find / -type d -gid  100
Search directory trees /usr/local/man and /opt/local/man for files whose names begin with 'my' </s> find /usr/local/man /opt/local/man -name 'my*'
Find `string' in all *.java files ignoring the case of that string </s> find . -type f -name "*.java" -exec grep -il string {} \;
Recursively finds all '*.pdf' files in a current folder and removes them. </s> find . -name "*.pdf" -print0 | xargs -0 rm
find all readme files in a folder </s> find /usr/share/doc -name README
Remove all files in the current directory tree that have the name "abc.xxx" </s> find . -name abc.xxx -exec rm {} \;
Print IP addresses of the host name </s> hostname -I | awk '{print $1}'
display all the files in the entire file system which are bigger than 10MB </s> find / -size +10000k
Gets MAC address of eth0 network interface. </s> ifconfig eth0 | awk '/HWaddr/ {print $5}'
For each line in 'file', print "result = " followed by the line backwards. </s> rev file | awk '{print "result =",$0}'
Concatenate all files under the current directory and below that contain "test" in their names </s> find . -iname '*test*' -exec cat {} \;
Find links to file path/to/foo.txt </s> find -L / -samefile path/to/foo.txt
Display the contents of "myfile" located in the current directory. </s> cat myfile
remove all "Foo*" files under current dir </s> find . -type f -name "Foo*" -exec rm {} \;
Copy the current directory tree to '/path/to/destination/dir' preserving permissions, timestamp and ownership </s> find . | cpio -pdumv /path/to/destination/dir
List environment variables and their values, escaping all semicolons with a backslash. </s> env | sed 's/;/\\;/g'
change owner of the files into directory "/mydir" with ".txt" extension to user root </s> find /mydir -type f -name "*.txt" -execdir chown root {} ';'
Removes files 'junk1', 'junk2', 'junk3'. </s> rm junk1 junk2 junk3
Move all files including hidden files and excluding ".." in "/path/subfolder/" to "/path/" </s> mv /source/path/{.[!.],}* /destination/path
Search the /path directory tree for files missing g+w and o+w bits </s> find /path ! -perm /022
Gets IP address of first listed network interface in system. </s> ifconfig | grep 'inet addr:' | grep -v 127.0.0.1 | head -n1 | cut -f2 -d: | cut -f1 -d ' '
find all the directories in the current folder which begin with the words "kt" and end with a digit </s> find . -regex './kt[0-9] '
Serach for all the files containing grep in man pages </s> find /usr/share/man/ -regex .*grep*
Search the specified user for the given "filename" </s> find / -user pat -iname "filename"
Move all 10*jpg files under /path to 2010*jpg files under the same directory </s> find /path -type f -name "10*jpg" | sed 's/.*/mv &/' | sed 's/mv \(.*\/\)\(.[^/]*\)/& \120\2/' | sh
Calculate the md5 sum of the contents of "$FILES" </s> cat $FILES | md5sum
List all files in the current directory tree that were last modified on the 3rd of March, 2010 or later </s> find -newermt "mar 03, 2010" -ls
kill all background processes </s> kill -INT $(jobs -p)
Stores date of last month day in the 'lastdaymonth' variable. </s> set lastdaymonth=`cal $month $year  |tr -s " " "\n"|tail -1`
Find all *.html files under current directory </s> find . -type f -name '*.html'
Removes files ~/.android/adbkey and ~/.android/adbkey.pub without prompting. </s> rm -f ~/.android/adbkey ~/.android/adbkey.pub
On host "server_b", connect as ssh user "user" and copy "/my_folder/my_file.xml" to directory "/my_new_folder/", with all transfer data relayed through local host. </s> scp -3 user@server_b:/my_folder/my_file.xml user@server_b:/my_new_folder/
Find all directories under current directory and change their permission to 644 </s> find -type d -print0|xargs -0 chmod 644
Recursively change the owner to "$USER" and group to "$GROUP" of "/var/lib/cassandra" </s> sudo chown -R  $USER:$GROUP /var/lib/cassandra
Delete all the files found in the current directory tree whose names begin with "heapdump" </s> find . -name heapdump*|xargs rm
sort based on size and display top ten largest normal/regular files in the current folder </s> find . -type f -exec ls -s {} \; | sort -n -r | head -10
Lists content of the current folder. </s> $ ls
List the unique tab delimited field number "$FIELD" in all files, prefix with the number of occurrences, sort from most frequent to least frequent </s> cut -f $FIELD * | sort| uniq -c |sort -nr
delete all the files in the file system which belong to the user edwarda </s> find / -user edwarda -exec rm "{}" \;
Append all regular files modified in the last 24 hours to the "$archive.tar" tar archive </s> find . -mtime -1 -type f -exec tar rvf "$archive.tar" '{}' \;
find all the files in the current folder and display adding quotations to each file </s> find . -exec echo -n '"{}" ' \;
search for the directory starting with "ora10" in the entire file system </s> find / -type d -name "ora10*"
Creates temporary file with name formatted like 'emacs-manager.XXXXXX' in '/tmp/' folder and saves path to it in 'tmp_file' variable. </s> tmp_file=`mktemp --tmpdir=/tmp emacs-manager.XXXXXX`
Update timestamps of all files (not directories) under current directory. </s> find . -exec touch {} \;
Find all directories under foldername directory and set their permission to 755 </s> sudo find foldername -type d -exec chmod 755 {} ";"
Search the current directory tree for symlinks whose contents match pattern "*sysdep.c" </s> find . -lname '*sysdep.c'
Find *.css files in the current directory tree, skipping all directories that match pattern '*/lang/en.css' </s> find . -path '*/lang/en.css' -prune -o -name '*.css' -print
Write contents of "/sys/kernel/debug/tracing/trace_pipe" to standard output and to "tracelog.txt" executing as a root user </s> sudo cat /sys/kernel/debug/tracing/trace_pipe | tee tracelog.txt
Mount "nifs" filesystem "/dev/mapper/myldm" on "/mnt" as read only </s> mount -t ntfs -o ro /dev/mapper/myldm /mnt
Finds IP addresses of all network interfaces. </s> ifconfig | sed -n 's/.*inet addr:\([0-9.]\+\)\s.*/\1/p'
Returns exit status 0 and prints exit status of previous command. </s> false | echo "${PIPESTATUS[0]}"
Print info about all mounted file systems, and grand total statistic about available and used space </s> df --total
Check if current system is running in 64-bit addressing. </s> uname -m | grep '64'
Do a dry run of renaming file extension '.andnav' to '.tile' for all files/directories under current directory tree </s> find . -name "*.andnav" | rename -vn "s/\.andnav$/.tile/"
find all the files in the current directory that have the word "lib" in them </s> find . -wholename '/lib*'
Finds all folders that contain 'ssh' file and have 'bin' in path. </s> dirname `find / -name ssh | grep bin`
Print the files in the current directory as a list of semicolon separated values </s> ls -1b | tr '\n' ';'
Find all files under /myfiles with 647 permission </s> find /myfiles -type f -perm -647
find all files & dircetiry in current directory which  have .tmp extension and delete them . </s> find . -type f -name "*.tmp"  -exec rm -rf {} \;
Find disk used space of only the target directory </s> du --max-depth=0 ./directory
Change directory to the parent of the real path of the current script </s> cd $(dirname $(readlink -f $0))
display all the files ending with .c in the current folder </s> find . -name \*.c -print0
Copy directory hierarchy "dir" and all its .txt files to "dir_txt" </s> find dir/ -name '*.txt' | xargs cp -a --target-directory=dir_txt/ --parents
Search the current directory tree for files whose names do not end in ".exe" and ".dll" </s> find . -not -name "*.exe" -not -name "*.dll" -not -type d
Find all regular files in the current directory tree that are not readable by anyone </s> find . -type f ! -perm -444
Find files/directories named 'sar' under directory trees whose path starts with '/u' or '/b' or '/s' or '/o' </s> find `ls -d /[ubso]*` -name sar
Report file system containing path-to-file disk usage human-readable. </s> df -h path-to-file
Sort file pointed by variable $filename, removing duplicate entries but ignoring the last N characters of each line. </s> rev $filename | sort | uniq -f=N | rev
Find all MP3s in the /home directory tree </s> find /home -type f -name '*.mp3'
Find all files/directories in entire file system that are exactly 50 bytes </s> find / -size 50c
remove all the pdf files in the current folder and do not delete those in the sub folders </s> find . -name "*.pdf" -maxdepth 1 -print0 | xargs -0 rm
get a PID of a process </s> jobs -x echo %1
Replace all newlines with spaces in the contents of "file" </s> sed -e '{:q;N;s/\n/ /g;t q}' file
Source executable "virtualenvwrapper.sh" found in $PATH </s> source `which virtualenvwrapper.sh`
List environment variables and their values whose name matches '^\w*X\w*' </s> set | grep -P '^\w*X\w*(?==)'
Extract any line in "fileA" which does not appear as the first word of any line in "fileB" </s> comm -23 <(sort fileA) <(cut -d' ' -f1 fileB | sort -u)
show all the directories in the current folder </s> find . -type d
remove all the log files which have not been modified in the last 5 days </s> find /logs -type f -mtime +5 -exec rm {} \;
Delete characters in columns 36 through 40 from the output of "finger" </s> finger |  sed 's/\(.\{35\}\)...../\1/'
Find all files in the current directory tree whose size is greater than 1MB, and move them to the "files" folder with confirmation </s> find . -size +1M -ok mv {} files \+
Split "/usr/bin/firefox" into 1000 files of about equal size </s> split -n 1000 /usr/bin/firefox
ERROR - need to add -a or -r for recursive copy </s> rsync --exclude='B/' --exclude='C/' . anotherhost:/path/to/target/directory
Find *.js UTF-8 files with BOM and correct them </s> find . -iname *.js -type f -exec sed 's/^\xEF\xBB\xBF//' -i.bak {} \; -exec rm {}.bak \;
Create a new RSA key for ssh with no passphrase, store it in ~/.ssh/id_rsa without prompting to overwrite if this file exists, and minimize output from ssh-keygen. </s> echo -e  'y\n'|ssh-keygen -q -t rsa -N "" -f ~/.ssh/id_rsa
Just find directories and skip file names </s> find  / -type d -name "apt" -ls
Finds all the log* files in /myDir recursively that are more than 7 days older, skipping already created .bz2 archives and compresses them. </s> find /myDir -name 'log*' -and -not -name '*.bz2' -ctime +7 -exec bzip2 -zv {} \;
change permission of all the files in the entire file system which have permissions 777. </s> find / -type f -perm 0777 -print -exec chmod 644 {} \;
Find the largest original ".gz" file in the current directory tree </s> find . -name '*.gz' -print | xargs gzip -l | awk '{ print $2, $4 ;}'  | grep -v '(totals)$' | sort -n | tail -1
Build an "svn hotcopy" command for each subdirectory of /usr/local/svn/repos/ </s> find /usr/local/svn/repos/ -maxdepth 1 -mindepth 1 -type d -printf "%f\0" | xargs -0 -I{} echo svnadmin hotcopy /usr/local/svn/repos/\{\} /usr/local/backup/\{\}
List directories in the current working directory and remove the trailing "/" </s> ls -1p | grep '/$' | sed 's/\/$//'
search for all the files in the folder /home/user1 which end with ".bin" </s> find /home/user1 -name "*.bin"
delete all the php files in the folder /var/www </s> find /var/www/*.php -type f -exec rm {} \;
find regular which case-insensitive name is foo in current directory </s> find . -iname foo -type f
Prints lines count of each *.php file in a current folder and subfolders, and prints total count. </s> find . -name '*.php' -print0 | xargs -0 wc -l
Count total number of lines in all files below current directory. </s> find . -type f -exec wc -l {} \; | awk '{ SUM += $0} END { print SUM }'
Set up a local SSH tunnel from port 80 to port 3000 </s> ssh $USERNAME@localhost -L 80:localhost:3000 -N
Recursively removes all files like '*.pyc' in a current folder. </s> find . -name '*.pyc' -print0 | xargs -0 rm
Find and show all files in the current directory tree that are smaller than 500 kB </s> find . -size -500k
split the file "/path/to/large/file" into pieces per 50000 lines named as /path/to/output/file/prefixNNN </s> split --lines=50000 /path/to/large/file /path/to/output/file/prefix
find all the files that have been modified today </s> find . -type f -mtime 0
insert "e" when it's pressed </s> bind '"e":self-insert'
ssh into "hostname" as user "buck" </s> ssh buck@hostname
Mount image "test" to loop device "/dev/loop0" </s> sudo mount -o loop /dev/loop0 test
create directory testExpress </s> mkdir testExpress
Prints process tree of the current process with parent processes. </s> pstree -s $$
display list of all the regular/normal files in the home folder which are bigger than 512 kb </s> find /home/ -type f -size +512k -exec ls -lh {} \;
Delete all .svn files/directories under current directory </s> find . -name .svn |xargs rm -rf
Display the number of regular files under current directory tree </s> find . -type f -exec echo {} \; | wc -l
Remove all *.tmp files from the /tmp directory tree </s> find /tmp -name "*.tmp" -print0 | xargs -0 rm
Gets MAC address of 'eth0' network interface. </s> ifconfig eth0 | grep -o -E '([[:xdigit:]]{1,2}:){5}[[:xdigit:]]{1,2}'
Find all Read Only files in entire file system and show a few lines of output from the beginning </s> find / -perm /u=r | head
Rename "blah1" to "blah1-new" </s> mv blah1 blah1-new
find all the directories in the folder /raid with the extension local_sd_customize. </s> find /raid -type d -name ".local_sd_customize" -print
find all normal/regular files in the current directory </s> find . -type f -print
Search for the case insensitive regex expanded by $2 in all files named $1 (to be expanded) under current directory </s> find . -name "$1" -type f -exec grep -i "$2" '{}' \;
Recursively prints all files in a current folders, and searches "stringYouWannaFind" in file content ignoring case differences, and preceding found string with its number in file. </s> find ./ -type f -print -exec grep -n -i "stringYouWannaFind" {} \;
Remove trailing whitespaces in .txt files from the current directory tree </s> find . -type f -name '*.txt' -exec sed --in-place 's/[[:space:]]\+$//' {} \+
Print summary of new/missing files, and which files differ between dir_one and dir_two, sorted alphabetically. </s> diff -qr dir_one dir_two | sort
Change the owner of all files in "/empty_dir/" to "root" using at most 10 files at a time </s> ls /empty_dir/ | xargs -n10 chown root
Print the byte count of all regular files found in the current directory tree </s> find . -type f | xargs | wc -c
Shows MAC address of network interface eth0. </s> ifconfig eth0 | grep HWaddr |cut -dH -f2|cut -d\  -f2
Find all files in /var/www/html/zip/data/*/*/*/*/* that are older than 90 days </s> find /var/www/html/zip/data/*/*/*/*/* -type f -mtime +90
Find all files in the current directory tree whose names begin with '-' </s> find . -name '[-]*'
Find all files/directories with '.o' extension under '/lib/modules' directory tree </s> find /lib/modules -name '*.o'
create a backup of all the files which have been modified in the last 48 hours </s> find source/directory -ctime -2 | cpio -pvdm /my/dest/directory
display all the java script files in the current folder </s> find . -name "*.js"
Print a colon-separated list of all directories from the ~/code directory tree, except hidden ones </s> find ~/code -type d -name '[^\.]*' | tr '\n' ':' | sed 's/:$//'
Search for the case insensitive regex 'STRING_TO_SEARCH_FOR' in all files under current directory </s> find . -type f -exec grep -n -i STRING_TO_SEARCH_FOR /dev/null {} \;
Save hexadecimal bytes 7 and 8 in binary file "file.moi" to variable "year" </s> year=$(od -t x2 --skip-bytes=6 --read-bytes=2 file.moi | head -1 | awk '{print $2}')
Save the user name of the current user to variable "me" </s> me="$(whoami)"
Find regular files named "expression -or expression" under and below /dir/to/search/ </s> find /dir/to/search/ -type f -name 'expression -or expression' -print
Number every line of standard input as zero padded to 6 characters followed by "-" </s> nl -s- -ba -nrz
Look for SGID files and directories </s> find / -perm /g=s
Find recursively all regular files in the current directory tree not ending in .dll or .exe </s> find . -type f | grep -vP "\.dll$|\.exe$"
List the names of all files under current directory </s> find . -type f -exec basename {} \;
Show file type information for all regular files under '/home' directory tree </s> find /home -type f -exec file {} \;
Find all symbolic links in the current directory tree </s> find -type l
Search for 'pattern' in file 'file' and print the matched lines by separating them with spaces instead of newlines </s> grep pattern file | tr '\n' ' '
Update the timestamp of '/tmp/$$' to the current month and day </s> touch -t `date +%m%d0000` /tmp/$$
Find all files under $x directory and set read-write permission for owner and group and no permission for other for those files </s> find ${x} -type f -exec chmod ug=rw,o= '{}' \;
Find all build* directories under /var/www/html/ and reverse sort them </s> find /var/www/html/ -type d -name "build*" | sort -r
Make directories "a/b/c" as needed without causing an error if it exists </s> mkdir -p a/b/c
Change directory to the directory containing the executable file of command "oracle" </s> cd $(which oracle | xargs dirname)
dispaly a long listig of all the files in the current folder which are bigger than 100KB </s> find . -size +100000 -ls
create symbolic links in current directory to all files located in directory "/original" and have filename extension ".processname" </s> ln -s $(echo /original/*.processme) .
find all files in the a direcotry which have been modified in exactly 1 day back </s> find /home/bozo/projects -mtime 1
find all the files in the entire file system that were modified in the last 10 minutes </s> find / -mmin -10
Find all .gif files in the /var/www directory tree </s> find /var/www -name *.gif
Finds recursively and following symlinks from root folder all files that contain "text-to-find-here" and prints files names. </s> grep -Ril "text-to-find-here" /
display all files in the current folder along with their last access timestamps </s> find . -printf "%h/%f : dernier accès le %Ac\n"
Print content of all files found regarding seach options '[whatever]' </s> find [whatever] -print0 | xargs -0 cat
Prints path to the target of symbolic link 'relative/path/to/file' </s> dirname `readlink -e relative/path/to/file`
Counts lines in each of *.php files in a current folder and subfolders ignoring 'tests' folder and prints total count as well. </s> find . -name tests -prune -o -type f -name '*.php' | xargs wc -l
Remove all files and directories called "test" from the current directory tree </s> find . -name test -exec rm -R "{}" \;
Delete all directories in the TBD directory that were modified more than 1 day ago </s> find /TBD -mtime +1 -type d | xargs rm -f -r
List all files and directories in long list format with a time style of "long-iso" and sort from oldest modifed to newest modified </s> ls -l --time-style=long-iso | sort -k6
Find all files under images directory </s> find images -type f
Prints full path to files with dot in name in a current folder. </s> ls -d -1 $PWD/*.*
Find "file.xml" under the current directory and change directory to its parent </s> cd `find . -name file.xml -printf %h`
display list of all the files in the current folder which are empty. </s> find . -size 0 -ls
Find all 'test' directories in the current directory tree and remove them </s> find -type d -a -name test|xargs rm -r
Find all files named "something" in the current folder and below and run them through the ls -l command, one by one. </s> find . -name something -exec ls -l {} \;
Replace all newlines except the last with a comma in "test.txt" </s> sed -i ':a;N;$!ba;s/\n/,/g' test.txt
Search the current directory tree for directories lacking execute permissions for user, group, or others </s> find . -type d ! -perm -111
Find all files that are set user ID to root </s> find . -user root -perm -4000 -print
Save the absolute path of the current script to variable "SELF" </s> actual_path=$(readlink -f "${BASH_SOURCE[0]}")
Print lines in file 'filename' that do not match the regex 'pattern' </s> grep -v 'pattern' filename
Find all filenames ending with .c in the /usr directory tree </s> find /usr -name "*.c"
View manual page of find utility </s> man find
Save Java home in variable "JAVA_HOME" </s> JAVA_HOME="$( readlink -f "$( which java )" | sed "s:bin/.*$::" )"
Find all files in current directory and search for 'searchName' in those files </s> find ./ -name "*" | xargs grep "searchName"
Print the current directory tree with file permissions </s> tree -p
Remove sequence like '\xEF\xBB\xBF' from first string of every file in a current folder and subfolders, creating backup file with .bak extension for every changed file, and removing backup on success. </s> find . -type f -exec sed '1s/^\xEF\xBB\xBF//' -i.bak {} \; -exec rm {}.bak \;
Set the host name to the contents of "/etc/hostname" </s> hostname $(cat /etc/hostname)
Find all files in the `sourceDir' directory tree </s> find sourceDir -mindepth 1
Search for the regex ^catalina in the first line of each file under current directory </s> find -type f | xargs head -v -n 1 | grep -B 1 -A 1 -e '^catalina'
Mount "proc" file system on "/var/snmp3/proc" </s> mount -t proc none /var/snmp3/proc
Search core files in current direcory and delete . </s> find . -name core -exec rm {} \;
Gets MAC address of en0 network interface. </s> ifconfig en0 | grep -o -E '([[:xdigit:]]{1,2}:){5}[[:xdigit:]]{1,2}'
Execute "du -s path" every 300 seconds </s> watch -n 300 du -s path
Add newline before all 2nd and consequent occurrences of '3d3d' in file 'temp' and write each line from the output to files with prefix 'temp' and numeric suffixes </s> sed 's/3d3d/\n&/2g' temp | split -dl1 - temp
Get domain name of $ip and save it to the variable 'reverse' </s> reverse=$(dig -x $ip +short)
Print the pathnames of all files from the /tmp/dir1 directory tree </s> find /tmp/dir1 -exec echo {} \;
Report file system containing path to /dir/inner_dir/ disk usage in kilobytes. </s> df -k /dir/inner_dir/
Print the list of directories that are present in the /mnt/raid directory tree </s> find /mnt/raid -type d
Recursively copies "$appname.app", preserving symlinks as symlinks to the 'Payload' directory. </s> cp -Rp "$appname.app" Payload/
Check if current shell is running within a 'screen' process. </s> pstree --show-parents -p $$ | head -n 1 | sed 's/\(.*\)+.*/\1/' | wc -l
Remove all files containing 'sample' (case insensitive) in their names under '/home/user/Series' directory tree </s> find /home/user/Series/ -iname '*sample*' -exec rm {} \;
Find broken symlinks in current directory </s> find -L -type l
Remove all files matching the pattern *[+{;"\\=?~()<>&*|$ ]* under current directory </s> find . -name '*[+{;"\\=?~()<>&*|$ ]*' -exec rm -f '{}' \;
Forward all connections to client localhost 3307 via the SSH tunnel to gateway and then connect to host 1.2.3.4 to port 3306 </s> ssh -f user@gateway -L 3307:1.2.3.4:3306 -N
Print the list of the current directory's subdirectories </s> find -maxdepth 1 -type d
search for text files in the folder /home/you which have been modified in the last 60*24 hours(case insensitive search) and display their contents </s> find /home/you -iname "*.txt" -mtime -60 -exec cat {} \;
display all files in the current folder which do not match the regular expression </s> find . -not -regex ".*test.*"
Calculate the md5 sum of all *.py files in the current directory </s> cat *.py | md5sum
find all the files in the home folder that are modified day before yesterday </s> find $HOME -mtime -2 -mtime +1
delete all text files from current folder </s> find . -type f ! -iname "*.txt" -delete
Request DNS record for  domain 'dragon-architect.com' with tracing and additional section, and extract third block of text, separated between two new lines. </s> dig +trace +additional dragon-architect.com | awk 'NR==3' RS="\n\n"
Recursively change the owner and group of all files in "/your/directory/to/fuel/" to "nginx" </s> chown nginx:nginx /your/directory/to/fuel/ -R
Lists all subdirectories in current directory with a trailing slash </s> ls -d ./*/                     ### more reliable BSD ls
Find '.git' directories in directory tree /path/to/files and print the pathnames of their parents </s> find /path/to/files -type d -name '.git' -exec dirname {} +
Remove all .sh files in the current directory tree whose names begin with "t" </s> find . -name "t*.sh" -exec rm -vf '{}' \;
Count the number of regular files with case insensitive name pattern $srchfor under 'teste2' directory tree </s> find teste2 -type f -iname "$srchfor"|wc -l
Find files modified between 6 and 9 minutes ago </s> find . -mmin +5 -mmin -10
Find all directories under 'test' directory tree that match the regex '[course*]' in their paths </s> find test -regex "[course*]" -type d
files all files which expect directories and display count of them </s> find /usr/share \! -type d wc -l
Find *.java files in the current directory and replace foo with bar in those files </s> find . -name "*.java" -exec sed -i '' s/foo/bar/g \;
set variable "uname_m" to machine architecture, ie. x86_64 </s> uname_m=`uname -m`
Archive "/path/to/files" on host "remotemachine" authentifying as user "user" and compressing data during transmission, copy symlinks as symlinks. </s> rsync -avlzp user@remotemachine:/path/to/files /path/to/this/folder
Replace "inputfile" with a sorted unique list of its contents </s> sort inputfile | uniq | sort -o inputfile
Make directories "project/{lib/ext,bin,src,doc/{html,info,pdf},demo/stat/a}" as needed and do not cause an error if it exists </s> mkdir -p project/{lib/ext,bin,src,doc/{html,info,pdf},demo/stat/a}
split file "$file into pieces named with 5 character suffix </s> split -a 5 $file
Find all *.txt file (case insensitive) in the entire system and copy them to /tmp/txt </s> find / -iname '*.txt' | xargs --replace=@ cp @ /tmp/txt
Display a long listing of the files/directories with human readable sizes (100M, 10G etc..) under '/var' directory tree which are bigger than 10MB </s> find /var/ -size +10M -exec ls -lh {} \;
Open gcc info manual and select "option index" menu entry. </s> info gcc "option index"
List all *.txt files under current directory that contains the regex 'pattern' </s> find . -type f -name '*.txt' -exec egrep -l pattern {} \;
Prefix all files and folders in the current directory with "PRE_" </s> ls | xargs -I {} mv {} PRE_{}
Search for all *.conf files in entire file system </s> find / -type f -name "*.conf"
Show manual page of find </s> man find
Find all *.jpg (case insensitive) files under current directory </s> find . -iname '*.jpg'
List all files 2 levels deep in the current directory tree </s> tree -L 2 -fi
change the permission of all the normal/regular files from 777 to 755 in the folder "/home/user/demo" </s> find /home/user/demo -type f -perm 777 -print -exec chmod 755 {} \;
find all files in the current folder which end with macs </s> find -name '*macs'
Find all files under /path/to/dir that were modified less than 7 days ago and show only first several lines of output </s> find /path/to/dir -type f -mtime -7 -print0 | xargs -0 ls -lt | head
Print list of files that are only in directory /dir1 and not their sub directories and only their file names. </s> diff -q /dir1 /dir2 | grep /dir1 | grep -E "^Only in*" | sed -n 's/[^:]*: //p'
renames all ".htm" files to ".html" files </s> find . -name "*.htm" -exec mv '{}' '{}l' \;
Find all files in the current directory tree whose names are ".DS_STORE" </s> find . -name ".DS_STORE"
Find all the files which are modified more than 50 days back and less than 100 days </s> find / -mtime +50 –mtime -100
Find text files modified less than 5 days ago </s> find . –name "*.txt" –mtime 5
display all the empty files in the entire file system </s> find / -size 0 -print
display all the files in the folder "$ORIG_DIR" </s> find "$ORIG_DIR"
Count the number of differing lines in "file1" and "file2" with 0 lines of unified context </s> diff -U 0 file1 file2 | grep -v ^@ | wc -l
search for word linux in all the regular/normal files in the folder mail. </s> find ~/mail -type f | xargs grep "Linux"
List the MD5 digest of all files under "teste1" and "teste2" sorted alphabetically </s> find teste1 teste2 -type f -exec md5 -r {} \; | sort
Find all regular files newer than '/tmp/$$' (where $$ expands to current process id) under '/tmefndr/oravl01' directory tree </s> find /tmefndr/oravl01 -type f -newer /tmp/$$
Print onlt last slash-separated field from $PATH value </s> echo "$PATH" | rev | cut -d"/" -f1 | rev
display all normal/regular files in current folder </s> find . -type f
Find all files in the /usr directory tree that are owned by group `staff' </s> find /usr -group staff
Find files/directories named blah under current directory </s> find ./ -name blah
Set variable 'vara' to 3 </s> source <(echo vara=3)
List all zero-length files </s> find . -empty -exec ls {} \;
Print the current date followed by ": $line" </s> echo "$(date): " $line
Print local files without descending non-local directories </s> find . ! -local -prune -o -print
Search the /myfiles directory tree for files last modified 2 days ago </s> find /myfiles -mtime 2
keep only read access to all the files in a directory. </s> find /path/to/dir ! -perm 0644 -exec chmod 0644 {} \;
Prints long listing of directory $var sorted from oldest to newest, with appended indicators. </s> $ ls -Fltr $var
Print common files of directory "one" and "two" </s> comm -12  <(ls one) <(ls two)
Copies ""$project_dir"/iTunesArtwork", to the 'Payload/iTunesArtwork', rewriting files if necessary. </s> cp -f "$project_dir"/iTunesArtwork Payload/iTunesArtwork
find all files in the current folder which have not been modified today and whose file name is of length 1 </s> find . -name \? -mtime +0
Set variable 'path' to name of current directory (without the containing directories) converted to lowercase. </s> path=$(basename $(pwd) | awk '{print tolower($0)}')
delete all the directories empty directories in the current folder </s> find . -type d -empty -delete
Find all files/directories named 'query' under current directory tree </s> find -name "query"
Remove all directories called "test" from the current directory tree </s> find . -name test -type d -print0|xargs -0 rm -r --
Merge already sorted files in the current directory ending in ".$suffix" </s> sort -m *.$suffix
find non-hidden files (ones that do not start with the period "." chartacter) that were are modified in the last 15 minutes. </s> find . -mmin -15 \( ! -regex ".*/\..*" \)
Search  all files & directoy from root directory which  are greater then 100M and delete them . </s> find /  -size +100M -exec rm -rf {} \;
Read a line from standard input and save each word in the bash array variable "first" </s> read -a first
Remove files from the home directory tree that were last accessed more than 100 days ago </s> find ~ -atime +100 -delete
force delete all the files which have not been accessed in the last 240 hours in the temp folder </s> find /tmp/* -atime +10 -exec rm -f {} \;
Removes all empty folders within $DELETEDIR folder. </s> find "$DELETEDIR" -mindepth 1 -depth -type d -empty -exec rmdir "{}" \;
display all the doc files in the current folder ( files ending with ".doc" ) </s> find . -name '*.doc'
Find all empty regular files in the current directory tree </s> find . -size 0c -type f
view the manual page of find </s> man find
Find files whose name starts with "MyFile", ignoring the case </s> find . -iname 'MyFile*'
Prompt the user with a question "This is the question I want to ask?" and save "y" or "n" in variable "REPLY" in zsh </s> read REPLY\?"This is the question I want to ask?"
change the owner and group of all the normal/regular files in the current folder and /home/admin/data/ to admin & admin </s> find . /home/admin/data/ -type f -exec chown admin.admin {} \;
Display the file type description of /bin/bash, ie. symbolic link, ELF executable, etc. </s> $ file /bin/bash
Find and remove multiple files such as *.mp3 or *.txt under current directory </s> find . -type f -name "*.mp3" -exec rm -f {} \;
Find all files and directories that do not match the pattern given as the $controlchars variable </s> find . ! -name "$controlchars"
Find regular files larger than 500MB in the current directory tree </s> find . -type f -size +500M
Send two ping requests to "www.google.com" </s> ping -c 2 www.google.com
split the file data.csv into pieces per 100 mb named as data.tsv.NNN with digital prefixes </s> split -C 100m -d data.tsv data.tsv.
Delete in the background all files in /var/tmp/stuff1 and below that have not been modified in over 90 days </s> find /var/tmp/stuff1 -mtime +90 -delete &
Find all *.mp4 files under /working </s> find /working -type f -name '*.mp4'
sort each file in the bills directory, leaving the output in that file name with .sorted appended </s> find bills -type f -execdir sort -o '{}.sorted' '{}' ';'
Recursively finds all files in a current folder excluding already compressed files and compresses them with level 9. </s> find . -type f | egrep -v '\.bz2' | xargs bzip2 -9 &
Read standard input until a null character is found and save the result in variable "f2" </s> read -r -d $'\0' f2
Find all *.rb (regular) files under current directory and print them on stdout putting the file name/path in-between two string literals 'Hello,' and '!' </s> find . -name "*.rb" -type f | xargs -I {} echo Hello, {} !
search a url in all regular/normal files in a folder. </s> find ./ -type f -exec grep https://www.ksknet.net {} \;
Show who is logged on </s> who
Prepend date to ping output to google.com </s> ping google.com | xargs -L 1 -I '{}' date '+%+: {}'
display all the files in the current folder except those whose name is "PERSONAL" </s> find . -name PERSONAL -prune -o -print
Find all files whose names end with "~" in the /home/peter directory tree, following symlinks, and delete them </s> find -L /home/peter -name *~ -print0 |xargs -0 -r rm
find files under the current directory called "foo" or "bar" </s> find . \( -name "foo" -o -name "bar" \)
find all the patch files in current folder and copy them to separate folder patches </s> find -name '*.patch' -print0 | xargs -0 -I {} cp {} patches/
Find files associated with an inode </s> find . -inum 968746 -print
Search the current directory tree for files and directories whose names do not end in ".exe" and ".dll" </s> find . -not -name "*.exe" -not -name "*.dll"
Create a full path symbolic link "$newlink" from a relative path symbolic link "$origlink" </s> ln -s $(readlink -f $origlink) $newlink
Make directory and parents as needed to "~/temp/bluecove/target/" </s> mkdir -p ~/temp/bluecove/target/
Attempt to connect as root via ssh to host whose IP address or hostname is specified by environment variable IPADDRESS - this will normally fail because ssh servers normally don't accept root logins. </s> scp -rp "DAILY_TEST_FOLDER" "root@${IPADDRESS}:/home/root/"
Change owner to "root" and group to "www-data" of "/foobar/test_file" </s> sudo chown root:www-data /foobar/test_file
Create all directories in the path specified by variable $tempWork </s> mkdir -p $tempWork
List files in the current directory and below except for GIT files </s> find . -not -iwholename '*/.git/*'
Display file.txt with lines numbered, and page interactively through the result. </s> less -N file.txt
remove all text files from the current folder </s> find -name "*.txt" | xargs rm
Exit the shell on the first error encountered </s> set -e
Find all files/directories under current directory tree whose names start with 'some_text_2014.08.19' </s> find . -name 'some_text_2014.08.19*'
Print the list of the subdirectories of /path/to/dir </s> find /path/to/dir/ -mindepth 1 -maxdepth 1 -type d
Read a line from standard input with a timeout of 0.1 seconds and prompt "This will be sent to stderr" </s> read -t 0.1 -p "This will be sent to stderr"
Run 'otherscript.sh' script with all environment variables specified in the file 'xxxx' </s> env `cat xxxx` otherscript.sh
Search for 'string' case insensitively in all files under current directory tree and show the matched lines with their filenames </s> find . -name * | xargs grep -iH "string"
Print file system disk space usage and grand total for the root file system with sizes in powers of 1000 </s> df -H --total /
find all regex "./[a-f0-9\-]\{36\}\.jpg" files </s> find . -regex "./[a-f0-9\-]\{36\}\.jpg"
Recursively copy "dir_a" to "dir_b" and delete any new files in "dir_b" </s> rsync -u -r --delete dir_a dir_b
Find all SUID set files under current directory and show a few lines of output from the beginning </s> find . -perm /u=s | head
find all the html files in the current folder and replace the end of each line with a pattern </s> find ./ -type f -name '*.html' | xargs sed -i '$s/$/<\/description>/'
Delete all files in the $DIR directory that have not been accessed in 5 or more days. </s> find "$DIR" -type f -atime +5 -exec rm {} \;
Search /path/to/your/directory for *.avi and *.flv files </s> find /path/to/your/directory -regex '.*\.\(avi\|flv\)'
Display inputfile all on one line (replace newlines by spaces) </s> awk 1 ORS=' ' file
display all pdf files in the current folder </s> find . -name *.pdf
List all leaf directories of the current directory tree </s> find . -type d | sort | awk '$0 !~ last "/" {print last} {last=$0} END {print last}'
Create new crontab set including $job and only jobs from current crontab that don`t contain $command </s> cat <(fgrep -i -v "$command" <(crontab -l)) <(echo "$job") | crontab -
Copy all *.data files under /source_path to /target_path </s> find /source_path -name *.data -exec cp {} /target_path \;
Do not immediately exit the shell if a command fails </s> set +e
Save the md5 sum of $twofish to variable 'twofish' </s> twofish=`echo -n $twofish | md5sum | tr -d "  -"`
Print only alphanumeric values from "/dev/urandom" </s> cat /dev/urandom | tr -dc 'a-zA-Z0-9'
find all the files in the home folder which are empty (Size 0 bytes) </s> find ~ -empty
Calculate a list of duplicate md5 sum hashes for all the ".java" files in the current directory </s> md5sum *.java | awk '{print $1}' | sort | uniq -d
Prints the file path composed from the path where symlink target file is located, and name of the symbolic link itself. </s> echo "$(dirname $(readlink -e $F))/$(basename $F)"
Set the read bit for "other" on all *rc.conf files in the current directory tree </s> find . -name "*rc.conf" -exec chmod o+r '{}' \;
List all regular files under the current directory and below it </s> find . -type f -print0 | xargs -0 ls -l
Search for 'js' in all files under current directory that match 'some string' in their names </s> find . | grep 'some string' | grep js
count amount of jobs running </s> jobs | wc -l
Find all files under current directory </s> find "`pwd`" -type f
List all files under current directory with white space safety in their paths </s> find . -type f -print0 | xargs -0 ls
Print "$1" or default 10 random lines from standard input </s> nl | sort -R | cut -f2 | head -"${1:-10}"
Find all files under /home/username/public_html/sites/all/themes and set their permission to 640 </s> find /home/username/public_html/sites/all/themes -type f -exec chmod 640 {} +
View history using "less" </s> history | less
Copy the directory hierarchy of the current directory to "destdir" </s> find . -type d | cpio -pdvm destdir
Send a single ping request with a TTL of 1 to "192.168.1.1" </s> ping -c 1 -t 1 192.168.1.1
Search for 'It took' in all $srch1* (case insensitive) files under current directory </s> find . -iname "$srch1*" -exec grep "It took" {} \; -print
grep from bottom of file </s> tac your.log | grep stuff
Get the total size of all files under dir1 directory </s> find dir1 ! -type d |xargs wc -c |tail -1
List all *.txt files under current directory that match 'foo=' in their file information </s> find . -name "*.txt" -type f -print | xargs file | grep "foo=" | cut -d: -f1
Find all files larger than 100M and delete them </s> find / -size +100M -exec rm -rf {} \;
split processed content of the file inout_file into pieces per 2000000 named as "out-prefix-NNN" </s> sed 's/\(.....\)\(.....\)/\1\n\2/' input_file | split -l 2000000 - out-prefix-
List all files in entire file system that belong to the user wnj or modified later than the ttt file </s> find / \( -newer ttt -or -user wnj \) -print
Force delete all files in the current folder </s> find . | xargs -i rm -f "{}"
Find the directories whose pathnames contain "New Parts" at level 3 of the current directory tree and create symlinks to them in /cygdrive/c/Views </s> find -mindepth 3 -maxdepth 3 -type d | grep "New Parts" | tr '\012' '\000' | xargs -0 ln -s -t /cygdrive/c/Views
delete all the log files in the current folder </s> find ./ -name '*.log' -print0 | xargs -0 rm
Check all .txt files whose names may contain spaces whether they contain "needle" </s> find . -type f -iname "*.txt" -print0 | xargs -0 grep "needle"
find all the files which have been modified in the last 15 minutes excluding hidden files. </s> find . -mmin -15 \( ! -regex ".*/\..*" \)
Delete files with inode number specified by [inode-number] under current directory </s> find . -inum [inode-number] -exec rm -i {} \;
Display source and mount point of the file system containing /some/path. </s> df '/some/directory' | awk '{print $1, $6}'
Print file information of command "passwd" </s> ls -l `which passwd`
Read one character from standard input into variable "REPLY" </s> read -n1
List in detail the regular files from the /somelocation/log_output directory tree that were last changed more than 40 days ago </s> find /somelocation/log_output -type f -ctime +40 -exec ls -l {} \;
Find all *.txt files under current directory and copy them to ./tmp </s> find . -type f -name '*.txt' | sed 's/'"'"'/\'"'"'/g' | sed 's/.*/"&"/'  | xargs -I{} cp -v {} ./tmp/
Exchanges the top two directories in the dirs stack. </s> pushd
List all functions or variables containing " ()" defined in the shell </s> set | grep " ()"
Set variable "fname" to the basename of path specified in variable "f", that is remove everything up to the last slash if present. </s> fname=`basename $f`
Search the *.txt files from the current directory tree for "string" </s> find . -name "*.txt" -print0 | xargs -0 egrep 'string'
Find all catalina* files/directories under /path/to/search/in </s> find /path/to/search/in -name 'catalina*'
Search the dir_data directory and all of its sub-directories for regular files and remove the execute permission for all while adding the write permission for the user. </s> find ~/dir_data -type f  -exec chmod a-x,u+w {} \;
Print file information of command "studio" </s> which studio | xargs ls -l
Find all *stat files/directories under /usr </s> find /usr -name *stat
Remove all files in and below the current directory whose names begin with "not" </s> find . -name not\* | tr \\n \\0 | xargs -0 rm
Report file systems disk usage in kilobytes. </s> df -k
Find empty regular files in /dir and its subdirectories </s> find /dir -type f -size 0 -print
find all gif files in the file system </s> find / -name "*gif" -print
Search the regular files from directory tree 'folder_name' for "your_text" </s> find folder_name -type f -exec grep your_text  {} \;
Find ".c" and ".h" files in the current directory tree and print lines containing "#include" </s> tree -if | grep \\.[ch]\\b | xargs -n 1 grep -H "#include"
List all files under current directory </s> find . -type f | xargs ls
search for all the c files in the current folder </s> find . -name \*.c -print
find all the files in the folder /opt which have been modified between 20 to 50 days ago </s> find /opt -mtime +30 -mtime -50
Find all *.css files under /starting/directory and print filenames and the lines matching the regex '\.ExampleClass' from those files </s> find /starting/directory -type f -name '*.css' | xargs -ti grep '\.ExampleClass' {}
Find all .php files in all directory trees matching pattern `/srv/www/*/htdocs/system/application/' and search those files for string "debug (" </s> find /srv/www/*/htdocs/system/application/ -name "*.php" -print0 | xargs -0 grep -H "debug ("
Read a single character from standard input into variable "key" without backslash escapes, with a timeout of 5 seconds, and with the prompt "Press any key in the next five seconds..." </s> read -t5 -n1 -r -p 'Press any key in the next five seconds...' key
find all regular files  then display the number of occurrences of banana without lines not proper end </s> find . -type f -print0| xargs -0 grep -c banana| grep -v ":0$"
Find all files starting from / that belong to user1 </s> find / -user user1
Delete all .bam files in the current directory tree </s> find . -name "*.bam" | xargs rm
Find files in the current directory tree that were accessed within the last 60 minutes </s> find . -amin -60
Join strings from 'file1' and 'file2', discarding excessive strings from largest file, and printing first, second and third space-separated field from first file, and third and fourth field from second file as a join result </s> join -o 1.2,1.3,2.4,2.5,1.4 <(cat -n file1) <(cat -n file2)
Calculate the md5 sum of the md5 sum of all the files sorted under "$path" </s> find "$path" -type f -print0 | sort -z | xargs -r0 md5sum | md5sum
Find all *.jpg files under current directory and print only duplicate names </s> find . -name \*.jpg -exec basename {} \; | uniq -d
Print space separated list of numbers from "$start" to "$end" </s> seq -s' ' $start $end
replace the word apple with orange in all the files in the current folder </s> find ./ -exec sed -i 's/apple/orange/g' {} \;
Search through the /usr directory for all files that begin with the letters Chapter, followed by anything else. </s> find /usr -name "Chapter*" -type f
Get a list of files and directories in the current directory tree </s> find . -print0 | xargs -0 echo
Save small letter short day name of the week to variable 'DayOfWeek' </s> DayOfWeek=`date +%a |tr A-Z a-z`
Rename all files in current directory with names starting with "fgh" so they start with "jkl" instead </s> rename 's/^fgh/jkl/' fgh*
find all the directories in the current folder which have been modified in 24 hours and move them to the folder  /path/to/target-dir </s> find . -type d -mtime 0 -exec mv {} /path/to/target-dir \;
Print the current default full path of the "java" executable </s> echo "The current default java is $(readlink --canonicalize `which java`)"
Find all CDC* files under current directory that were accessed less than 1 day ago and delete the first and last lines from those files and count the number of lines in the output </s> find .  -type f -name "CDC*" -ctime -1 -exec sed -i'' -e '1d' -e '$d' '{}'  \ | wc -l
Find all directories named "D" in the current directory tree </s> find ./ -type d -name 'D'
Prints long listing of top ten most memory using processes in a system. </s> ps -e -orss=,args= | sort -nr | head
Find all files/directories with execute permission by group or others </s> find /path -perm /011
In the current shell, interpret 'incl.sh' which is in the directory pointed by variable DIR </s> source "$DIR/incl.sh"
Find writable regular files in the current directory </s> find .  -maxdepth 1 -type f -writable
Prints current directory name </s> pwd | sed 's#.*/##'
Find all .jpg files in the current directory and below. </s> find . -name “*.jpg”
Archive directory "/mnt/data" to "/media/WD_Disk_1/current_working_data/", deleting any extraneous files in destination, compress data during copy. </s> rsync -az --delete /mnt/data/ /media/WD_Disk_1/current_working_data/;
Create a symbolic link in target directory "$tmpdir" for each file under the current directory </s> find $PWD -type f -exec ln -st $tmpdir {} +
display a long listing of all the normal/regular files in the current folder (print0 is used to handle files which have newlines in their names or files with the name only as spaces ) </s> find . -type f -print0 | xargs -0 ls -l
Attempt to connect as root to localhost and copy /home/reportuser/dailyReport.doc to directory /root/dailyReports/20150105/ - this will normally fail because ssh won't accept root connections by default. </s> scp -p /home/reportuser/dailyReport.doc root@localhost:/root/dailyReports/20150105/
Find regular files which have 644 permission </s> find . -perm 644 -type f -exec ls -l {} \;
Gets IP addresses of all active network interfaces on host. </s> ifconfig | awk -F':' '/inet addr/&&!/127.0.0.1/{split($2,_," ");print _[1]}'
Report file systems inode usage. </s> df -i
List the z* links in the /usr/bin directory with inode information and the file to which it points to </s> find /usr/bin -type  l  -name "z*" -ls
Save the user name in all capitals of the current user to variable "v" </s> v=$(whoami | awk '{print toupper($0)}')
display the count of all normal/regular files in current directory </s> find . -type f | wc -l
Print all lines in file that do not match "pattern" </s> sed -n '/pattern/!p' file
Print all filenames under /proc and below </s> find /proc -exec ls '{}' \;
Find all files/directories which have been modified from the start of the day in directories/files taken from the glob pattern '/tmp/test/*' </s> find /tmp/test/* -daystart -mtime -0
Find all files/directories named 'foo.rb' under current directory tree </s> find . -name foo.rb
Search the /path directory tree for files matching pattern '*.foo' </s> find /path -name '*.foo'
Push the current directory path to the dirs stack </s> pushd `pwd`
Print the names of the subdirectories of /usr/local/svn/repos/ prepending "/usr/local/backup" to them </s> find /usr/local/svn/repos/ -maxdepth 1 -mindepth 1 -type d -exec echo /usr/local/backup{} \;
Remove all files in the ~/backups/mydatabasename directory recursively that were last modified more than 30 days ago </s> find ~/backups/mydatabasename/* -mtime +30 -exec rm {} \;
find files in current directory that names are game </s> find . -name game
Prints calendar of April of 2012, and redirects output to 't' file and 'more' pager tool. </s> cal April 2012 | tee t | more
list regular files under the current directory ending in .mbox putting a null between each file found </s> find . -type f -wholename \*.mbox -print0
Search for 'DOGS' in all files with '.txt' extension under ~/documents and also print the file names </s> find ~/documents -type f -name '*.txt' -exec grep -s DOGS {} \; -print
Search through the /usr/local directory for files that end with the extension .html, and print the file locations. </s> find /usr/local -name "*.html" -type f
Pair side-by-side content of the 'file' and its side-mirrored content </s> paste -d ' ' file <(rev file)
Find all files on the system whose names are 'drush' </s> find / -name drush
find all the files ending with "rb" and display the first 10000 lines from these files. </s> find . -name "*rb" -print0 | xargs -0 head -10000
Write "2-1.1.1" to standard output and to file "/sys/bus/usb/drivers/usb/unbind" </s> echo '2-1.1.1'|sudo tee /sys/bus/usb/drivers/usb/unbind
Recursively change owner and group to "$JBOSS_AS_USER" of "$JBOSS_AS_DIR/" </s> chown -R $JBOSS_AS_USER:$JBOSS_AS_USER $JBOSS_AS_DIR/
Change permissions to 644 for all files in the current directory tree </s> find . -type f | xargs -I{} chmod -v 644 {}
Change permissions to 644 recursively only for files </s> find . -type f -exec chmod 644 {} \;
find all the text files in the current folder expect those which are in the path "sk" </s> find . -path "./sk" -prune -o -name "*.txt" -print
recursively change owner of the directory /usr/lib/node_modules/ to the current user </s> sudo chown -R $(whoami) /usr/lib/node_modules/
Search for the literal string 'v$process' in all files under current directory </s> find . -print|xargs grep v\$process
Recursively changes group ownership of everything in 'files' to 'apache_user'. </s> chgrp -R apache_user files
display the base name(name without extension) of all the ".flac" files in the current folder </s> find . -name "*.flac" -exec basename \{\} .flac \;
display long listing of all regular/normal files whose size is less than 50 bytes. </s> find /usr/bin -type f -size -50c -exec ls -l '{}' ';'
Search the current user's home directory and below for all .png files and copy those files in the directory imagesdir. </s> find ~/ -name *.png -exec cp {} imagesdir \;
List all regular file owned by root with permissions 4000 </s> find / -type f -user root -perm -4000 -exec ls -l {} \;
Save number of lines in '/some/big/file' to 'LINES' variable </s> LINES=$(cat /some/big/file | wc -l)
Create a symbolic link in the current directory for each hidden file or directory in "git-stuff/home/" excluding "." and ".." </s> ln -s git-stuff/home/.[!.]* .
Find all aliencoders.[0-9]+ files/directories under /home/jassi/ directory </s> find /home/jassi/ -name "aliencoders.[0-9]+"
Print the full path of a file under the current working directory with inode number specified on standard input </s> xargs -n 1 -I '{}' find "$(pwd)" -type f -inum '{}' -print
Make directories and parents as needed for each unique second "&" delimited field with " ", ",", and ":" removed in "filetypes.txt" </s> mkdir -p `cut -f2 -d"&" filetypes.txt | sed 's/[ ,:]//g' | sort -u`
display all the html files in the folder /var/www </s> find /var/www -type f -name "*.html"
find all the files in the current folder which are modified after /bin/sh. </s> find . -newer /bin/sh
Find all files that are modified in last 3 days </s> find . -type f -mtime -3
Find all regular files under $dir directory tree with name pattern provided by the first positional parameter and show only the $num'th line from each of those files </s> find $dir -type f -name $1 -exec sed $num'q;d' {} \;
Print the last 10 lines of "great-big-file.log" </s> tail great-big-file.log
Copy /my/configfile to all empty directories of the $somedir directory tree </s> find "$somedir" -type d -empty -exec cp /my/configfile {} \;
Remove spaces from output of "echo aa | wc -l" </s> echo aa | wc -l | tr -d ' '
Find all files/directories named 'top' (case insensitive) in the entire filesystem </s> find / -iname top
List level 2 subdirectories of the current directory </s> find . -mindepth 2 -maxdepth 2 -type d -ls
Display all files in a folder </s> find /usr/X11/man/man5 -print
Find all directories under current directory tree that match the case insensitive regex '^\./course\([0-9]\.\)*[0-9]$' in their paths </s> find . -type d -iregex '^\./course\([0-9]\.\)*[0-9]$'
List all files/directories under current directory </s> find .
Numerically sort file "files" by the second "-" separated value of each line ordered from least value to highest value </s> tac files | sort -t- -k2,2 -n
find all the normal/regular files in the folder main-directory </s> find main-directory -type f
delete all the log files in the current folder </s> find ./ -name '*.log' | xargs rm
Find and list all files on your current directory and show a few lines of output from the beginning </s> find | head
Find all files under ./lib/app and redirect their sorted list to myFile </s> find ./lib/app -type f | sort | tee myFile
display all files in the entire file system excluding the directories /proc,/sys,/dev and those files which are writable and which are not symbolic links and which are not sockets and which do not have the sticky bit set </s> find / -noleaf -wholename '/proc' -prune -o -wholename '/sys' -prune -o -wholename '/dev' -prune -o -perm -2 ! -type l  ! -type s ! \( -type d -perm -1000 \) -print
Find files/directories greater than 10MB in your home directory </s> find ~ -size +10M
Save hexadecimal byte 9 in binary file "file.moi" to variable "month" </s> month=$(od -t x1 --skip-bytes=8 --read-bytes=1 file.moi | head -1 | awk '{print $2}')
Print IP addresses of the host name </s> hostname -I
display all the soft links in a  folder which are not broken </s> find -L /target ! -type l
Print the output of history without line numbers </s> history | sed 's/^[ ]*[0-9]\+[ ]*//'
Make DNS lookup requests for domain list in file '/path/to/host-list.txt' </s> dig -f /path/to/host-list.txt
Go into the first directory whose name contains 1670 </s> cd `find . -maxdepth 1 -type d | grep 1670`
Search directory tree `MyApp.app' for directories whose name is 'Headers' and delete them </s> find -d MyApp.app -name Headers -type d -exec rm -rf "{}" \;
Search the /var/www/ tree for files not owned by user `apache' </s> find /var/www ! -user apache -print0 | xargs -0
Prints logged in users in sorted order. </s> w | sort
find files under the current directory ending in "txt" and list them, or ending in  "html" but do nothing. </s> find . -name '*.txt' -print -o -name '*.html'
Save the logical current working directory to variable "basedir" </s> basedir=$(pwd -L)
Find all files in the current directory tree whose pathnames match pattern "./sr*sc" </s> find . -path "./sr*sc"
Find all *.htm files under current directory and print the changed names by appending 3 levels of parent directory names at the beginning and modifying the actual name to dd-nnn format </s> find -type f -name "*.htm" | awk -F'[/]' 'BEGIN{OFS="-"}{ gsub(/^\.\//,"") ;print $1,$2, substr($4,3,2),substr($4,5,2),substr($4,8) }'
search for the directory "config" in the current folder </s> find . -name config -type d
Find all files that aren't owned by user www-data </s> find -not -user www-data
Remove from the current directory tree all the regular files which have a dot in their names and contain string "<img-name>-<width:integer>x<height:integer>.<file-ext> syntax" </s> find . -name "*.*" -type f -exec grep -l '<img-name>-<width:integer>x<height:integer>.<file-ext> syntax' {} \; | xargs rm -f
Search for 'mystring' in all *.txt files under current directory </s> find . -name "*.txt" -print0 | xargs -0 egrep mystring
Find all files under /path/to/input/ that match the case insensitive string literal 'spammer@spammy.com' in their contents </s> find /path/to/input/ -type f -exec grep -qiF spammer@spammy.com \{\} \; -print
Save the absolute path of the directory of the current script to variable "DIR" </s> DIR=$(dirname "$(readlink -f \"$0\")")
Find all files/directories under current directory tree </s> find | xargs
search for all tar.gz compress files  in the current folder </s> find -name *.tar.gz
delete all the ".bak" or swap files in kat folder </s> find kat -type f \( -name "*~" -p -name "*.bak" \) -delete
Replace all ocurrences of '<title>' with 'sblmtitle\n<title>' in all the regular files with '.html' extension under current directory tree </s> find ./ -type f -name '*.html' | xargs sed -i 's/<title>/sblmtitle\n<title>/g'
search for all the files which have not been modified in the last 6 months (180 days) in current folder and display the disk usage of them </s> find . -mtime +180 -exec du -sh {} \;
Remove all files and directories under '/home/foo' directory tree that match with one of the name patterns '.DS_Store', '._.DS_Store' , '._*', '.TemporaryItems' or '.apdisk' </s> find /home/foo \( -name '.DS_Store' -or -name '._.DS_Store' -or -name '._*' -or -name '.TemporaryItems' -or -name '.apdisk' \) -exec rm -rf {} \;
Find all files whose names end with "macs" in and below the current directory </s> find -name '*macs'
Remove all .txt files in and below the current directory </s> find . -name "*.txt" -delete
Get from file 'File1.txt' strings starting with 'Q', extract only part of them following after '=' sign, and print which ones are not found in 'File2.txt' </s> grep ^Q File1.txt | cut -d= -f2- | sort | comm -23 - <(sort File2.txt)
Format file "list-of-entries.txt" with no column delimiter </s> column -t -s '' list-of-entries.txt
extract 'archive.tar.gz' to /destination </s> tar xzf archive.tar.gz -C /destination
Remove the path $1 from the PATH environment variable </s> PATH=$(echo $PATH | tr ":" "\n" | grep -v $1 | tr "\n" ":")
find all the html files in the current folder </s> find . -name "*.html"
Make hidden directory ".hiddendir" </s> mkdir .hiddendir
Print file type of the command "c++" </s> file `which c++`
locate large files (> 100 MB) in /home/ for 'cleaning' </s> find /home -type f -size +100M -delete
View history using "vim" </s> vim <(history)
change the extension of all the ".lst" files in the current folder to "a.lst" </s> find -name ‘*.lst’ -exec rename .lst a.lst {} \;
Creates temporary file and saves path to it in a 'tmpfile' variable. </s> tmpfile=$(mktemp)
Print the current working directory without a trailing newline </s> echo -n $(pwd)
Recursively changes group ownership of every folder in a current directory to the name of that folder. </s> find . -type d | sed -e 's/^\.\///g' -e 's/^\./avoid/g' | grep -v avoid | awk '{print $1"\t"$1}' | xargs chgrp
find all html or cgi files in current folder </s> find ./ -type f -iregex ".*\.html$" -or -iregex ".*\.cgi$"
Count the number of equal lines in sorted files "ignore.txt" and "input.txt" </s> comm -12 ignore.txt input.txt | wc -l
find directories  that have been modified in the last seven days </s> find . -mtime -7 -type d
find files (under root file system /) that were accessed within the last 24 hours </s> find / -atime -1
Search the current directory tree for files whose names begin with 'my' </s> find . -name 'my*'
Find all files/directories under /home/bozo/projects directory that were modified 1 day ago </s> find /home/bozo/projects -mtime 1
Display all the files/directories under '/home/bozo/projects' directory tree that have been modified within the last day </s> find /home/bozo/projects -mtime -1
find all the regular/normal files in all the directories in the /some/dir and delete them </s> find /some/dir -type d -exec find {} -type f -delete \;
display all regular/normal files in the folder "dir" and display the filename along with file size </s> find dir -type f -printf "f %s %p\n"
Change directory to the download directory specified in the current user's user-dirs.dirs file </s> cd "$(grep DOWNLOAD $HOME/.config/user-dirs.dirs | cut -f 2 -d "=" | tr "\"" "\n")"
List all regular files in entire file system </s> find / -type f -exec echo {} \;
Print host name followed by ":" and the contents of "/sys/block/sda/size" </s> echo "$(hostname):$(cat /sys/block/sda/size)"
display files in current folder ending with "pdf" or "PDF" </s> find . -name '*.pdf' -or -name '*.PDF'
Print lines in the sorted contents of "file1" that are not in the sorted contents of "file2" </s> comm -23 <(sort file1) <(sort file2)
Find all files that belongs to user root under / directory and show a few lines of output from the beginning </s> find / -user root | head
change owner of the files into directory dir_to_start except directory dir_to_exclude to user owner </s> find dir_to_start -name dir_to_exclude -prune -o -print0 | xargs -0 chown owner
Remove all regular files under and below directory "$DIR" that were last accessed more than 5 days ago </s> find "$DIR" -type f -atime +5 -exec rm {} \;
Find files with 002 permission in entire file system </s> find / -type f -perm -002
Search the entire file hierarchy for all regular files owned by olduser and change their ownership to newuser. </s> find / -user olduser  -type f  -exec chown newuser {} \
Find all files/directories named orm.properties under  /eserver6/share/system/config/cluster directory </s> find /eserver6/share/system/config/cluster -name "orm.properties"
Sort lines in "set1" and "set2" to standard output preserving only unique lines </s> sort -u set1 set2
Count the number of times each person is logged in on the system </s> who | awk '{print $1}' | sort | uniq -c | sort -n
find all the files in the root folder which have been modified in the last 24 hours and print them </s> find / -mtime -1 -print
Print every two lines in "num.txt" on a single line separated by a space </s> paste -d' ' <(sed -n 'p;n' num.txt) <(sed -n 'n;p' num.txt)
List all *.c, *.h and *.cpp files under current directory </s> find . -type f \( -name '*.c' -or -name '*.h' -or -name '*.cpp' \) -exec ls {} \;
Search for files/directories which are writable by either their owner or their group </s> find . -perm /u+w,g+w
List all .jpg files in the home directory tree </s> find . -name "*.jpg" -exec ls {} \;
display all the regular files in current folder that belong to the user "tom" </s> find . -type f -user tom
Removes all files but 5 newest ones from current folder. </s> ls -tp | grep -v '/$' | tail -n +6 | tr '\n' '\0' | xargs -0 rm --
Replace all occurrences of "foo_fn" with "bar_fn" in the files named "foo_fn" from the current directory tree </s> find . -name foo_fn exec sed -i s/foo_fn/bar_fn/g '{}' \;
Print yesterday's date information in "%a %d/%m/%Y" format </s> date -d "-1 days" +"%a %d/%m/%Y"
Find writable files in the current directory tree </s> find . -writable
Make 3 directories named "$HOME/Labs/lab4a/folder" followed by a 3 width zero padded number from 1 to 3 </s> mkdir $(seq -f "$HOME/Labs/lab4a/folder%03g" 3)
search for all the jpg files in the folder "/mnt/hda1/zdjecia/test1/" and copy these files to the folder  /mnt/hda1/test/<same name as the found file> </s> find /mnt/hda1/zdjecia/test1/ -iname “*.jpg” -type f -exec cp {} -rv /mnt/hda1/test{} ‘;’
Add cron lists from "filename" to list of cron jobs, giving errors for any lines that cannot be parsed by crontab. </s> crontab filename
Rename all .png files, changing the string "_h.png" into "_half.png". </s> rename 's/_h.png/_half.png/' *.png
Make directories to "$2" as needed </s> mkdir -p $2
Save the user name of the current user to variable "x" </s> x=$(whoami)
Calculate the md5 checksum of the current directory structure and save it in variable SUM </s> SUM=$(tree | md5sum)
Creates temporary directory in '/tmp/' folder and saves path to it in 'my_tmp_dir' variable. </s> my_tmp_dir=$(mktemp -d --tmpdir=/tmp)
Set shell option 'checkwinsize'. </s> shopt -s checkwinsize
Print a welcome message with the current user's user name </s> echo -ne "Welcome $(whoami)!\n"
Prints file.txt without the last N bytes </s> head -c -N file.txt
search for a word in all the files in the entire filesystem and display the matched fline along with the file name </s> find / -type f -exec grep -Hi 'the brown dog' {} +
find all directories in the current directory </s> find . -type d -name "*"
Unzip and untar "tarball.tar.gz" </s> zcat tarball.tar.gz | tar x
Search for 'magic' in all regular files under current directory tree </s> find . -type f | xargs grep "magic"
Calculate the md5 sum of "yourstring" </s> echo -n "yourstring" |md5sum
search for al cpp files in current folder and display unique parent directory of these files in sorted order </s> find . -name "*.cpp" -exec dirname {} \; | sort -u
Find all files matching "abc*" in the current directory and append "\tok" </s> find . -name 'abc*' | sed 's/$/\tok/' | column -t
Create an empty file in each directory named "mydir" under current directory. </s> find . -type d -name "mydir" -print |  sed 's/$/\/abc.txt/g' | xargs touch
find the type & description of all the regular/normal files in the home folder </s> find /home -type f -print0 | xargs -0 file
Search the current directory tree for files whose names do not end in ".exe" and ".dll" </s> find . -not -name "*.exe" -not -name "*.dll" -type f
Print lines 347340107 through 347340206 in "filename" </s> tail -n +347340107 filename | head -n 100
Find recursively regular files in the current directory tree </s> find -type f -print0
Find all files under current directory and change their permission to 644 </s> find . -type f -exec chmod 644 {} \;
Move each of the directories in /path/to/folders/* to another directory whose name is constituted by appending .mbox to each directory name and create a directory named Messages in this directory then move all *.emlx files into this directory </s> find /path/to/folders/* -type d  -exec mv {} {}.mbox \; -exec mkdir {}.mbox/Messages \; -exec sh -c "mv {}.mbox/*.emlx {}.mbox/Messages" \;
Print the grand total file system disk space usage with block sizes in units of TiB </s> df --total -BT | tail -n 1
display all the files in the current folder that are at least one week old (7 days) but less then 30 days old </s> find . -mtime +30 -a -mtime -7 -print0
SSH into "myhost.com" as user "myname" with a check every 60 seconds that the server is still alive </s> ssh -o ServerAliveInterval=60 myname@myhost.com
display all files in the current folder along with their last accessed timestamps </s> find . -printf "%h/%f : dernier accès le %AA %Ad %AB %AY à %AH:%AM:%AS\n"
Verbosely compresses all files on seventh and eighth depth level keeping original files in place. </s> bzip2 -kv */*/*/*/*/*/*/*
Find all directories under maximum 1 level down the current directory and set their permission to 700 </s> find . -mindepth 1 -type d | xargs chmod 700
Enables shell options 'extglob' and 'progcomp' </s> shopt -s extglob progcomp
find not case sensitive all directories that names are 'apt' </s> find  / -type d -iname "apt"
Remove all *.sql files in the $backup_path directory tree that were last modified more than 30 days ago </s> find $backup_path/* -name *.sql -mtime +30 -exec rm {} \;
Show the list of files that are not owned by user wnj or are not newer than file `ttt' </s> find / \! \( -newer ttt -user wnj \) -print
find all text files in user/directory/ and display the last line </s> find /user/directory/* -name "*txt" -mtime 0   -type f -exec awk '{s=$0};END{print FILENAME, ": ",s}' {} \;
Search for first match of the case insensitive regex 're' in all *.coffee files under current directory </s> find . -name \*.coffee -exec grep -m1 -i 're' {} \;
search for the file filename in the entire file system </s> find / -name filename
recursively change owner of the directory /usr/local/lib to the current user </s> sudo chown -R `whoami` /usr/local/lib
Find files owned by nonexistent users </s> find / -nouser -print
find all files with the first letter “e” or “f” and last one x in /usr/bin directory: </s> find /usr/bin -name [ef]*x
Recursively removes all files like '*.pyc' in a current folder. </s> rm `find . -name \*.pyc`
find all the text files in the current folder starting with "somefiles-" </s> find . -name "somefiles-*-.txt" -type f
Go to directory /cygdrive/c/Program Files (x86) using quotes to escape special characters </s> cd "/cygdrive/c/Program Files (x86)"
search for the pattern in all the regular/normal files in the entire file system </s> find / -type f -print0 | xargs -0 grep -i pattern
Find symbolic links in /usr/sbin and /usr/bin to files whose pathnames end in "*/systemctl" </s> find /usr/sbin /usr/bin -lname "*/systemctl"
Save IP address of your SSH session in variable "WORKSTATION" </s> WORKSTATION=`who -m|awk '{print $5}'|sed 's/[()]//g'`
find the file with inode $inum under the current directory and delete it </s> find . -inum $inum -exec rm {} \;
Move all files from the `sourceDir' directory tree to the `destDir' directory </s> find sourceDir -mindepth 1 -exec mv "{}" --target-directory=destDir \;
Find all .java files whose name contains "Message" </s> find . -print | grep '.*Message.*\.java'
find all the text files present in the current directory excluding the search in certain paths. </s> find . -type f -name "*.txt" ! -path "./Movies/*" ! -path "./Downloads/*" ! -path "./Music/*"
Find all files/directories under /proc and run ls command on each. </s> find /proc -exec ls '{}' \;
Count the *.html files residing in the /usr/src directory tree and containing string "foo" </s> find /usr/src -name "*.html" -exec grep -l foo '{}' ';' | wc -l
Display hostname. </s> uname -n
Open a session-less connection to 'host' as user 'user' in master mode with a socket "/tmp/%r@%h:%p" to enable connection sharing </s> ssh user@host -M -S /tmp/%r@%h:%p -N
find all the empty files and folders in your system </s> find / -empty
Find the first file/directory in ... directory and quit </s> find ... -print -quit
Request A record from nameserver $ns for domain name $d, filter strings with domain name and exclude lines matching 'DIG' </s> dig @$ns $d A | grep $d | grep -v "DiG"
Cuts off last two parts from the path $dir, and deletes resulted folder if empty. </s> rmdir "$(dirname $(dirname $dir))"
Shuffles strings of text received by 'awk' command on the input. </s> awk 'BEGIN{srand();} {printf "%06d %s\n", rand()*1000000, $0;}' | sort -n | cut -c8-
Find all files under $dir </s> find $dir -type f
display all normal/regular files in current folder which have readable permission </s> find . -type f -readable
find all the zip files in the current folder and create a tar ball of these zip files </s> find . -type f -name '*.zip' -print0 | xargs -0 tar -xzf
Find all directories named build under the current directory </s> find . -type d -name build
Display a long listing of all the files/directories under current directory tree that are newer than the file 'Nov' by modification time </s> find . -newer Nov -ls
Count all directories under current directory </s> find . -type d -exec ls -dlrt {} \; | wc --lines
Find directories in the current directory (no sub-directories) and print them appended with a string literal 'Directory: ' </s> find . -maxdepth 1 -type d -print | xargs  -I "^" echo Directory: "^"
Find all *.plist files/directories under current directory </s> find . -name \*.plist
Extract 8 bytes as an unsigned integer that is "$o" offset into "$rpm" </s> set `od -j $o -N 8 -t u1 $rpm`
Find all 755 permission regular files under current directory tree </s> find . -type f -perm 755
find all the files ending with ".sh" in the folder /dir excluding those wth the names foo and bar. </s> find /dir \( -name foo -prune \) -o \( -name bar -prune \) -o -name "*.sh" -print
Search the entire file hierarchy for files larger than 100 megabytes and delete them. </s> find / -size +100M -exec /bin/rm {} \;
List all *.c files in entire file system </s> find / \! -name "*.c" -print
display all normal/regular files in current folder in sorted order </s> find . -type f print0 | sort -r
Find directories named `build' </s> find . -type d -name build
find all the files in the file system which are bigger than 3 bytes </s> find / -size +3 -print
find all normal/regular files in current folder which end with "~" or which begin and end with "#" and and and delete them </s> find . -maxdepth 1 -type f -name '*~' -delete  -or -name '#*#' -delete
Find files under [directory] that match 'pattern_to_INCLUDE' in their names without descending into directories that match 'pattern_to_exclude' and 'another_pattern_to_exclude', then search for 'pattern' in those files </s> find [directory] -name "pattern_to_exclude" -prune -o -name "another_pattern_to_exclude" -prune -o -name "pattern_to_INCLUDE" -print0 | xargs -0 -I FILENAME grep -IR "pattern" FILENAME
display all files in the current folder which end with extension "myfile" followed by two digits </s> find . -regex '.*myfile[0-9][0-9]?'
Find all files/directories with space in their names under current directory and rename them by replacing all spaces with _ </s> find . -depth -name "* *" -execdir rename "s/ /_/g" "{}" \;
Attempt to connect as root via ssh to host "IP" and copy /root/K to local machine, passing option "StrictHostKeyChecking=no" to the ssh backend - this will normally fail because ssh servers by default don't (and shouldn't) accept root logins. </s> scp -o StrictHostKeyChecking=no root@IP:/root/K
Find all directories under and below /home/admin/public_html/, and change their permissions to 755 </s> find /home/admin/public_html/ -type d -exec chmod 755 {} \;
Find all files/directories named 'document' in maximum 4 levels down the '/usr' directory </s> find /usr -maxdepth 4 -name document -print
find files in the /usr/src directory with pattern` *.c  that larger than 100 Kilobytes </s> find /usr/src -name '*.c' -size +100k -print
display all the files in the current folder which have been modified in the last 24 hours </s> find . -mtime -1
display all files in the current folder which start with met </s> find -name met*
Silently read $char number of symbols from file descriptor 4, without backslash escaping, and store received input in 'line' variable </s> read -u 4 -N $char -r -s line
display all php,xml and phtml files in current folder </s> find . -name '*.php' -o -name '*.xml' -o -name '*.phtml'
Find all directories name nasa in the current directory and below. </s> find . -name nasa -type d
List files ending in .html and residing in the current directory tree </s> find . -name "*.html"
find all the files that have been modified in the last 2 days </s> find . -type f -daystart -mtime -2
List all empty files in the current directory tree </s> find . -empty -exec ls {} \;
Find files/directories that are owned by the user 'syslog' in entire filesystem </s> find / -user syslog
create a backup of all the files in the current folder excluding those that are present in the .snapshot sub directory and excluding the swap files (files ending with  ~) </s> find . -name .snapshot -prune -o \( \! -name *~ -print0 \) | cpio -pmd0 /dest-dir
Decompress and extract '/usr/src/redhat/SOURCES/source-one.tar.gz' </s> gzip -dc /usr/src/redhat/SOURCES/source-one.tar.gz | tar -xvvf -
Search all non-hidden files in the current directory and all non-hidden sub-directories for the file hi.dat. </s> find *-name hi.dat
Merge already sorted files "*.txt" and split the result into files of at most 1000000 lines each with a numeric suffix and a prefix "output" </s> sort -m *.txt | split -d -l 1000000 - output
Find all regular files that reside in the current directory tree and were last modified more than 4 days ago </s> find . -type f -mtime +4
Read a line from standard input into variable "prompt" with the prompt "Are you sure you want to continue? <y/N> " </s> read -p "Are you sure you want to continue? <y/N> " prompt
Make directories to "$TARGET_PATH" as needed without causing an error if it exists </s> mkdir -p "$TARGET_PATH"
Search the /myfiles directory tree for files whose names contain "blue" </s> find /myfiles -name '*blue*'
Recursively search for all regular files below directory "dir1" in currentd directory, and output the name of each, without any containing directories. </s> find ./dir1 -type f -exec basename {} \;
display all the text files in the current folder  and do not search in the bin directory </s> find . -name bin -prune -o -name "*.txt" -print
Locate the httpd.conf file on the system </s> find / -name httpd.conf
Numerically sort standard input by the second word of each line </s> sort -n -k 2
Records the number of occurences of 'needle' in the array 'haystack' into the variable 'inarray' </s> inarray=$(echo ${haystack[@]} | grep -o "needle" | wc -w)
Count and show the number of lines for each PHP files in the current directory tree </s> find . -name '*.php' | xargs wc -l
Copy the directory structure in "src/" to "dest/" with empty files </s> find src/ -type d -exec mkdir -p dest/{} \; -o -type f -exec touch dest/{} \;
display all the files having spaces in the current folder </s> find . -name "filename including space" -print0
Create directory dir2 </s> mkdir dir2
Find all files/directories under current directory tree whose paths match the pattern '*ACK*1'  (case insensitive) </s> find . -iwholename "*ACK*1"
Display "/tmp/file" as a table of width 30 with columns filled before rows </s> column -x -c 30 /tmp/file
Remove all files and directories called "test" from the current directory tree </s> find . -name test -exec rm {} \;
get the root access </s> sudo su
Deletes folder like /tmp/*/* or deeper, older than +7 days if they don`t contain files or other folders. </s> find /tmp/*/* -mtime +7 -type d -exec rmdir {} \;
Print the paths of all files in the current directory tree that contain "abc" replacing "abc" with "xyz" </s> find . |xargs grep abc | sed 's/abc/xyz/g'
recursively change owner and group of the directory and all files into it to user "user" and group "www-data" </s> chown -R user:www-data yourprojectfoldername
display all the text files in the temp folder </s> find /tmp -name *.txt
display the name and size of all the regular/normal files  in the current folder which are bigger than 50MB </s> find . -type f -size +50000k -exec ls -lh {} \; | awk '{ print $9 ": " $5 }'
Find all 50MB files in file system </s> find / -size 50M
display all the html files in the current folder excluding search in the path ./foo </s> find . -path "./foo" -prune -o -type f -name "*.html"
Make "bar" executable </s> chmod +x bar
Find all index.* files/directories under current directory </s> find -name 'index.*'
find the oldest normal file in the current directory and display with its timestamp </s> find ! -type d -printf "%T@ %p\n" | sort -n | head -n1
Find all *.ps files under $STARTDIR </s> find $STARTDIR -name '*.ps' -print
display a list of all regular/normal files in the current folder </s> find . -type f -ls
find not case sensitive all directories that names are 'project.images' </s> find  / -type d -iname "project.images" -ls
Find all *.py files/directories under current directory </s> find . -name \*.py -print
Find files/directories modified within the last hour under current directory </s> find . -mtime -1
find all files with pattern` '*.mp3' and send output into nameoffiletoprintto file </s> find / -name *.mp3 -fprint nameoffiletoprintto
change the permissions of all the directories to 755 in the folder "/home/nobody/public_html" </s> find /home/nobody/public_html -type d -exec chmod 755 {} \;
Find all *shp* directories under current directory and move their contents to ../shp_all/ </s> mv $(find . -name "*shp*" -printf "%h\n" | uniq)/* ../shp_all/
Wrap each line in "file.txt" to fit in 80 characters </s> cat file.txt | fold
display all the files ending with ".foo" excluding those that are in the directory ".snapshot" </s> find . -name .snapshot -prune -o -name '*.foo' -print
find all the files ending with "clj" in the current folder and search for a pattern </s> find . -name '*.clj' -exec grep -r resources {} \;
Split a file ADDRESSS_FILE into pieces per 20 lines named with prefix "temp_file_ and numeric suffixes </s> split -l20 ADDRESSS_FILE temp_file_
List all leaf directories (directories which don't contain any sub-directory) under current directory </s> find -depth -type d |sed 'h; :b; $b; N; /^\(.*\)\/.*\n\1$/ { g; bb }; $ {x; b}; P; D'
Reports count of characters in the value of ${FOO} variable as follows:  "length(FOO)==<counted number of characters>" </s> echo -e "length(FOO)==$(echo -ne "${FOO}" | wc -m)"
Prints total number of lines of all *.php files in a current folder and subfolders. </s> cat `find . -name "*.php"` | wc -l
list all the files in the file system excluding proc folder and excluding symbolic links which have write permission for the user </s> find / -path /proc -prune -o -perm -2 ! -type l -ls
Replace all the mathes to regex '<script type="text\/javascript" charset="utf-8" src="file.js"><\/script>.*' with '<script type="text\/javascript" charset="utf-8" src="file2.js"><\/script>' in all HTML files under $DIR directory tree modifying the files in-place </s> find $DIR -type f -name '*.html' -exec sed -i 's/.*<script type="text\/javascript" charset="utf-8" src="file.js"><\/script>.*/<script type="text\/javascript" charset="utf-8" src="file2.js"><\/script>/g' {} \;
Find all php files in the current directory </s> find . -type f -name "*.php"
List all unique parent directories of .class files found under the current directory </s> find -name '*.class' -printf '%h\n' | sort -u
Prints process tree with command line arguments of a process having id $PID. </s> pstree -a "$PID"
Change mode of all files ending with ".php" under the current folder to 755 and write the output to the console and "logfile.txt" file </s> find . -name '*.php' -exec chmod 755 {} \; | tee logfile.txt
Find all files/directories under '/home/exampleuser/' directory tree whose names end with 'conf' and were modified exactly 3 days ago </s> find /home/exampleuser/ -name "*conf" -mtime 3
Forcefully remove files *~important-file </s> rm -rf *~important-file
search for all the perl files in the folder /nas/projects/mgmt/scripts/perl which have been modified 8-10 days ago. </s> find /nas/projects/mgmt/scripts/perl -mtime 8 -mtime -10 -daystart -iname "*.pl"
remove all the files in the present directory which have space in their name. </s> find . -name "* *" -exec rm -f {} \;
find all files and directories that have been modified in the last seven days </s> find . -mtime -7
Show all values (without the names) of variables whose name or value contains "VARIABLE_NAME" </s> set | grep VARIABLE_NAME | sed 's/^.*=//'
Find all files/directories under current directory which have read-write permission for owner and only read permission for group and others </s> find -perm -644
Print a tab separated table in "table.txt" with cell borders </s> sed -e 's/\t/_|/g' table.txt |  column -t -s '_' | awk '1;!(NR%1){print "-----------------------------------------------------------------------";}'
Find directories in the current directory tree that were modified within the last 24 hours and move them to /path/to/target-dir </s> find . -depth -type d -mtime 0 -exec mv -t /path/to/target-dir {} +
Move all files/directories under current directory to destDir </s> find sourceDir -print0 | xargs -0 mv -t destDir
Find all files/directories named 'articles.jpg' under current directory tree </s> find . -name "articles.jpg"
force delete all the files that have been modified in the last 3 days </s> find . -mtime -3 -exec rm -rf {} \;
Gets string with MAC address of eth0 network interface. </s> ifconfig eth0 | grep HWaddr
remove all the files with the name "Trash" in the folder /home </s> find /home -name Trash -exec rm {} \;
Change all files in "~" which are owned by the group "vboxusers" to be owned by the user group "kent" </s> find ~ -group vboxusers -exec chown kent:kent {} \;
Print the files in the current directory as a list of comma separated values </s> ls -1 | tr '\n' ',' | sed 's/,$/\n/'
Create hard links of all files and directories matching "test/icecream/cupcake/*" or "test/mtndew/livewire/*" in "test-keep" preserving directory hierarchy </s> find test -path 'test/icecream/cupcake/*' -o -path 'test/mtndew/livewire/*' | cpio -padluv test-keep
Move all files that contain "Subject: \[SPAM\]" to "DIR" </s> grep -L -Z -r 'Subject: \[SPAM\]' . | xargs -0 -I{} mv {} DIR
Remove all files on the system that have been changed within the last minute </s> find / -newerct '1 minute ago' -print | xargs rm
Replace all sequence of 'blank' characters in file 'log' with a single occurence of such symbol and print space-separated fields of each string but first two fields </s> cat log | tr -s [:blank:] |cut -d' ' -f 3-
Changes group ownership of 'target_directory' to 'target_group'. </s> chgrp target_group target_directory
Find all directories that do not contain "main.cpp" </s> diff <(find . -exec readlink -f {} \; | sed 's/\(.*\)\/.*$/\1/' | sort | uniq) <(find . -name main.cpp  -exec readlink -f {} \; | sed 's/\(.*\)\/.*$/\1/' | sort | uniq) | sed -n 's/< \(.*\)/\1/p'
search for all the files in the current directory which have the name a.out or core or which end with .o and delete them. </s> find . \( -name a.out -o -name '*.o' -o -name 'core' \) -exec rm {} \;
search for directories in the folder "test" which end have 5 digits as their name </s> find ./test -type d -name '[0-9][0-9][0-9][0-9][0-9]'
create a tar of all png & jpg images in the current folder </s> find . \( -iname "*.png" -o -iname "*.jpg" \) -print -exec tar -rf images.tar {} \;
display all instances  of the file tkConfig.sh in the folder /usr </s> find /usr -name tkConfig.sh
Remove all directories called "test" from the /path/to/dir directory tree </s> find /path/to/dir -name "test" -type d -delete
Gets list of IP addresses of all network interfaces. </s> ifconfig | sed -En 's/127.0.0.1//;s/.*inet (addr:)?(([0-9]*\.){3}[0-9]*).*/\2/p'
Search the files residing in the current directory tree whose names contain "bills" for "put" </s> find . -name "*bills*" -print0 | xargs -0 grep put
Find all regular files in the current directory tree and print a command to move them to the current directory </s> find . -type f -exec echo mv -t . {} +
Compare "$source_file" and "$dest_file" line by line </s> diff "$source_file" "$dest_file"
Recursively removes all files in a current folder but '*txt' files. </s> find . -type f -not -name '*txt' | xargs rm
convert epoch second timestamp to date </s> date -d @1278999698 +'%Y-%m-%d %H:%M:%S'
Find all files named 'Makefile' in the /usr/ports directory tree and count the number of lines in them beginning with USE_RC_SUBR </s> find /usr/ports/ -name Makefile -exec grep ^USE_RC_SUBR '{}' '+' | wc -l
Get the directory with least access time under current directory </s> find . -type d -printf "%A@ %p\n" | sort -n | tail -n 1 | cut -d " " -f 2-
Print the IP address of your SSH session </s> who am i|awk '{ print $5}'
Find all php files in current directory and delete lines matching the regex '<\?php \/\*\*\/eval(base64_decode(.*));.*\?>' in those files </s> find . \( -name "*.php" \) -exec grep -Hn "<\?php /\*\*/eval(base64_decode(.*));.*\?>" {} \; -exec sed -i '/<\?php \/\*\*\/eval(base64_decode(.*));.*\?>/d' {} \;
Read a line from standard input into variable "message" with prompt "Please Enter a Message: " followed by a newline </s> read -p "`echo -e 'Please Enter a Message: \n\b'`" message
Delete all files/directories taken by the glob pattern * except the ones with the name 'b' </s> find * -maxdepth 0 -name 'b' -prune -o -exec rm -rf {} \;
find all the files in the entire file system that start with top </s> find / -name 'top*'
find md5sum of string 'hi' </s> echo -n hi | md5
Silently read a single character from standard input into variable "key" without backslash escapes and using the prompt $'Press any key to continue...\n' </s> read -rsp $'Press any key to continue...\n' -n 1 key
Find all files under current directory and change their permission to 600 </s> find . -type f -exec chmod 600 {} \;
Replace "version.old" with "version.new" in the symbolic link target of "SomeLibrary" </s> ln -f -s -T `readlink SomeLibrary | sed 's/version.old/version.new/'` SomeLibrary
Find all directories named "D" in the current directory tree and print their parents </s> find ./ -type d -name 'D'|sed 's/D$//'
Mount "cpuset" filesystem on "/cpuset/" </s> mount -t cpuset none /cpuset/
Search for environmental variables with "HIST" in their name or contents </s> set | grep HIST
remove all files that's older than 30 days in '/tmp' </s> find /tmp -type f -mtime +30 -exec rm -f {} \;
Print each logged in user's username and full name </s> finger -l | grep "Name:" | tr -s ' ' | cut -d " " -f 2,4- | sort | uniq
Find all files/directories with '.txt' extension under '/home' directory tree that are exactly 100KB in size </s> find /home -name "*.txt" -size 100k
Find all the files/directories under '/var/adm' directory tree that have not been modified in the last 3 days </s> find /var/adm -mtime +3 -print
Find recursively all files in the "." directory tree whose names end with ".class" and delete them </s> find . -type f -name "*.class" -exec rm -vf {} \;
display all the files in the home folder which have not been modified in the last 365*24 hours </s> find $HOME -mtime +365
Find all files under current directory that were modified more than 7 days ago and delete them </s> find . -type f -mtime +7 -print0 | xargs    -0 rm
Answer "y" to any prompts in the interactive recursive removal of "dir1", "dir2", and "dir3" </s> yes y | rm -ir dir1 dir2 dir3
print disk usage of files or folders in current directory </s> du -sh *
Add '.avi' extension to all files/directories with '.mkv' extension under '/volume1/uploads' directory tree </s> find /volume1/uploads -name "*.mkv" -exec mv \{\} \{\}.avi \;
Print environment variable "IFS" and its value </s> set | grep ^IFS=
Find all *.axvw files/directories under current directory </s> find . -name '*.axvw'
Copy the entire contents of the current directory preserving ownership, permissions, and times </s> find . | cpio -pdumv /path/to/destination/dir
Execute the file utility for each file found under /etc and below </s> find /etc -print0 | xargs -0 file
Send SIGTERM signal to first process sent to background by the current shell. </s> kill %1
Prints calendar of February, 1900. </s> cal 2 1900
Finds strings having text "searched-string" in all files recursively in a current folder. </s> find . | xargs grep "searched-string"
Numerically sort each line of standard input </s> sort -n
Copy a file xyz.c to all directories or over all files matching the letter 'c' at the end of their names under current directory tree </s> find . -name "*c" -print0 | xargs -0 -n1 cp xyz.c
Open "charm" executable file in vim </s> sudo vim `which charm`
Find all *.epub, *.mobi, *.chm, *.rtf, *.lit and *.djvu files/directories under current directory </s> find ./ -name '*.epub' -o -name '*.mobi' -o -name '*.chm' -o -name '*.rtf' -o -name '*.lit' -o -name '*.djvu'
Search all files in the current directory tree that are named "whatever" for "you_search_for_it" </s> find -name whatever -exec grep --with-filename you_search_for_it {} \;
Find files that end in ".gz" and execute "awk -F, '$1 ~ /F$/'" on their unzipped contents </s> find . -maxdepth 1 -name \*.gz -print0 | xargs -0 zcat | awk -F, '$1 ~ /F$/'
View history using "vim" </s> history | vim -
List all files in the "test" directory tree except those with '/invalid_dir/' in the pathnames </s> find test -print | grep -v '/invalid_dir/'
Write the shell's input to standard error as it is read </s> set -v
List all directories of the $topdir directory tree that contain a Makefile and at least one .py file </s> find "$topdir" -name '*.py' -printf '%h\0' | xargs -0 -I {} find {} -mindepth 1 -maxdepth 1 -name Makefile -printf '%h\n' | sort -u
show all the files in the entire file system which are bigger than 100MB </s> find / -size +100M
Print the list of files changed within the last minute </s> find / -newerct '1 minute ago' -print
Find all files in the current directory recursively with "linkin park" in their names and copy them to /Users/tommye/Desktop/LP, preserving path hierarchy </s> find . -type f -iname "*linkin park*" | cpio -pvdmu /Users/tommye/Desktop/LP
split compressed content of the directory /home into pieces per 4000 mb named as  "/media/DRIVENAME/BACKUPNAME.tgz.NNN" </s> tar --one-file-system -czv /home | split -b 4000m - /media/DRIVENAME/BACKUPNAME.tgz
Force create a symbolic link to "$f" in "~/my-existing-links/" with name the basename of "$f" </s> ln -sf "$f" "~/my-existing-links/$(basename $f)"
Move all files matching patterns "*.old", ".old", ".*.old" from the current directory to directory "../old/" </s> find . ! -name . -prune -name '*.old' -exec mv {} ../old/ \;
search for all the files which have not been modified in the last 6 months (180 days) in current folder and display the total disk usage of them </s> find . -mtime +180 -exec du -ks {} \; | cut -f1 | awk '{total=total+$1}END{print total/1024}'
find all the swap files (files ending with ~) in the current folder and delete them </s> find . -name "*~" -delete
Read a line of standard input with prompt "My prompt: " and save it to variable "varname" </s> read -e -p "My prompt: " varname
Sets shell options 'globstar' and 'nullglob'. </s> shopt -s globstar nullglob
Print numbers from 1 to 5 without separating spaces </s> seq 5 | awk '{printf "%s", $0} END {print ""}'
Remove all vmware-*.log files under current directory </s> find . -name vmware-*.log | xargs rm
Write '"myname="Test"' to the console and append to "$CONFIG" as root </s> echo "myname=\"Test\"" | sudo tee --append $CONFIG
Read a line from standard input into variable "message" with escaped prompt "Please Enter a Message: \n\b" </s> read -p "$(echo -e 'Please Enter a Message: \n\b')" message
Find all regular files under current directory </s> find . -depth -type f -print
Print second section of data coming from stdin where sections are separated by one or more whitespace. </s> tr -s ' ' | cut -d ' ' -f 2
Sort content of files 'file1' and 'file2' by second of dot-separated fields. </s> cat file1 file2 |sort -t. -k 2.1
Prints long listing of file 'file.ext'. </s> ls -al file.ext
Print only common file names in sorted listings of directory 'dir1' and 'dir2' </s> comm -1 -2 <(ls /dir1 | sort) <(ls /dir2 | sort)
display the type of all the regular/normal files in the entire file system </s> find / -type f -print | xargs file
Print '-okdir is an action so an implicit -print is not applied' for each file/directory found by the name 'file' under current directory tree </s> find -name file -okdir echo '-okdir is an action so an implicit -print is not applied' \;
Save long listing of all files listed in file 'filenames.txt' to 'listing' variable </s> listing=$(ls -l $(cat filenames.txt))
Count files in $DIR_TO_CLEAN that are older than $DAYS_TO_SAVE days </s> find "$DIR_TO_CLEAN" -mtime +$DAYS_TO_SAVE | wc -l
Find all .php files in the current directory tree </s> find . -type f -name "*.php"
Move all hidden files in "wordpress" to the current directory </s> mv wordpress/.* .
show all .cpp, .c, .h, .hpp files in the folder ~/src </s> find ~/src -type f \( -iname '*.cpp' -or -iname '*.h' -or -iname '*.c' -or -iname '*.hpp' \) -exec echo {} \;
Compare "fastcgi_params" and "fastcgi.conf" line by line, output 3 lines of unified context, and print the C function the change is in </s> diff -up fastcgi_params fastcgi.conf
Remove all directories in and below the current directory </s> find \! -name . -type d -print0 | xargs -0 rmdir
prints absolute file paths for files in current directory </s> find `pwd` -maxdepth 1
find directories under the $LOGDIR directory where there has been no modifications within the last 24 hours and compresses the files. </s> find $LOGDIR -type d -mtime +0 -exec compress -r {} \;
Find all directories under '/var/www' directory tree excluding '/var/www/web-release-data' and '/var/www/web-development-data' directories and their sub-directories </s> find /var/www -type d \( ! -wholename "/var/www/web-release-data/*"  ! -wholename "/var/www/web-development-data/*" \)
Search for files only that end with .php and look for the string $test inside those files </s> find . -name \*.php -type f -exec grep -Hn '$test' {} \;
Split "input.txt" into files of at most 10 bytes each with prefix "xxx/split-file" </s> split -b 10 input.txt xxx/split-file
Construction with additional '-exec true' to be used if both commands need to run regardless of their success or failure. </s> find . -name "*.txt" \( -exec echo {} \; -o -exec true \; \) -exec grep banana {} \;
Find files and directories modified in last 7 days </s> find . -mtime -7
find the count of text files that are present in the current working directory. </s> find . -maxdepth 1 -name \*.txt -print0 | grep -cz .
Remove all *.bak and *.backup files that were accessed last time more than 30 days ago </s> find . \( -name '*.bak' -o -name *.backup \) -type f -atime +30 -exec rm '{}' ';'
Print 'file' content, formatting output as 29-symbol wide column, regarding space symbol as a word separator </s> cat file | fold -s -w29
find all of the files that are readable </s> find / -readable
Force create a symbolc link named "new_dir" to "/other/dir" without dereferencing "new_dir" </s> ln -sfn /other/dir new_dir
search for the file picasso in the folder /home/calvin/ (case insensitive search) </s> find /home/calvin/ -iname “picasso”
delete all the tmp files ( files with the extension tmp ) in the /tmp folder </s> find /tmp -name "*.tmp" | xargs rm
Find files named "blabla" in the current directory tree and print the number of lines in each of them </s> find ./ -name "blabla" -exec wc -l {} ;
Change permissions of "/usr/bin/wget" to 777 </s> chmod 777 /usr/bin/wget
list all files </s> find .
Move all directories in the current directory tree that have been modified in the last day to "/path/to/target-dir" </s> find . -type d -mtime -0 -exec mv -t /path/to/target-dir {} +
Recursively change the group ownership to "laravel" in "./bootstrap/cache" </s> sudo chown -R :laravel ./bootstrap/cache
Find all .rb files owned by root in the /apps/ folder and below that have been accessed in the last two minutes. </s> find /apps/ -user root -type f -amin -2 -name *.rb
Force create a symbolic link without dereferencing named "mylink" to "dir2" </s> ln -nsf dir2 mylink
Print fourth column of data from text file text.txt where columns separated by one or more whitespaces. </s> cat text.txt | tr -s ' ' | cut -d ' ' -f4
display long listing of all the empty files in the current folder </s> find . -empty -exec ls -l {} \;
Find and print the names of all files found in the current directory and all of its sub-directories. </s> find .
List files larger than 10MB in the /var directory recursively </s> find /var/ -size +10M -ls
Find all empty directories recursively starting from the current one and delete them </s> find . -type d -empty -delete
get all files in a current directory modified in the last 7 days </s> find . -mtime -7 -print0 | xargs -0 tar -cjf /foo/archive.tar.bz2
Find all directories under present working directory </s> find $PWD -type d
Change the owner and group of "testfile.txt" to "root" </s> sudo chown root:root testfile.txt
Interactively create a symbolic link in the current directory for "$SCRIPT_DIR/$FILE" </s> ln --symbolic --interactive $SCRIPT_DIR/$FILE
Find all pdf files under /dir/containing/unsigned with null character as the delimiter </s> find /dir/containing/unsigned -name '*.pdf' -print0
Continuously convert "20131202" into "2013 12 02" and print the result </s> yes a=\"20131202\" | sed -e :a -e 's/...\([0-9]\{4\}\)\([0-9]\{2\}\)\([0-9]\{2\}\)./\1 \2 \3/'
Removes all top-level *.pdf files in a current folder. </s> rm -f *.pdf
Find grub.conf files in entire file system </s> find / -name grub.conf
Find all files called wp-config.php in the /var/www directory and below </s> find /var/www/ -name wp-config.php
find all files in current folder using name patterns </s> find . -iregex ".*packet.*"
Search for "foo" in every file in the current directory and number the output </s> grep foo * | nl
Print the list of all regular files residing in the current directory and below </s> find ./ -type f -print
Compress every file in the current directory that matches "*cache.html" and keep the original file </s> gzip -k *cache.html
find case-insentive example.com file, omit ./beta path </s> find ./ -path ./beta/* -prune -o -iname example.com -print
Delete all empty files in the current directory tree </s> find . -type f -empty -delete
Find files/directories modified within the last day under /etc </s> find /etc -type f -ctime -1
find all java files in the current folder and search for the pattern REGEX </s> find . -name '*.java' -exec grep REGEX {} \;
List all the file links </s> find . -type l
Search the .java files from the current directory tree for TODO lines </s> find . -name "*.java" -exec grep -i -n TODO {}  \;
find for the word "dba_2pc_pending" in all the files of current fodler having the word "sql" in their name </s> find . -print|grep sql|xargs grep -i dba_2pc_pending
Print the sizes and names of all TXT files from the current directory tree </s> find . -iname "*.txt" -exec du -b {} +
find all the files in the current folder and display adding quotations to each file and replace spaces with new line </s> find $PWD -exec echo -n '"{}" ' \; | tr '\n' ' '
Locate all *.txt files in the current directory tree </s> find . -name "*.txt"
find all empty files </s> find / -empty
Find image files and move them to the pictures directory </s> find ~/Desktop -name “*.jpg” -o -name “*.gif” -o -name “*.png” -print0 | xargs -0 mv –target-directory ~/Pictures
Find all directories named "nasa" </s> find . -name nasa -type d
Reversibly sorts content of the '${TMP}/${SCRIPT_NAME}.pid' file, comparing human readable numbers in file strings. </s> cat ${TMP}/${SCRIPT_NAME}.pid|sort -rh;
Gets IP address of 'eth0' network interface. </s> ifconfig eth0 | grep inet | cut -d: -f2 | cut -d' ' -f1
Prints total number of lines of all *.c files in a current folder and subfolders. </s> find . -name '*.c' -print0 |xargs -0 wc -l|grep -v total|awk '{ sum += $1; } END { print "SUM: " sum; }'
Print source of the file system containing current working directory. </s> df . | tail -1 | awk '{print $1}'
Prints name of a current shell binary file. </s> ls -l /proc/$$/exe | sed 's%.*/%%'
Display only first and second dot-separated numbers of kernel version, ie. 4.4 </s> uname -r | cut -d. -f1-2
list broken symbolic links under "somedir" </s> find "somedir" -type l -print0 | xargs -r0 file | grep "broken symbolic" | sed -e 's/^\|: *broken symbolic.*$/"/g'
Search for the string 'git' in all the files under current directory tree excluding paths and names that contain the string 'git' </s> find . -not -path "*git*" -not -name '*git*' |grep git
list all regular files under the directory "$directory" </s> find $directory -type f -name '*'
Read a line of standard input with prompt "Enter your choice: " in an interactive shell and save the response to variable "choice" </s> read -e -p "Enter your choice: " choice
Find all files that belong to group developer </s> find /home -group developer
Print unique lines in "set1" and "set2" when compared to each other and remove any tabs </s> comm -3 <(sort set1) <(sort set2) | sed 's/\t//g'
Find all files/directories in all paths expanded by the glob pattern * </s> find *
Find all the regular files under $DIR directory tree which have been modified before the file $a excluding the file $a and delete them </s> find "$DIR" -type f \! -newer "$a" \! -samefile "$a" -exec rm {} +
Displays process tree of a process with id 'PID', showing parent process and processes id. </s> pstree -p -s PID
create a compressed archive with files newer than 1st of January 2014, 18:00:00. </s> tar -N '2014-02-01 18:00:00' -jcvf archive.tar.bz2 files
Forcibly removes ${temp} file. </s> rm --force "${temp}"
display the number of lines in all the ".c" files in the current folder </s> find . -name "*.c" -print | xargs wc -l
Find all files named "test2" in the current directory </s> find -name test2 -prune
Print the first line of output after alphabetically sorting the file "set" </s> head -1 <(sort set)
forcibly change owner to all files and directories in current directory to user www-data </s> sudo chown -Rf www-data *
Uncomment every entry in current user's cron job list which contains "test.sh" </s> crontab -l | sed '/# *\([^ ][^ ]*  *\)\{5\}[^ ]*test\.sh/s/^# *//' | crontab -
List each unique character in "file" prefixed by number of occurrences and sorted from most frequent to least frequent </s> grep -o . filename | sort | uniq -c | sort -nr
Display the number of sub-directories for all directories under current directory tree, sort them according to the decreasing order of the number and show only the first 10 of them </s> find . -type d -ls | awk '{print $4 - 2, $NF}' | sort -rn | head
Archive "/path/to/sfolder/" to "name@remote.server:/path/to/remote/dfolder" preserving hard links and compressing the data during transmission </s> rsync -aHvz /path/to/sfolder/ name@remote.server:/path/to/remote/dfolder
Enables shell option 'nocaseglob'. </s> shopt -s nocaseglob
find all the normal/regular files in the current directory and search for the word mail and display the file names </s> find . -type f -exec grep -il mail
Print a colon-separated list of all directories from the $root directory tree </s> find $root -type d -printf '%p:'
Give all files in the /path/to/base/dir tree read privileges </s> find /path/to/base/dir -type f -exec chmod 644 {} +
Find only permission field & file name from long listing with find command . </s> find -type f -iname "*.txt" -exec ls -lrt {} \;|awk -F' ' '{print $1  $9}'
Recursively remove all "*.txt" files and answer "n" to any prompt </s> yes n | rm -r *.txt
Delete files containing whitespaces without recursion </s> find . -name '*[+{;"\\=?~()<>&*|$ ]*' -maxdepth 0 -exec rm -f '{}' \;
Compare sorted files 'f1.txt' and 'f2.txt' and print in three columns strings unique for first file, second file, and common ones </s> comm <(sort -n f1.txt) <(sort -n f2.txt)
Print all file/directory names without white space safety under the /proc directory </s> find /proc | xargs
Add "execute" to the permissions of all directories in the home directory tree </s> find ~ -type d -exec chmod +x {} \;
search for a word in all the .C files in the current directory </s> find . -name "*.c" -exec grep -ir "keyword" {} ";"
sort and display top 11 files along with the last access date for all the files in the file system ( sort based on the timestamp ) </s> find / -type f -printf "\n%AD %AT %p" | head -n 11 | sort -k1.8n -k1.1nr -k1
Find files in the current directory tree whose names begin with "file" and whose size is 0, and remove them </s> find -name 'file*' -size 0 -delete
Print each line in parallel in files "tmp/sample-XXX.tim" and "tmp/sample-XXX.log" </s> paste tmp/sample-XXXX.{tim,log}
Find all directories under /myfiles directory </s> find /myfiles -type d
replace the word apple with orange in all the regular/normal files in the current folder </s> find ./ -type f -exec sed -i -e 's/apple/orange/g' {} \;
Remove duplicates in variable "variable" and preserve the order </s> variable=$(echo "$variable" | tr ' ' '\n' | nl | sort -u -k2 | sort -n | cut -f2-)
list all files in /home/bozo/projects directory tree that were modified exactly one day ago. </s> find /home/bozo/projects -mtime 1
find all files in home folder which have been modified after a timestamp </s> find ~ -newer /tmp/timestamp
find all the text files in current folder and force delete them </s> find . -name "*.txt" | xargs rm -rf
Find all directories under /path whose names are 33 characters long </s> find /path -type d -printf "%f\n" | awk 'length==33'
Search in the current directory and all sub-directories except ./D for the file named hi.dat. </s> find . \( -name D -prune \) -o -name hi.dat
Copy "src" to "dest" if "src" is newer than "dest" </s> rsync -u src dest
Find all directories in maximum 1 level down the current directory and remove the . entry from the output </s> find . -maxdepth 1 -type d | sed '/^\.$/d'
Places current job to background. </s> bg %  so it wont die when you logoff
display all directories in current folder </s> find -type d
Remove all libEGL* files from the current directory tree </s> find . -name libEGL* | xargs rm -f
Change directory to the "lib" directory located two parent directories above the path to command "perl" </s> cd $(dirname $(dirname $(which perl)))/lib
Search /usr, /home, /tmp for *.jar files </s> find /usr /home  /tmp -name "*.jar"
Save a comma separated list of all directories under current directory tree to variable 'FOLDER' </s> FOLDERS=$(find . -type d -print0 | tr '\0' ',')
Print fourth column of space-separated data from text file text.txt. </s> cat text.txt | cut -d " " -f 4
Search "inputfile" for lines starting with "t:" and group the results in files with at most 200 lines each </s> cat inputfile | grep "^t\:" | split -l 200
Finds file 'Subscription.java' and changes to containing folder. </s> cd $(find . -name Subscription.java | xargs dirname)
Find files/directories named 'somename.txt' under current directory tree </s> find ./ -name "somename.txt"
Print amount of space available on the file system containing path to the current working directory. </s> df $PWD | awk '/[0-9]%/{print $(NF-2)}'
Execute the file utility for each file found under /etc or below that contains "test" in its pathname </s> find /etc -print0 | grep -azZ test | xargs -0 file
Print a space separated list of numbers from 1 to 10 with no trailing new line </s> seq 10 | xargs echo -n
download contents from "https://raw.github.com/creationix/nvm/master/install.sh" and execute </s> curl https://raw.github.com/creationix/nvm/master/install.sh | sh
Case-insensitive search for "error" in file report.txt, display one page at a time, waiting for user interaction between each. </s> cat report.txt | grep -i error | more
Find all the files/directories in '/path/to/files' directory tree which have not been modified in the last 2 hours </s> find "/path/to/files" -mmin +120
display all the files in the current folder excluding the files with the name mmm </s> find . -name mmm -prune -o -print
Replace "  " with " $UID " in the output of "history" </s> history | sed "s/  / $UID /"
Find all the files without permission 777 in the file system </s> find / -type f ! -perm 777
Counts lines in each *.php file. </s> find . -name '*.php' -type f | xargs wc -l
Kill the processes of user `myuser' that have been working more than 7 days </s> find /proc -user myuser -maxdepth 1 -type d -mtime +7 -exec basename {} \; | xargs kill -9
Search the /home/bozo/projects directory tree for files modified within the last 24 hours </s> find /home/bozo/projects -mtime 1
Find all regular files that reside in the current directory tree and were last modified 1 day ago </s> find . -type f -mtime 0
Recursively finds all 'STATUS.txt' files containing text 'OPEN' and prints containing folder of them. </s> find -type f -name "STATUS.txt" -exec grep -q "OPEN" {} \; -exec dirname {} \;
Find all mysong.ogg files/directories under your home directory </s> find $HOME -name 'mysong.ogg'
Print each line that is found only once in "file1" and "file2" combined </s> sort file1 file2 | uniq -u
Create symlinks to all  /home/folder2/*.txt files with the same name in current directory </s> find /home/folder2/*.txt -type f -exec ln -s {} \;
find any files in the current directory that begin with a number </s> find . -regex './[0-9].*' -print
Verbosely compresses all files on third and fourth depth level keeping original files in place. </s> bzip2 -kv */*/*/*
find all the files that have not been modified in the last (24*7) hours. </s> find . -mtime +7
Find all *1234.56789* files/directories under current directory </s> find . -name '*1234.56789*'
Recursively removes all empty folders under current folder. </s> find -depth -type d -empty -exec rmdir {} \;
Search for all .mp3 files in the /mnt/usb directory tree </s> find /mnt/usb -name  "*.mp3" -print
Find files in the current directory tree which have permissions rwx for user and rw for group and others </s> find . -perm 766
Find recursively the latest modified file in the current directory </s> find . -type f -print0|xargs -0 ls -drt|tail -n 1
List regular files in current directory with read, write and execute permission for all users and also show the permissions </s> find . -type f  -perm 777 -exec ls -l {} \;
Search all .c files from the current directory tree for "keyword", ignoring the case </s> find . -name "*.c" -exec grep -i "keyword" {} ";"
Look for any instance of "ds1337" in the modules.alias file matching current kernel release </s> grep ds1337 /lib/modules/`uname -r`/modules.alias
Revert $string value and print first 20 space-separated fields </s> echo $string | rev | cut -d ' ' -f -20
Search the current directory tree for *cache, *xml, and *html files </s> find . -type f \( -name "*cache" -o -name "*xml" -o -name "*html" \)
Find files in entire file system that are writable by group or other </s> find / -perm /g=w,o=w
Executes tmux commands that are stored in the '$tmux_command' variable, and then attaches to the tmux session. </s> tmux "$tmux_command \; attach"
Gets MAC address of eth0 network interface. </s> ifconfig | grep -i hwaddr | cut -d ' ' -f9
Replace all ' ' with '-' from standard input </s> tr  ' ' '-'
Search for first match of the regex 're' in all *.coffee files under current directory </s> find . -name '*.coffee' -exec awk '/re/ {print;exit}' {} \;
Display differences between a and b side-by-side </s> diff -y a b
display a long listing of all the regular/normal files in the file system which have set uid bit or set gid bit enabled. </s> find / -type f \( -perm -4000 -o -perm -2000 \) -exec ls -l {} \;
display all the home folder which end with the extension "sxw" and which have been accessed in the last 3*24 hours and which belong to the user bruno </s> find /home -type f -name "*.sxw" -atime -3 -user bruno
display a long ilsting of all the files in the file system which are bigger than 1KB and which have not been modified in the last 30*24 hours </s> find / -size +1000 -mtime +30  -exec ls -l {} \;
Copies file '/boot/config-`uname -r`' to the  '.config', printing info message and prompting before owerwriting files. </s> cp -vi /boot/config-`uname -r` .config
Find the file with inode number 211028 in the current dirrectory tree and move it to newname.dir </s> find . -inum 211028 -exec mv {} newname.dir \;
Suffix all files and folders in the current directory with "_SUF" </s> ls | xargs -I {} mv {} {}_SUF
Exclude directory from find . command </s> find -iname example.com | grep -v beta
Copy directory hierarchy from "$sourceDir" to "$targetDir" </s> find "$sourceDir" -type d | sed -e "s?$sourceDir?$targetDir?" | xargs mkdir -p
Find files created in the last minute; works on Mac OS X </s> find / -newerct '1 minute ago' -print
Delete all .svn files/directories under current directory </s> find . -name .svn -exec rm -rf {} +
List files under current directory according to their size in descending order </s> find . -type f -exec ls -s {} \; | sort -n -r
Count the number of lines in each .java file in the current directory tree </s> find . -name "*.java" -exec wc -l {} \;
Search the current directory for files whose names start with "messages." ignoring SVN, GIT, and .anythingElseIwannaIgnore files </s> find . -type f -print0 | xargs -0 egrep messages. | grep -Ev '.svn|.git|.anythingElseIwannaIgnore'
Find all the .mp3 files in the music folder recursively and pass them to the ls command </s> find ./music -name "*.mp3" -print0 | xargs -0 ls
Find all files/directories under current directory that match the case insensitive extended regex .*/(EA|FS)_.* </s> find -E . -iregex '.*/(EA|FS)_.*'
Find all the files which were modified 50 days ago </s> find / -mtime 50
Find all directories under ${1:-.} directory without descending into any sub-directories </s> find ${1:-.} -mindepth 1 -maxdepth 1 -type d
Print file system disk space usage with a grand total </s> df --total
List all files under current directory matching the regex '.*(c|h|cpp)$' </s> find -E . -type f -regex '.*(c|h|cpp)$' -exec ls {} \;
Find all regular files whose names contain a case insensitive pattern composed of space separated positional arguments and display a long listing of them </s> find . -type f -iname '*'"$*"'*' -ls
Print a list of all the files in entire file system whose inode has been modified no later than one minute ago </s> find / -newerct '1 minute ago' -print
Find all files/directories starting with 'app-' and ending with '.log' in their names and have been modified in the last 5 minutes </s> find /var/log/crashes -name app-\*\.log -mmin -5
find all the direcories in the current folder </s> find -type d
Change to location of '$TARGET_FILE' file. </s> cd `dirname $TARGET_FILE`
Find all files called "INPUT.txt" in the current directory tree and remove lines starting with # in them, saving backup copies as INPUT.txt.bak </s> find . -type f -name INPUT.txt -print0 | xargs -0 -I file  sed -i.bak '/^#/d' file
Search the /home/sdt5z/tmp directory tree for files named "accepted_hits.bam" </s> find /home/sdt5z/tmp -name "accepted_hits.bam"
Print the contents of "n" </s> cat n
Compute the mean average of the word count of *.txt files in the home directory </s> find ~/ -name '*.txt' -print0 | xargs -0 wc -w | awk 'END { print $1/(NR-1) }'
display all the jpg files in the current folder which belong to the user nobody </s> find . -name *.jpg -user nobody
Print the column count of compressed file "$file" </s> zcat "$file" | awk '{print NF}' | head
Print the number of lines in file.txt. </s> wc -l file.txt | cut -f1 -d" "
Removes all empty folders under path '/foo/bar' and the path itself. </s> find /foo/bar -type d -depth -exec rmdir -p {} +
Find the current directory and all its subdirectories. </s> find . -type d
Creates alias for network interface 'eth0' with IP address '192.0.2.55' and network mask '255.255.255.255'. </s> ifconfig eth0:fakenfs 192.0.2.55 netmask 255.255.255.255
List ".java" files that have the same filename and contents </s> md5sum *.java | sort | uniq -d
Print the path names of all files and directories in the current directory tree </s> find -printf '"%h/%f" '
Search the current directory recursively for files last modified within the past 24 hours </s> find . -mtime 0
Find all files named "foo_bar" in the current directory recursively </s> find -name foo_bar
filter output of bind -p by regex </s> bind -p | grep -a forward
find for lighttpd in /var </s> find /var -name lighttpd
Prints process tree with command line arguments and process id numbers. </s> pstree -apl
search for the files "foo.txt" in the current folder and rename it to foo.xml </s> find -name foo.txt -execdir rename 's/\.txt$/.xml/' '{}' ';'
Ping the broadcast address "10.10.0.255" </s> ping -b 10.10.0.255
Read a line from standard input with prompt "Is this a good question (y/n)? " and save the response to variable "answer" </s> read -p "Is this a good question (y/n)? " answer
Change owner to "root" and group to "dockerroot" of "/var/run/docker.sock" </s> sudo chown root:dockerroot /var/run/docker.sock
set a crontab to create or update the timestamp of "washere2" in the current directory every 30 minutes. </s> echo "30 * * * * touch $(pwd)/washere2" | crontab
Shows only process trees rooted at processes of this user. </s> pstree user
Remove all files with the .c extension in the current directory tree </s> find . -name "*.c" | xargs rm -rf
display all the files in the current folder which are present in the path "./src/emacs" </s> find . -path './src/emacs' -prune -o -print
create symbolic links in directory "/usr/local/symlinks " to all files located in directiry "incoming" and that have been modified earlier then 5 days and owned by user "nr" </s> find /incoming -mtime -5 -user nr -exec ln -s '{}' /usr/local/symlinks ';'
Find all files named 'new' under current directory tree and display their contents </s> find . -name new -print -exec cat {} +
display a long listing of all the java files in the current folder in sorted order </s> find . -type f -name '*.java' -ls | sort -k +7 -r
Save the first "." separated field of the system host name to variable "HOSTZ" </s> HOSTZ=$( hostname | cut -d. -f1 )
Copy all files in current directory that do not match */not-from-here/* in their names to /dest </s> find . -type f -not -iname '*/not-from-here/*' -exec cp '{}' '/dest/{}' ';'
File "files.txt" contains a list of files, copy all files listed to host "remote", connecting as ssh user "user", and copying the files to this user's home directory - this will not work with files/directory names containing spaces. </s> cat files.txt | xargs scp user@remote:
find files which modification time is  one day ago </s> find . -mtime 1
Recursively removes all files like "(__pycache__|\.pyc|\.pyo$)" in a current folder. </s> find . | grep -E "(__pycache__|\.pyc|\.pyo$)" | xargs rm -rf
Enables shell option 'histappend'. </s> shopt -s histappend
Find regular files in the current directory tree that have executable bits set for the user and group but not for the other </s> find -L . -type f -perm -u=x,g=x  \! -perm -o=x
Join data in file1 containing one number per line with data in file2 containing a number and other information per line, keeping the same order as it is found in file1. </s> join -1 2 -2 1 -a1 <(cat -n file1.txt | sort -k2,2) <(sort file2.txt) | sort -k2 | cut --complement -d" " -f2
Search the current directory recursively for files with the exact permissions u=rwx,g=rx,o=rx </s> find . -perm u=rwx,g=rx,o=rx
List all non-empty files under under current directory </s> find . -type f ! -size 0
Split "INPUT_FILE_NAME" into files of at most 500 MiB each with a numeric suffix of length 4 and prefix "input.part." </s> split -b 500M -d -a 4 INPUT_FILE_NAME input.part.
Print the contents of "file" with " | " appended to each line </s> echo `sed -e 's/$/\ |\ /g' file`
Count all files under "/DIR" </s> find /DIR -type f -print0 | tr -dc '\0' | wc -c
search all the files in the current folder and assign them to a variable </s> files=`find .`
find the file "foo.txt" in the current folder and assign the output to a variable </s> OUTPUT=`find . -name foo.txt`
For each line in file2 whose first field appears as a first field in file1, print an output line constructed following the specified -o format. </s> join -11 -21 -o1.1,1.2,1.3,2.3 file1 file2
Recursively copy "old/" to "new/" as a dry run skipping files that have matching checksums and output the name only </s> rsync -rcn --out-format="%n" old/ new/
Create archive "backup1.tar" of all subdirectories of the current directory </s> find . -mindepth 1 -maxdepth 1 -type d | awk 'BEGIN {FS="./"}; {print $2}' | xargs -d '\n' tar czf backup1.tar
Print the last space separated word from "Your string here" </s> echo "Your string here"| tr ' ' '\n' | tail -n1
Change the ownership of "/etc/udev/rules.d/51-android.rules" to "root" </s> sudo chown root. /etc/udev/rules.d/51-android.rules
search for the file "job.history" in the folder /data/Spoolln and search for multiple patterns in the file and display the count of matched lines along with the pattern </s> find /data/SpoolIn -name job.history | xargs grep -o -m 1 -h 'FAIL\|ABOR' | sort | uniq -c
Move all files and directories in the current directory to "/foo" </s> mv `ls` /foo
download contents of a website "https://get.scoop.sh" </s> curl -L https://get.scoop.sh
Search directory tree `MyApp.app' for directories whose name is 'Headers' and delete them </s> find MyApp.app -name Headers -type d -delete
Find all hidden files in the current directory </s> find . -type f -name ".*"
Recursively removes all files and folders like 'FILE-TO-FIND' from current folder. </s> find . -name "FILE-TO-FIND" -exec rm -rf {} \;
Add prefix like number and "^M${LOGFILE}> " to every non-blank line received on standard input </s> nl -s"^M${LOGFILE}>  "
Remove all *.swp files/directories under current directory </s> find . -name "*.swp"-exec rm -rf {} \;
Search for files only that end with .php and look for the string $test inside those files </s> find . -name \*.php -type f -print0 | xargs -0 -n1 grep -Hn '$test'
change the permission of all the rpm files in the entire file system to 755 </s> find / -name *.rpm -exec chmod 755 '{}' \;
Find all files and directories on the system whose name is `filedir' </s> find / -name filedir
Read a single character from standard input into variable "runCommand" with the prompt "Pick a letter to run a command [A, B, or C for more info] " </s> read -n1 -p "Pick a letter to run a command [A, B, or C for more info] " runCommand
Find all regular files in .git and replace every occurrences of 'subdomainB.example.com'  with 'subdomainA.example.com' in those files </s> find .git -type f -print0 | xargs -0 sed -i 's/subdomainB\.example\.com/subdomainA.example.com/g'
finda ll the files in the current folder that are modified today. </s> find ~ -type f -mtime 0 -ls
display all the files ending with ".foo" including those that are in the directory ".snapshot", this is the wrong way of using prune. </s> find . \( -name .snapshot -prune -o -name '*.foo' \) -print
Find all files/directories named 'javac' under current directory </s> find . -name 'javac'
Print the characters in $b that match with any character in $a without printing any whitespace in-between </s> echo "$b" | grep --only-matching "[$a]" | xargs | tr --delete ' '
Find all files in the current directory recursively that were last modified more than 5 days ago </s> find ./* -mtime +5
Print the date followed by the host name </s> echo `date` `hostname`
Gets the groups these users belong to. </s> groups a b c d
Find SUID files </s> find / -perm +u=s
display all the html files in the current folder that have been modified exactly 7*24 hours ago </s> find . -mtime 7 -name "*.html" -print
Remove files under current directory that contains white space in their name </s> find . -name "* *" -exec rm -f {} \;
List all *.txt files/directories under /etc </s> find /etc -name "*.txt" | xargs -I {} ls -l {}
Creates temporary file, replacing XXXXXXXXXXXXXXXXXXXXXXX with equal length suffix. </s> mktemp /tmp/banana.XXXXXXXXXXXXXXXXXXXXXXX.mp3
Archive "/path/to/sfolder" to "name@remote.server:/path/to/remote/dfolder" preserving hard links and compressing the data during transmission </s> rsync -aHvz /path/to/sfolder name@remote.server:/path/to/remote/dfolder
change group of the file /tmp/php_session to group daemon </s> chown -R :daemon /tmp/php_session
list all files in the current directory recursively </s> find .
Find all regular files whose names do not end in "*.html" </s> find . -type f -not -name "*.html"
Make directory and parents as needed for the directory name of file "$f" </s> mkdir -p -- "$(dirname -- "$f")"
Replace 'company' with 'newcompany' in all files under current directory and keep backups with .bakup extension </s> find -type f -print0 | xargs -0 sed -i .bakup 's/company/newcompany/g'
Request NS record for com. domain, receiving only authoritative answers </s> dig NS +aaonly com.
Recursively copy all files with names ending with .txt from dir_1 to the same location within copy_of_dir_1 </s> rsync --recursive --prune-empty-dirs --include="*.txt" --filter="-! */" dir_1 copy_of_dir_1
Find all *.txt files under the current directory whose names are not "File.txt" </s> find . -maxdepth 1 -type f -regex '.*\.txt' -not -name File.txt
Count the number of unique 3 to 6 character file extensions are in the current directory tree </s> find . -type f -name "*.*" | grep -o -E "\.[^\.]+$" | grep -o -E "[[:alpha:]]{3,6}" | awk '{print tolower($0)}' | sort | uniq -c | sort -rn
find all the text files in the file system and search only in the disk partition of the root. </s> find / -xdev -name "*.txt"
Display inputfile all on one line (replace newlines by spaces) </s> awk '{printf "%s ", $0} END {printf "\n"}' inputfile
Find all files/directories under current directory tree that contain 'pattern' in their names </s> find -name "*pattern*"
Search the current directory tree for regular files omitting directory `omit-directory' </s> find . \( -name omit-directory -prune \) -o \( -type f -print \)
View the bash manpage, starting with the view positioned at the first occurrence of the expression "BASH_SOURCE". </s> man bash | less -p BASH_SOURCE
Find all directories in maximum 2 levels down the /tmp directory </s> find /tmp -maxdepth 2 -mindepth 1 -type d
Search for "#define" in all files in the current directory, excluding backup files *~, *.orig, *.bak </s> find . -maxdepth 1 ! -regex '.*~$' ! -regex '.*\.orig$' \     ! -regex '.*\.bak$' -exec grep --color "#define" {} +
Find all *.mp3 files in file system with more than 10MB and delete them using rm command </s> find / -type f -name *.mp3 -size +10M -exec rm {} \;
display all normal / regular files in current folder in reverse order </s> find . -type f | tac
Find all test2.h files under current directory </s> sudo find . -name test2.h
search for the file foo.txt in the current folder and open it in vi editor </s> find -name foo.txt -execdir vim '{}' ';'
sleep for 10 seconds </s> sleep 10
Recursively removes all files and folders that match pattern '/usr/local/{lib/node{,/.npm,_modules},bin,share/man}/npm*' </s> rm -rf /usr/local/{lib/node{,/.npm,_modules},bin,share/man}/npm*
Find all files, folders, symlinks, etc in the current directory recursively </s> find .
Case-insensitive search all existing environment variables and their values for "shell". </s> env | grep -i shell
Find broken symlinks </s> find ./ -follow -lname "*"
Search for 'string-to-find' in all files under current directory tree matching the regex 'filename-regex.\*\.html' in their paths and show the matched lines along with the filenames </s> find . -regex filename-regex.\*\.html -exec grep -H string-to-find {} \;
Recursively finds files like '*.js', and filters out files with 'excludeddir' in path. </s> find . -name '*.js' | grep -v excludeddir
Get IP address of your SSH session </s> who am i --ips|awk '{print $5}' #ubuntu 14
Find all files in entire file system which are larger than 20000KB and show file name/path followed by its size </s> find / -type f -size +20000k -exec ls -lh {} \; | awk '{ print $8 ": " $5 }'
search the pattern ^PyErr in all the ".c" files in the folder Lib/ </s> find Lib/ -name '*.c' -print0 | xargs -0 grep ^PyErr
display all the directories in the current folder excluding those that have the name "node_modules" </s> find . ! -name "node_modules" -type d
find regular files under the current directory and execute an md5sum command on each one </s> find -type f -exec md5sum {} +
Print the content of file </s> sed 's/\n//' file
find the file with the name "file" in the entire file system </s> find / -name file
display the file name and creation month of top 11 files in the entire file system </s> find / -type f -printf "\n%Ab %p" | head -n 11
Format bash array "${arr}" in columns </s> echo " ${arr[@]/%/$'\n'}" | sed 's/^ //' | column
View history using "more" </s> history | more
find all the files in the current folder which are writable </s> find . -writable
Print extended file information for regular files found under the home directory whose names start with my </s> find . -name 'my*' -type f -ls
Find symbolic links under /etc/ </s> find /etc -type l
find all files under the /etc/sysconfig directory that were accessed in the last 30 minutes </s> find /etc/sysconfig -amin -30
Search for hidden files non-recursively </s> find . -name '.?*' -prune
Locate files that reside in the /u/bill directory tree and were last accessed between 2 and 6 minutes ago </s> find /u/bill -amin +2 -amin -6
Find all *.py files under and below the current directory and search them for "xrange" </s> find . -name '*.py' -exec grep --color 'xrange' {} +
Split all files in the directory tree "/dev/shm/split/" into files of at most 1000 lines each and use the filename as the prefix </s> find /dev/shm/split/ -type f -exec split -l 1000 {} {} \;
Unsets 'history' shell option. </s> shopt -u -o history
Print the names of all files and directories in the current directory tree </s> find . -print
display long listing of all the files in the folder "/myfiles" </s> find /myfiles -exec ls -l {} ;
display the count of all the directories in the current folder </s> find . -type d –print | wc -l
Infinitely ping every host listed in "file-of-ips" with at most 50 processes at once </s> cat file-of-ips | xargs -n 1 -I ^ -P 50 ping ^
display all the directories in the folder /path/to/dest except tmp and cache directories </s> find /path/to/dest -type d \( ! -name tmp \) -o \( ! -name cache \) -print
replaces the last occurrence of 'a' with 'c' </s> tac infile.txt | sed "s/a/c/; ta ; b ; :a ; N ; ba" | tac
Search the current directory tree for files matching regular expression '^myfile[0-9][0-9]?$' </s> find . -\( -name "myfile[0-9][0-9]" -o -name "myfile[0-9]" \)
find all the files in current folder which end with a speicifc regular expression and display their count </s> find ./ -type f -regex ".*\.[JPGjpg]$" | wc -l
find all files in the current folder that are not modified in the last 10 minutes </s> find . -mmin +10 -print
Search the current user's home directory and its sub-directories for any files accessed after alldata.tar was last accessed and add them to that same tar archive. </s> find ~/ -newer alldata.tar 	-exec tar uvf alldata.tar {} \;
Print pathnames of all files in the current directory and below skipping files under SCCS directories </s> find . -print -name SCCS -prune
Join comma-separated information in 4 files - files must be sorted. </s> join -t, test.1 test.2 | join -t, - test.3 | join -t, - test.4
Recursively removes all files in a 'path' folder but 'EXPR' files. </s> find [path] -type f -not -name 'EXPR' | xargs rm
Find and compress all .pl files in the current directory tree </s> find . -name "*.pl" | xargs tar -zcf pl.tar.gz
Save the list of all .py files under and below the current directory that contain "something" in their pathnames to output.txt </s> find . -name '*.py' | tee output.txt | xargs grep 'something'
Find all file paths under current directory, sort them numerically and show last 10 lines of output with only their paths </s> find . -type f -printf '%T@ %p\n' | sort -n | tail -10 | cut -f2- -d" "
search all jpg files in current folder </s> find . -type f -name "*.jpg"
Find all files named `file1' starting from / </s> find / -name file1
Find *.pl files/directories under /users/tom </s> find /users/tom -name "*.pl"
Rename all .txt files to .bak in the current directory tree </s> find . -name "*.txt" | sed "s/\.txt$//" | xargs -i echo mv {}.txt {}.bak | sh
Send one ping request to host with local address in the 10.0.0.x range, with last number specified by variable "i", waiting 1 second for a reply, and output only lines containing "from" to standard output. </s> ping -W 1 -c 1 10.0.0.$i | grep 'from' &
Delete all .svn files/directories under current directory </s> find . -depth -name .svn -exec rm -fr {} \;
Find all files under current directory that were modified in the last 24 hours </s> find -mtime 0
Print the help message of command "split" </s> split --help
Output the base name of first argument to script or function, that is the part following the last slash. </s> echo $(basename "$1")
change the permission of all the regular/normal files in the current folder from 777 to 755 </s> find . -type f -perm 777 -exec chmod 755 {} \;
Find all directories in maximum 1 level down the $front_element directory, sort them according to modification time and list them excluding the $front_element path from the list </s> find "$front_element" -maxdepth 1 -type d -not -path "$front_element" -printf '%T@ %p\n' | sort | awk '{print $2}'
Find all *.rb (regular) files under current directory </s> find . -name "*.rb" -type f
Sort and print each unique line in "myfile.txt" </s> cat myfile.txt| sort| uniq
Print amount of space available on the file system containg path to the current working directory. </s> df . | awk '$3 ~ /[0-9]+/ { print $4 }'
Remove everything in a current folder without prompting. </s> rm -rf *
Find files/directories named 'TEST_3' under current directory tree </s> find -name TEST_3
find all the directories in the file system which have read, write and execute to all the users </s> find / \( -type d -a -perm -777 \) -print
Find all files that belongs to group Developer under /home directory </s> find /home -group developer
Delete all files in the current directory. </s> find . -exec /bin/rm {} \;
Get the sizes (and total size) of all files under dir2 directory </s> find dir2 ! -type d |xargs wc -c
Find all directories whose name is Tecmint in / directory </s> find / -type d -name Tecmint
find the type of all the regular/normal files in the current folder </s> find . -type f -exec file {} \;
search for the file "abc" in the current folder or display all the directories </s> find . -name abc -or -type d
Print the mount point of the last mounted drive </s> mount | tail -1 | sed -e "s/^[^/]*\(.*\) type .*$/\1/g"
Find all .sh files in or below the current directory and move them to folder ~/back.scripts </s> find . -name "*.sh" -print0 | xargs -0 -I file mv file ~/back.scripts
Find all files in $dir directory (non-recursive) and count them </s> find "$dir" -maxdepth 1 -type f | wc -l
Find all files under current directory and show their file information </s> find . -type f -exec file {} \;
kill all background jobs </s> jobs -p | xargs kill
Find all files/directories under $dir directory </s> find "$dir"
Copy all files below the current directory whose names contain "FooBar" to directory foo/bar/ in user's home directory. </s> find . | grep FooBar | xargs -I{} cp {} ~/foo/bar
Append the parent directory name with a space in all 'text.txt' files in all sub directories of current directory </s> find . -name text.txt | sed 's|.*/\(.*\)/.*|sed -i "s@^@\1 @" & |' | sh
Perform a dry run replacing "special" with "regular" in all file names in the current directory </s> rename -n 's/special/regular/' **
Find all files/directories under current directory and print their paths </s> find . -exec echo {} ';'
display all the files with the names "name1" and "name2" in the current folder and do not search in the sub directories </s> find . -maxdepth 1 -name "name1" -o -name "name2"
print the line containing TERMINATE and everything after in 'file' </s> tail -n "+$(grep -n 'TERMINATE' file | head -n 1 | cut -d ":" -f 1)" file
Change permissions of all directories in the ~/dir_data directory tree in accordance with mode `a+xr,u+w' </s> find ~/dir_data -type d -exec chmod a+xr,u+w {} \;
List the current directory recursively ignoring the "dir1" subdirectory's content </s> find . -print -name dir -prune
Print appended data in "/var/log/some.log" that match "foo" and "bar" </s> tail -f /var/log/some.log | grep --line-buffered foo | grep bar
Gets IP address of 'en1' network interface. </s> my_ip=$(ifconfig en1 | grep 'inet addr' | awk '{print $2}' | cut -d: -f 2)
Unzip and extract "userAgent=[^=]*'" from "input.gz" </s> zcat input.gz | grep -o 'userAgent=[^=]*' | sed 's/ [^ ]*$//'
display all the files in the current folder </s> find .
Find files named core in or below the directory /tmp and delete them. Note that this will work incorrectly if there are any filenames containing newlines, single or double quotes, or spaces. </s> find /tmp -name core -type f -print | xargs /bin/rm -f
Print first 11 characters from $line, print a tab, print the md5 sum of the file specified by the 13th and onward characters from $line and print a null character at end without a trailing new line </s> echo -en "${line:0:11}" "\t" $(md5sum "${line:12}") "\0"
Search the regular files of the current directory tree for string "whatever" </s> find . -type f | xargs grep whatever
Exclude directory from find . command </s> find . -name '*.js' | grep -v excludeddir
Exclude directory from find . command </s> find . -name '*.js' -and -not -path directory
Find all 777 permission files/directories under current directory tree </s> find -perm 777
List all files in the /hometest directory tree whose names are "Trash", and their sizes </s> find /hometest -name Trash -exec ls -s {} \;
Find files in the current directory and its sub-directories that begin with 'f'. </s> find . -name f* -print
Search the files in the current directory tree that are named "string to be searched" for "text" </s> find . -name "string to be searched" -exec grep "text" "{}" \;
change the permission of all the files in the current directory to 664 and change the permission of all the directories  in the current folder to 775. </s> find . \( -type f -exec sudo chmod 664 "{}" \; \) , \( -type d -exec sudo chmod 775 "{}" \; \)
find all the text files in  the current folder and do not search in somedir, bin directories </s> find . \( -name somedir -prune \) , \( -name bin -prune \) -o \( -name "*.txt" -print \)
Find all *.py files under current directory </s> find . -type f -name "*.py"
Compress $file file using gzip </s> gzip "$file"
find the depth of all the files in current folder and display the depth and file name </s> find folder1/ -depth -type f -printf "%d\t%p\n"
find regular/normal files in the current folder </s> find -type f
search in current directory downwards all files whose size is less then 10 bytes </s> find .  -size -10c -print
Remove lines matching "kpt#" from "data.txt" and add left-justified line numbers </s> grep -v 'kpt#' data.txt | nl -nln
recursively change owner and group of the directory and all files into it to user root and group root </s> chown -R root:root /var/lib/jenkins
list all processes with its PIDs </s> jobs -l
Print the list of all regular files in the current directory and below </s> find . -type f
Archive "src" to "dst" updating files existing in "dst" </s> rsync -a -v src dst
Find all Makefile's in the current directory tree and print the line 235 of each of them </s> find . -type f -name Makefile -print -exec sed -n '235p' {} \;
delete a hard link and create a symbolic link to file named "$link" </s> ln -sf "$(readlink -f "$link")" "$link"
Recursively search for all files with names ending with "_test.rb", renaming them to end with "_spec.rb". </s> find . -name "*_test.rb" | xargs rename s/_test/_spec/
display all text files in the folder /home/you which have been modified in the last 60*24 hours(case insensitive search) </s> find /home/you -iname "*.txt" -mtime -60 -print
Change owner to "bob" and group to "sftponly" of "/home/bob/writable" </s> sudo chown bob:sftponly /home/bob/writable
Change folder to the one where $0 link target file is located. </s> cd $(dirname $(readlink -f $0))
List the number of occurrences of each unique character in "The quick brown fox jumps over the lazy dog" sorted from most frequent to least frequent </s> echo "The quick brown fox jumps over the lazy dog" | grep -o . | sort | uniq -c | sort -nr
Find all files under and below the current working directory with the word California in the file (case insensitive), and count the number of lines in the output </s> find . -type f -exec grep -i California {} \; -print | wc -l
Find recursively all Python files in the current directory tree and count the number of lines in them </s> find . -name '*.py' | xargs wc -l
count lines of C or C++ or Obj-C or Java code under the current directory </s> find . \( -name "*.c" -or -name "*.cpp" -or -name "*.h" -or -name "*.m" -or -name '*.java' \) -print0 | xargs -0 wc
Make directory "~/temp" </s> mkdir ~/temp
find all the files starting with "config" in the folder Symfony ( case insensitive search) </s> find Symfony -iname '*config*';
Print the current working directory prepended by "pwd: " </s> echo pwd: `pwd`
find all text files in current folder and display all files that have the alphabet a in their name </s> find . -name ".txt" | grep a
Find all directories under current directory and set their permission to 775 </s> find -type d | xargs chmod 775
Find all files/directories newer than ttt or owned by user 'wn' in entire file system </s> find / \( -newer ttt -or -user wnj \) -print
Print the average round trip time of 5 pings to "google.com" from OSX </s> ping -c 5 google.com | grep "round-trip" | cut -f 5 -d "/"
Write "suspend" to standard output and to file "/sys/bus/usb/devices/usb3/power/level" </s> echo suspend | sudo tee /sys/bus/usb/devices/usb3/power/level
Look for any files that were modified 2-5 days ago </s> find -mtime +2 -mtime -5
Print a count of duplicate lines in "filename" </s> sort filename | uniq -c
Send ping requests to "yourhostname.local" </s> ping youhostname.local
Prints process tree for each process owned by user 'username'. </s> ps -aux |  awk '/^username/{print $2}' | xargs pstree
Find all *.mov files under current directory </s> find . -name "*.mov"
Finds the folder where temporary files would be written to. </s> dirname $(mktemp -u -t tmp.XXXXXXXXXX)
find all the database files in the folder /var/named </s> find /var/named -type f -name *.db
Get the base filename from variable 'path', similar to using the basename command. </s> echo "$path" | rev | cut -d"/" -f1 | rev
Prints the length and contents of the longest line in filename </s> cat filename | awk '{print length, $0}'|sort -nr|head -1
Removes 55, adds a 10-digit line number, and rearranges the date for each line in "input" on OSX </s> nl -nrz -w10 -s\; input | sed -E 's/55//; s/([0-9]{2})-([0-9]{2})-([0-9]{4})/\3\2\1/'
Find all files/directories with inode number 16187430 and move them to 'new-test-file-name' </s> find -inum 16187430 -exec mv {} new-test-file-name \
Find files that were modified second last week and archive them </s> find . -type f -mtime +7 -mtime -14 | xargs tar -cvf `date ‘+%d%m%Y’_archive.tar`
list files in /u/bill that were last read from 2 to 6 minutes ago </s> find /u/bill -amin +2 -amin -6
Search the system for files and directories owned by group `managers' </s> find / -group managers -print
search for the file, filename.txt in the folder /home </s> find /home -name filename.txt
Print variable "$OPTARG" "$opt" times </s> yes "$OPTARG" | head -$opt
Check whether "$path_in_question" is a mount point </s> df $path_in_question | grep " $path_in_question$"
Add group write permission to all files matching "*" or "...*" </s> chmod g+w * ...*
delete all the text files from the current folder after user confirmation </s> find . -name "*.txt" -ok rm {} \;
For each line of colon-separated information in files 'empsal' and 'empname' whose first field matches in both files, output: first field of empname, second field of empname, fourth field of empname, and third field of empsal. </s> join -j 1 -t : -o 2.1,2.2,2.4,1.3 <(sort empsal) <(sort empname)
Decompress and sort "$part0" and "$part1" of files in different processes </s> sort -m <(zcat $part0 | sort) <(zcat $part1 | sort)
Find all directories under current directory whose names are 33 characters long </s> find . -type d -name "?????????????????????????????????"
Join comma-separated data in file1 and file2, including extra non-matching information in both files. </s> join -t, -a1 -a2 <(sort file1) <(sort file2)
Print a sorted list of the subdirectories of ~/Music </s> find ~/Music/ -maxdepth 2 -mindepth 2 -type d | sort
Read a single character from standard input and do not allow backslash to escape characters </s> read -rn1
create directory practice into home directory </s> mkdir ~/practice
Find the process id of mysql </s> ps -A|grep mysql
List all files/directories under current directory </s> find . -print
Set permission of all files in "img", "js", and "html" to 644 </s> chmod 644 img/* js/* html/*
Find files/directories named 'photo.jpg' in the entire filesystem </s> find / -name photo.jpg
Make directories "bravo_dir" and "alpha_dir" </s> mkdir bravo_dir alpha_dir
Find all TXT files in the current directory and copy them to directory "$HOME/newdir" </s> find "$HOME" -name '*.txt' -type f -print0 | sort -zu | xargs -0 cp -t "$HOME/newdir"
Retrieve column number from column name "Target" in file "table" </s> head -1 table | tr -s ' ' '\n' | nl -nln |  grep "Target" | cut -f1
find all the normal/regular files in the current directory </s> find -type f
Find all 400 permission files under /data directory </s> find /data -type f -perm 400 -print
display all the hidden directories in the directory "/dir/to/search/" </s> find /dir/to/search -path '*/.*' -print
Remove regular files changed more than 15 days ago from the /tmp directory tree </s> find /tmp/ -ctime +15 -type f -exec rm {} \;
Tmux configuration to enable mouse support within tmux </s> set -g mouse on
Print the list of the current directory's subdirectories </s> find . -type d -maxdepth 1
delete all the files in the current folder </s> find . -print0 | xargs -0 rm
Find all regular files in the "aaa" directory </s> find aaa/ -maxdepth 1 -type f
Find all files modified less than 5 minutes ago, and page interactively through the output. </s> find -cmin -5 | less -R
change user and group of the file "/var/run/docker.sock" to user root and group dockerroot </s> sudo chown root:dockerroot /var/run/docker.sock
Find .cpp files that differs in subdirectories PATH1 and PATH2. </s> diff -rqx "*.a" -x "*.o" -x "*.d" ./PATH1 ./PATH2 | grep "\.cpp " | grep "^Files"
use find -exec with multiple commands regardless of their success or failure </s> find . -name "*.txt" \( -exec echo {} \; -o -exec true \; \) -exec grep banana {} \;
Print the base name of the current working directory </s> echo "$(basename $(pwd))"
Display operating system type, ie. GNU/Linux </s> uname -o
Read a line from standard input into variable "message" with escaped prompt "\nPlease Enter\na Message: '" </s> read -p "`echo -e '\nPlease Enter\na Message: '`" message
Replace the spaces after line number in the output of history with ".." </s> history | sed 's/^\( *[0-9]*\) */\1../'
Rename all files in current directory to lowerase, overwriting any existing files. </s> rename -f 'y/A-Z/a-z/' *
find all the directories in the current folder </s> find . -type d -print
find all the files in the current directory whose size is equal to exactly 126MB. </s> find . -size 126M
This find command ignore the case when searching for file name , to ignore the case  in this example all .py & .PY file will search </s> find . -type f -iname "*.py"
Prints latest modified file in a directory </s> ls -1t | head -1
Get a detailed list of all files on the system larger than 10MB </s> find / -size +10M -printf “%12s %t %h/%fn”
Search the files in the current directory tree for lines containing string "vds admin" </s> find . -exec grep -i "vds admin" {} \;
Search for regular files of the grooup 'users' in the file system </s> find /  -type f -group users
search for files in the current folder which start with "myfile" ( case insensitive search ) </s> find . -iname 'MyFile*'
Remove files in current directory according to the filenames found in ~/clang+llvm-3.3/bin/ </s> find ~/clang+llvm-3.3/bin/ -type f -exec basename {} \; | xargs rm
Pushes current folder to the directory stack. </s> pushd $PWD
Recursively and forcibly removes $TMP folder with all content. </s> rm -fR "${TMP}/";
Find all files newer than httpd.conf under and below the current directory </s> find . -newer httpd.conf
Find all files/directories under current directory and print them </s> find . -print0 | xargs -I{} -0 echo {}
search for all the regular files in the current folder and display the contents </s> find . -type f -exec cat {} \;
Find all *.c files under and below the current directory that contain "hogehoge" </s> find . -name \*.c | xargs grep hogehoge
Print the newest *.txt file under current directory with timestamp and path </s> find . -name "*.txt" -printf "%T@ %p\n" | sort | tail -1
Make directory "/etc/cron.5minute" </s> mkdir /etc/cron.5minute
Print file system disk space usage in human readable format of the root filesystem </s> df -h /
Rename all files matching "access.log.<number>.gz" incrementing <number>. </s> find -name 'access.log.*.gz' | sort -Vr | rename 's/(\d+)/$1+1/ge'
find all the regular/normal files in the current folder which belong to the group "flossblog" </s> find . -group flossblog -type f
Search non-recursively directory tree `MyApp.app' for directories whose name is 'Headers' and delete them in an optimized way </s> find MyApp.app -name Headers -type d -prune -exec rm -rf {} +
Go to /the/project/root//data, which in most filesystems/operating systems will be the same as cd /the/project/root/data </s> cd /the/project/root//data
Print a colon-separated list of all directories from the ~/code directory tree </s> find ~/code -type d | tr '\n' ':' | sed 's/:$//'
Recursively changes group ownership of everything within a '/path/to/repo' to 'GROUP'. </s> chgrp -R GROUP /path/to/repo
Print a sorted list of the extensions of the regular files from the current directory tree with counts per extension </s> find . -type f | sed -e 's/.*\.//' | sed -e 's/.*\///' | sort | uniq -c | sort -rn
Look for file `Chapter1' under /usr and /home </s> find /usr /home -name Chapter1 -type f
List all environment variables whose name contains 'ipo', showing only the names of the variables and not their values. </s> env | grep ipo | awk 'BEGIN {FS="="} ; { print $1 } '
Executes 'true'. then makes 'xargs' fail executing 'false' and return 123 exit code. </s> true | xargs false
display all the files in current folder which have write permission to all the users </s> find . -perm /222
List all *.gif files found in the current directory tree </s> find . -name *.gif -exec ls {} \;
Recursively removes all files like '*.pyc' in a current folder, printing info message about each action. </s> find . -name "*.pyc" | xargs -I {} rm -v "{}"
display all the text files in the home folder ( case insensitive search ) </s> find /home -iname "*.txt"
kill all active jobs </s> jobs -p | xargs kill -9
Recursively print all directories in the current directory tree </s> tree -d
Display a long listing of all 0777 permission directories under current directory tree </s> find . -perm 0777 -type d -exec ls -l {} \;
Print each character of "abcdefg" on a line </s> echo "abcdefg" | fold -w1
Make directory "~/public_html" </s> mkdir ~/public_html
Remove all characters except ";" and digits from standard input </s> tr -cd ";0-9"
search for a file "file" in current folder and if the file is found quit ! </s> find -name file -quit
Counts lines in each *.php file, sorted by number of lines, descending. </s> find . -name '*.php' -type f | xargs wc -l | sort -nr
Find all directories under current directory and set read & execute permission for group and other for these files </s> find . -type d -print0 | xargs -0 chmod go+rx
For each line of the sorted output of both file1 and file2, print lines whose first field of file2 does not appear as first field of file1. </s> join -v1 <(sort file1) <(sort file2)
Recursively change ownership of "/usr/lib/node_modules/" to the current user </s> sudo chown -R $(whoami) /usr/lib/node_modules/
Search the current directory tree for files whose names end in "rb" or "js" </s> find . -name "*js" -o -name "*rb"
Find all files whose name or type description includes "text", display only paths to files. </s> find . -exec file {} \; | grep text | cut -d: -f1
Show files in maximum 1 level down the current directory that were modified less than 1 day ago from today </s> less `find -maxdepth 1 -type f -daystart -mtime -1`
Change the group to `temp' for all files in the current directory tree that belong to group `root' </s> find . -group root -print | xargs chgrp temp
Print every two lines in "file" on a single line separated by a space </s> cat file | paste -d\ - - -
Create ssh tunnel through "genja.org" connecting localhost port 4444 to "raptor.lan" port 22 </s> ssh -L 4444:raptor.lan:22 genja.org
Move all files and directories in the current directory to "/foo" </s> mv * /foo
Replace spaces in file names with underscores for all files in the current directory tree </s> find -name "* *" -type f | rename 's/ /_/g'
search for all the files in the current directory which belong to the user "xuser1" and change the owner ship of them to "user2" </s> find . -user xuser1 -exec chown -R user2 {} \;
Split "domains.xml" into files of at most 50000 lines each with a numeric suffix of length 4 and prefix of "domains_" </s> split -a 4 -d -l 50000 domains.xml domains_
Delete all empty files/directories under test directory </s> find test -depth -empty -delete
Set variable 'file' to the base name of first argument to script or function, that is the part following the last slash. </s> file=`basename "$1"`
Find files/directories writable by group and others under the /path directory </s> find /path -perm -g+w,o+w
Search for files/directories which are writable by somebody (their owner, or their group, or anybody else) </s> find . -perm /222
Remove trailing whitespaces in TXT files from the current directory tree </s> find . -iname '*.txt' -type f -exec sed -i '' 's/[[:space:]]\{1,\}$//' {} \+
Print the list of all directories under the current directory and below </s> find ./ -type d -print
display the amount of disk space used by all the log files in the folder /usr/local/apache/logs/ </s> find /usr/local/apache/logs/ -type f -name "*_log"|xargs du -csh
Find all SGID set files </s> find / -perm /g=s
search for *.log files starting from / (root) and only in the current file system </s> find / -xdev -name "*.log"
Find all files/directories under current directory tree that have modified in the last 2 days and contain 'blah' (case insensitive) in their names </s> find . -iname '*blah*' \( -type d -o -type f \) -mtime -2
find all ".flac" files starting with "cmn-" and search for files having CJK characters using unicodes </s> find . -name 'cmn-*.flac' -print | grep -P '[\x4e00-\x9fa5]'
Format time string @1267619929 according to default time format </s> date -d @1267619929
Delete all files under '/home/backups' directory tree with '.tgz' or '.gz' extension (case insensitive) that were modified more thant 60 days ago </s> find /home/backups -type f -iregex '.*\.t?gz$' -mtime +60 -exec rm {} \;
Find files that are 0 bytes in size in the current directory and remove them </s> find . -maxdepth 1 -size 0c -exec rm {} \;
Delete all files/directories named 'sample' (case insensitive) under '/home/user/Series/' directory tree as super user </s> sudo find /home/user/Series/ -iname sample -print0 | sudo xargs -0 rm -r
Display only line numbers listed in 'file_of_line_numbers" from file 'source'. </s> sed 's/$/p/' file_of_line_numbers | sed -nf - source
Change directory to "/path/to/pdf" </s> cd  /path/to/pdf
Find all Executable files in the file system </s> find / -perm /a=x
search for the ip "192.168.1.5" in all the files in /etc folder </s> find /etc/ -iname "*" | xargs grep '192.168.1.5'
change permissions for directories in the entire file system </s> chmod 751 `find ./ -type d -print`
Print a ping request and the number of packets sent, received, and the percentage lost for each ping request to "google.com" </s> ping google.com | awk '{ sent=NR-1; received+=/^.*(time=.+ ms).*$/; loss=0; } { if (sent>0) loss=100-((received/sent)*100) } { print $0; printf "sent:%d received:%d loss:%d%%\n", sent, received, loss; }'
Read a line from standard input into variable "YESNO" ignoring backslash escapes and using the prompt "$(echo $@) ? [y/N] " </s> read -r -p "$(echo $@) ? [y/N] " YESNO
Split "$in_file" excluding the first line into files of at most 100000 lines each with numeric suffixes of length 5 and the prefix $in_file"_" </s> awk '{if (NR!=1) {print}}' $in_file | split -d -a 5 -l 100000 - $in_file"_"
Find all *.rb and *.py files/directories under current directory </s> find . -name "*.rb" -or -name "*.py"
Display name and value of 'variable' if it exists. </s> env | grep '^variable='
List all leaf directories (directories which don't contain any sub-directory) under current directory </s> find . -type d -links 2
Change permission to 755 for all directories under $d directory tree </s> find "$d/" -type d -print0 | xargs -0 chmod 755
Run perl -V (displays informations about perl's setup) in an empty environment. </s> env -i perl -V
Print the 6th field (delimited by '/') from the paths specified by ~/bin/FilesDvorak/.* files/directories </s> find ~/bin/FilesDvorak/.* -maxdepth 0 | awk -F"/" '{ print $6 }'
Print directories in the the current directory as a list with no report information </s> tree -d -L 1 -i --noreport
Prints directory where the executing script ($0) is located. </s> $(dirname $0)
search for all the files with the name "dummy" in the current folder </s> find -type f -name dummy
Change permissions to 644 for all regular files under the /path/to/dir/ tree </s> find /path/to/dir/ -type f -print0 | xargs -0 chmod 644
Print the current working directory and the base name of "$1" </s> echo "$(pwd)/$(basename "$1")"
split file /usr/bin/gcc into pieces per 100000 lines </s> split -n 100000 /usr/bin/gcc
Print "#include" statements found in "file2" that are not in "file1" </s> comm -13 <(grep '#include' file1 | sort) <(grep '#include' file2 | sort)
Write standard input to standard output and to "foobar.txt" </s> tee foobar.txt
Find all files/directories case insensitively containing 'xt' in their names under '/etc' directory tree </s> find /etc -iregex '.*xt.*'
Print short TXT record of domain o-o.myaddr.l.google.com from nameserver 8.8.8.8 </s> dig TXT +short o-o.myaddr.l.google.com @8.8.8.8
display list of all the C files ( fuiles with ".c" extension ) in current folder </s> find . -name '*.c' -ls
Page through the contents of 'file', but excess from lines that don't fit within the screen/window width is cut. </s> less -S file
Find all broken symlinks under /path/to/search directory </s> find /path/to/search -type l -xtype l
Display all lines contained in 'dax-weekly.csv' in reverse order. </s> cat dax-weekly.csv | awk '{a[i++]=$0} END {for (j=i-1; j>=0;) print a[j--] }'
Find all files/directories that have read, write, execution permission for user and belong to the user 'my_user' under current directory tree </s> find . -user my_user -perm -u+rwx
Remove all .txt files in and below the current directory </s> find . -name "*.txt" -print0 | xargs -0 rm
Save the first three octets of the current host's IP address to variable "local" </s> local=$(hostname -I | awk '{print $2}' | cut -f1,2,3 -d".")
Recursively change the owner and group of "/home/el/svnworkspace" and "775" to "your_user_name" </s> chown -R your_user_name.your_user_name 775 /home/el/svnworkspace
search for the regular/normal file "foo.bar" and force delete it </s> find /home -name foo.bar -type f -exec rm -f "{}" ';'
Search for all jpg images on the system and archive them </s> find / -name *.jpg -type f -print | xargs tar -cvzf images.tar.gz
Search the ./in_save directory for regular files and view the result using pager `more' </s> find ./in_save/ -type f -maxdepth 1| more
find all the files that were modified two days ago </s> find . -daystart -ctime 1 -type f
Find the most recently changed files in a subtree </s> find . -type f -printf '%TY-%Tm-%Td %TT   %p\n' | sort
Remove all *.txt files under the given directory modified more than 5 minutes ago </s> find /home/u20806/public_html -maxdepth 1 -mmin +5 -type f -name "*.txt" -delete
list names of bind functions containing "/" </s> bind -l | grep /
Find all directories with space in their names under current directory and rename them by replacing all spaces with _ </s> find -name "* *" -type d | rename 's/ /_/g'
List the files in the /etc directory tree containing text "old1.old2.co.com" </s> find /etc -type f -print | xargs grep -il old1\.old2\.co\.com
Read a line from standard input in an interactive shell with prompt in variable "myprompt" interpreted as PS1 is interpreted </s> read -e -p "${myprompt@P}"
download a file "http://download.oracle.com/otn-pub/java/jce/8/jce_policy-8.zip" using cookies "oraclelicense=accept-securebackup-cookie" </s> curl -L -C - -b "oraclelicense=accept-securebackup-cookie" -O http://download.oracle.com/otn-pub/java/jce/8/jce_policy-8.zip
Search the current directory recursively for *.txt files with lines that match regular expression "^string" </s> find . -name "*.txt" -exec egrep -l '^string' {} \;
Change permissions to 700 for directories at the current level and deeper </s> find . -mindepth 1 -type d | xargs chmod 700
find all directory list which have empty list in /tmp directory </s> find /tmp -type d -empty
Print the list of directories residing in the current directory tree </s> find . -type d -exec ls -ld {} \;
display all files in current folder excluding text files </s> find . ! -name "*.txt"
Replace all occurrence of "subdomainA.example.com" with "subdomainB.example.com" in all files under the current directory and below ignoring SVN files </s> find . \( ! -regex '.*/\..*' \) -type f -print0 | xargs -0 sed -i 's/subdomainA.example.com/subdomainB.example.com/g'
Find all files under /path/to/base/dir and change their permission to 644 </s> find /path/to/base/dir -type f -print0 | xargs -0 chmod 644
List all cron jobs where the minute part is either * or a number from 0 to 14. </s> crontab -l | awk '$1 == "*" || $1 ~ /^[0-9]+$/ && $1 < 15 {print}'
Filters only directories including hidden ones from long file listing of a current directory, and prints their names. </s> ls -Al | grep "^d" | awk -F" " '{print $9}'
Remove all files from the current directory tree whose names do not match regular expression "excluded files criteria" </s> find . | grep -v "excluded files criteria" | xargs rm
Replace all occurrences of edx (case insensitive) with gurukul in all *.css (case insensitive) files under ./cms/djangoapps/contentstore/management/commands/tests directory </s> find ./cms/djangoapps/contentstore/management/commands/tests -iname *.css | xargs sed -i s/[Ee][Dd][Xx]/gurukul/g
Print the list of the current directory's subdirectories </s> find . -maxdepth 1 -mindepth 1 -type d -printf '%f\n'
Page through the contents of BIG_FILE.txt, letting the user move around with the arrow keys, the Q key quits. </s> cat BIG_FILE.txt | less
Find all directories in the current directory tree excluding hidden directories and create them in "../demo_bkp" </s> find . -not -path \*/.\* -type d -exec mkdir -p -- ../demo_bkp/{} \;
Compress a file named '{}' in the current directory </s> gzip "{}"
Search for 'foo=' in all *.png files under current directory without descending into *.gif and *.svn directories </s> find . -name "*.png" -prune -o -name "*.gif" -prune -o -name "*.svn" -prune -o -print0 | xargs -0 -I FILES grep -IR "foo=" FILES
Find files in the current directory tree whose pathnames contain "sub" </s> find ./ | grep "sub"
find all files which name contain 'foo' and path is not dir1 or dir2 </s> find ! -path "dir1" ! -path "dir2" -name "*foo*"
Search the current directory tree for files executable by at least someone </s> find . -type f -perm +111 -print
Split "/etc/gconf/schemas/gnome-terminal.schemas" into 1000000 files of about equal size </s> split -n 1000000 /etc/gconf/schemas/gnome-terminal.schemas
Search for the extended grep regex 'expr' in all files with '.c' and '.h' extension under current directory tree </s> find . -name '*.[ch]' | xargs grep -E 'expr'
List all files/directories under $dir_name with size $sizeFile and print them according to the format string  '%M %n %u %g %s %Tb %Td %Tk:%TM %p\n' </s> find $dir_name -size $sizeFile -printf '%M %n %u %g %s %Tb %Td %Tk:%TM %p\n'
display all files in current folder excluding current folder (.) </s> find . \! -name '.'
Format the contents of "[file]" in a neat table </s> cat file | column -t
Find all files/directories under current directory and print their paths </s> find . -exec echo {} \;
Takes folder name of file $0, changes backslashes to forward ones and saves result in $basedir variable. </s> basedir=$(dirname "$(echo "$0" | sed -e 's,\\,/,g')")
find for a filename with multiple patterns in the current folder </s> find . -name "photo*.jpg"
Find all 50MB files </s> find / -size 50M
Erase user's cron jobs and add one cron job to run "script" every minute. </s> echo "* * * * * script" | crontab -
Find all files/directories under current directory tree whose names start with '(test)' followed by two digits and end with '.txt' extension </s> find . -regex ".*/(test)[0-9][0-9]\.txt"
Find directory "/some/dir" if it is empty </s> find /some/dir/ -maxdepth 0 -empty
Unset the executable bit of all regular files from directory trees arch, etc, lib, module, usr, xpic </s> find arch etc lib module usr xpic -type f | xargs chmod -x
Print the file paths and their sizes for all files under full_path_to_your_directory </s> find full_path_to_your_directory -type f -printf '%p %s\n'
Search the home directory tree for files modified less than 7 days ago </s> find $HOME -mtime -7
split file abc.txt into pieces per 1500000000 bytes named as "abc.NNN" </s> split --bytes=1500000000 abc.txt abc
search for the directory testdir in the folder /home </s> find /home -type d -name testdir
find all the normal/regular files in the current directory which have been modified in the last 24 hours </s> find . -mtime -1 -type f -print
Format tab separated fields in "FILE" as a table </s> column -t -s $'\t' FILE
long list al the files in the current directory which have read permission to the group </s> find . -perm -g=r -type f -exec ls -l {} \;
Find files with 002 permission in entire file system and print them with the string 'has world write permissions' printed at last </s> echo $(find / -type f -perm -002) has world write permissions
Unzip "file.gz" to stdout </s> zcat file.gz
List all empty files under the current directory </s> find . -maxdepth 1 -empty
Change permissions to 755 recursively only for directories </s> find . -type d -exec chmod 755 {} \;
Find all files/directories under 'A' directory tree excluding the paths containing the directory 'a' </s> find A \! -path "A/a/*"
Find all files/directories named 'foo.bar' under './dir1' and './dir2' directory trees </s> find ./dir1 ./dir2 -name foo.bar -print
Join data in "file1" sorted by the second word of each line with data in "file2" sorted by the first word of each line, keeping the same order as it is found in "file1" </s> join -1 2 -2 1 <(sort +1 -2 file1) <(sort +0 -1 file2)
Archive "path/subfolder" to "path", skipping files that are newer at the destination. </s> rsync -vuar --delete-after path/subfolder/ path/
search for "flac" files in current folder using regular expressions </s> find ./ -regex "./cmn-.\.flac"
print the last word in a.txt </s> tac a.txt | awk 'NF{print $NF; exit}'
display all instances of the .profile file in the entire file system </s> find / -name .profile -print
Delete files in /var/tmp/stuff and below that have not been modified in over 90 days </s> find /var/tmp/stuff -mtime +90 -execdir /bin/rm {} \+
Search the /myfiles directory tree for regular files with at least these permissions: 647 </s> find /myfiles -type f -perm -647
display all the regular files in current folder excluding all the directories and all the sub directories having "normal" in their name </s> find . \( \( -path "\.?.*" -type d \) -o -path "*normal*" \) -prune -o \( -type f \) -print
Get the actual find exectuable path </s> which find
Create symlinks to all  /home/folder1/*.txt files and 'folder2_' directory with the same name in a target directory named '+' </s> find /home/folder1/*.txt -type f -exec ln -s {} "folder2_" + \;
Find recursively all empty directories in the current directory </s> find -type d -empty
Find all *.txt files/directories under your home directory </s> find ~/ -name '*.txt'
Unzip every ".gz" file in the current directory tree </s> find . -name "*.gz" | xargs gunzip
Copy '/path/to/source' from remote "username@computer" to local "/path/to/dest" </s> rsync -r username@computer:/path/to/source /path/to/dest
Print the 10 most used commands </s> history | awk '{print $2}' | awk 'BEGIN {FS="|"}{print $1}' | sort | uniq -c | sort -n | tail | sort -nr
change the group of all regular/normal files in the current directory </s> find . -type f -exec chgrp usergroup {} \;
Output "stuff", removing "/foo/bar/" from the specified path. </s> basename /foo/bar/stuff
find all txt files under the current folder except ./directory folder </s> find -name "*.js" -not -path "./directory/*"
Search the current directory tree for executable regular files </s> find . -type f -executable -exec file {} \; | grep -wE "executable|shared object|ELF|script|a\.out"
Search the files from the current directory tree for "foo" </s> find . -exec grep foo {} +
Search the current directory tree for files whose names end in "rb" or "js" and which contain string "matchNameHere" </s> find . -regextype posix-ergep -regex ".*(rb|js)$" -exec grep -l matchNameHere {} \;
Find regular files in the current directory tree that have the user executable bit set </s> find . -type f -perm -u=x
Search the directory tree /tmp for regular files using zero delimiter for output </s> find /tmp -type f -print0
Delete all directories under '.cache/chromium/Default/Cache' directory tree that are at least 1 level deep and are bigger than 100 MB in size </s> find .cache/chromium/Default/Cache/ -mindepth 1 -type d -size +100M -delete
Print the number of lines for each *.txt file from the $DIR directory tree </s> find $DIR -name "*.txt" -exec wc -l {} \;
Recursively changes group ownership of everything in '/home/secondacc/public_html/community/' to 'fancyhomepage'. </s> chgrp -R fancyhomepage /home/secondacc/public_html/community/
Look for SUID files and directories </s> find / -perm +4000
Change all files with no user under "/var/www" to have owner "root" and group "apache" </s> sudo find /var/www -nouser -exec chown root:apache {} \;
Change all files in the current directory tree to owner "xx" </s> find . \( \! -user xx -exec chown -- xx '{}' + -false \)
Search  all directory from /usr downwards for files whose inode number is 1234 and print them . </s> find /usr -inum 1234 -print
change the owner of all the files in the file system which belong to the user with the uid 999 </s> find / -user 999 -exec chown NEWUSER {} \;
Request MX record of 'example.com' domain, and filter out all comment strings </s> dig mx example.com | grep -v '^;' | grep example.com
display all the html files in the current folder that have not been modified in the last 7*24 horus </s> find . -mtime +7 -name "*.html" -print
Saves file sctipt.sh size in 'size' variable. </s> size=`cat script.sh | wc -c`
Saves printed calendar of February,1900 in positional variables. </s> set -- $(cal 2 1900)
Find all *.tex regular files in maximum 2 levels down the current directory </s> find . -type f -maxdepth 2 -name "*.tex"
recursively change user of the direct /home/test/ and all files into it to user test </s> sudo chown -R test /home/test
find all files in the current directory which are bigger than 4MB </s> find . -size +4096k -print
search for all the files having spaces in the current folder and save the output to the variable founddata </s> founddata=`find . -name "filename including space" -print0`
list in long format all files from / whose filename ends in "jbd", not descending into directories that are not readable while searching, and not descending into directories on other filesystems </s> find / -mount \! -readable -prune  -o  -path /dev -prune  -o  -name '*.jbd' -ls
Create intermediate directories "x" and "p" as required and create "q" </s> mkdir -p x/p/q
find all the ".JPG" files in current folder and display their count </s> find ./ -name '*.JPG' -type f | wc -l
search for all mp3 files in the folder /home/you which have been accessed exactly 10*24 hours ago </s> find /home/you -iname "*.mp3" -atime 10 -type -f
Display 798 backwards </s> echo 798|rev
Mount a partition in "$IMAGE" with offset "$OFFSET" to "media/$DEST" as read only using a loop device </s> mount -o ro,loop,offset=$OFFSET -t auto $IMAGE /media/$DEST
find all directories with the name "lib64" in the usr folder and replace space with ':' </s> find /usr -name lib64 -type d|paste -s -d:
display all the files in the current folder in a single line separated by null command </s> sudo find . -print0
Search for directory foo ignoring case </s> find . -iname foo -type d
Display a long listing of all directories under '/nas' directory tree </s> find /nas -type d -ls
find all the files ending with jpg in current folder and display their count ( case insensitive ) </s> find ./ -type f -regex ".*\.[Jj][Pp][gG]$" | wc -l
Print a welcome message with the current user's user name </s> echo "Welcome $(whoami)!"
Search files "file-containing-can't" in the current directory tree for the string "can't" </s> find . -name "file-containing-can't" -exec grep "can't" '{}' \; -print
Print a welcome message with the current user's user name </s> echo -ne "Welcome `whoami`!\n"
search for all the non-hidden files in the current directory and do not search in the subfolders and dispaly their name and size. </s> find . -maxdepth 1 -name '[!.]*' -printf 'Name: %16f Size: %6s\n'
Find files/directories named 'sar' under '/usr', '/bin', '/sbin' and '/opt' directory tree </s> find /usr /bin /sbin /opt -name sar
Find all *.m4a files/directories under /home/family/Music directory </s> find /home/family/Music -name '*.m4a' -print0
Change permissions to 644 for all subdirectories </s> find . -type d -print0|xargs -0 chmod 644
Find all the *.txt files in the current directory older than 48 hours </s> find . -maxdepth 1 -name '*.txt' -mtime +2
Save a nginx link to "/path/to/file" with the current user and system FQDN host name in variable "path" </s> path="http://$(whoami).$(hostname -f)/path/to/file"
Replace "firstWord" with "newFirstWord", "secondWord" with "newSecondWord", "thirdWord" with "newThirdWord" in all XML files in the current directory tree </s> find -name "*.xml" -exec sed -s --in-place=.bak -e 's/firstWord/newFirstWord/g;s/secondWord/newSecondWord/g;s/thirdWord/newThirdWord/g' {} \;
Find all executable upvoter-* files (following symlinks) under maximum 1 level down the current directory </s> find -L -maxdepth 1 -name 'upvoter-*' -type f -perm /111
Strip all '\' and newlines from $output and save the result to variable 'output' </s> output=$(echo "$output" | tr -d '\' | tr -d '\n')
Display differences between /destination/dir/1 and /destination/dir/2 excluding files that match any pattern in file "exclude.pats". </s> diff /destination/dir/1 /destination/dir/2 -r -X exclude.pats
change the permission of all directories in current folder to 755. </s> find . -type d -exec chmod 755 {} \;
Counts lines in each of *.php files in current folder with subfolders and prints total count as well. </s> find . -name '*.php' | xargs wc -l | sort -r
Find all PHP files under current directory that contain only one line </s> find . -type f -name '*.php' -exec grep -Hcm2 $ {} + | sed -n '/:1$/{s///;p}'
Copies ${FILE} to COLLECT folder with unique name formatted like 'job_XXXXXXXXX'. </s> cp "${FILE}" "COLLECT/$(mktemp job_XXXXXXXXX)"
Remove all CVS directories from the current directory tree </s> find . -name 'CVS' -type d -exec rm -rf {} \;
Move all files from the `sourceDir' directory to the `destDir' directory </s> find sourceDir -mindepth 1 -maxdepth 1 -exec mv --target-directory=destDir '{}' +
Search the current directory recursively for files containing "needle text" </s> find . -type f -print0 | xargs -0 grep -IZl . | xargs -0 grep "needle text"
Find regular files with permissions less than 111 </s> find -perm -111 -type f
Append the date and command ran to "/tmp/trace" after every command </s> PROMPT_COMMAND='echo "$(date +"%Y/%m/%d (%H:%M)") $(history 1 |cut -c 7-)" >> /tmp/trace'
Archive all filepattern-*2009* files/directories under data/ into 2009.tar </s> find data/ -name filepattern-*2009* -exec tar uf 2009.tar {} ;
Set the setgid bit on all directories in the repository "/git/our_repos" </s> find /git/our_repos -type d -exec chmod g+s {} +
Change permission to 755 of all files/directories under current directory tree that have 777 permission </s> find -perm 777 | xargs -I@ sudo chmod 755 '@'
find all the ".wma" files in the folder "$current_directory" </s> find "${current_directory}" -type f -iname "*.wma"
force remove all the regular/normal files which begin with sess in the temp folder </s> find /tmp -type f -name sess* -exec rm -f {} \;
Save the contents of "numbers.txt" to variable "f" </s> f=$(cat numbers.txt)
Delete every second line from output of "seq 10" </s> seq 10 | sed '0~2d'
List all regular files from the current directory tree that were modified less than 60 minutes ago </s> find . -mmin -60 -type f | xargs ls -l
Locate all *.csv regular files under the current directory tree </s> find . -type f -name "*.csv"
Saves list of logged in users in system together with 'USER' header in the 'a' variable. </s> a=`w|cut -d' ' -f1`;
Find .rmv files in the ./root directory recursively and copy them to directory /copy/to/here </s> find root -name '*.rmv' -type f -exec cp {} /copy/to/here \;
Count the toal number of lines in all .py files in current directory tree </s> find . -name *.py -exec wc -l {} \; | awk '{ SUM += $0} END { print SUM }'
Remove all *.mp3 files in tmp directory but not in it's subdirectories </s> rm `find tmp -maxdepth 1 -name '*.mp3'`
Remove all files from the current directory tree whose names end in "~" </s> find -iname '*~' | xargs rm
Unsets shell option 'extglob'. </s> shopt -u extglob
Delete files under $LOCATION that match $REQUIRED_FILES in their names and were modified more than 1 day ago </s> find $LOCATION -name $REQUIRED_FILES -type f -mtime +1 -delete
Find all the files in the current directory </s> find * -type f -print -o -type d -prune
find files in the current directory with pattern` '*.[ch]' which are contain ‘thing’ string and print file names </s> find . -name '*.[ch]' | xargs grep -l thing
Find all files starting from the current directory which are exactly 100MB in size </s> find . -size 100M
Get domain names from file '1.txt' and request TXT DNS record for each one </s> cat 1.txt | xargs dig TXT
Find and list all regular files </s> find . -type f -ls
print all files in the current directory and all subdirectories </s> find . -print
Prints folder where current script is located </s> echo "dirname: `dirname "$0"`"
display the count of all the files in the current folder </s> find . -print | wc -l
List all environment variables (name and value) whose name either equals PATH or starts with GOBIN </s> env | grep '^\(GOBIN\|PATH=\)'
Identify CMS version/releases accross all your Wordpress websites </s> find /var/www/vhosts/*/httpdocs/ -type f -iwholename "*/wp-includes/version.php" -exec grep -H "\$wp_version =" {} \;
Sort and display the file name and creation month of top 11 files in the entire file system (Sort in the order of month ) </s> find / -type f -printf "\n%Ab %p" | head -n 11 | sort -k1M
Remove all regular files from the current directory tree that were modified between August 10th and August 17th </s> find . -type f -newermt "Aug 10" ! -newermt "Aug 17" -exec rm {} \;
find all the non compressed files in the current directory and compress them. </s> find . \! -name "*.Z" -exec compress -f {} \;
Save the canonical path of "$dir/$file" in variable "path" </s> path=`readlink --canonicalize "$dir/$file"`
Print a list of all *.code files from the current directory tree </s> find . -name *.code
Copies all files like 'lib*.so' to '~/usr/gtest/lib/' directory. </s> cp lib*.so ~/usr/gtest/lib
Display a named character dump of "test.sh" </s> od -a test.sh
Search the /Path directory tree for files matching pattern "file_name*" and containing "bar" in their pathnames </s> find /Path -name "file_name*" | grep "bar"
Find all broken symlinks under current directory </s> find . -type l -xtype l
Remove all .gz files in the current directory tree </s> find . -name '*.gz' -type f -printf '"%p"\n' | xargs rm -f
find all files with pattern` '*song*abc2009*.jpg' and replace "abc2009" with "def2010" </s> find . -name '*song*abc2009*.jpg' | sed 's/\(^.*song.*\)abc2009\(.*.jpg\)$/mv "&" "\1def2010\2"/' | sh
Find all files that contain the case insensitive regex 'stringtofind' in maximum 1 level down the / directory without descending into other partitions </s> find / -maxdepth 1 -xdev -type f -exec grep -Zli "stringtofind" {} +
Fetch 'stackoverflow.com' domain IP addresses from dig DNS lookup </s> dig stackoverflow.com | grep -e "^[^;]" | tr -s " \t" " " | cut -d" " -f5
Move "tobecopied/tobeexclude" to "tobeexclude" </s> mv tobecopied/tobeexclude tobeexclude;
Find all files/directories under current directory with 'foobar' (case insensitive) in their names and copy them to ~/foo/bar </s> find . -iname "*foobar*" -exec cp "{}" ~/foo/bar \;
search for a regular/normal file myfile in the folder "/home/weedly" </s> find /home/weedly -name myfile -type f -print
file1 and file2 contain lines of comma-separated information, for each line whose first field matches, and where 3rd field of file1 matches 2nd field of file2, 6th field of file1 matches 3rd field of file2, and 7th field of file1 matches 4th field of file2, output: fields 1, 2, 3, 4, 6, and 7 of file1. </s> join -t, file1 file2 | awk -F, 'BEGIN{OFS=","} {if ($3==$8 && $6==$9 && $7==$10) print $1,$2,$3,$4,$6,$7}'
Removes all files from current folder but 5 newest ones. </s> find . -maxdepth 1 -type f -printf '%T@ %p\0' | sort -r -z -n | awk 'BEGIN { RS="\0"; ORS="\0"; FS="" } NR > 5 { sub("^[0-9]*(.[0-9]*)? ", ""); print }' | xargs -0 rm -f
find all the empty directories in the current folder and all its sub directories too </s> find . -depth -empty -type d
Sort "file" using a buffer with a size 50% of main memory </s> sort -S 50% file
Read a line from standard input with prompt "Enter your choice: " and save response to variable "choice" </s> read -p "Enter your choice: " choice
Prints strings with text "texthere" in all files recursively in a current folder. </s> grep -r "texthere" .
Create a symolic link in "/usr/local/bin/" to "/Applications/Sublime\ Text\ 2.app/Contents/SharedSupport/bin/subl" </s> ln -s /Applications/Sublime\ Text\ 2.app/Contents/SharedSupport/bin/subl /usr/local/bin/
Recursively list all files on smbfs mounts </s> mount -v | grep smbfs | awk '{print $3}' | xargs ls -lsR
Save a random 4 byte unsigned integer from "/dev/urandom" to variable "RAND" </s> RAND=`od -t uI -N 4 /dev/urandom | awk '{print $2}'`
find all the files in the folder .home/calvin which have been modified in th last 45 minutes </s> find /home/calvin/ -mmin -45
Save "something" into variable "param" in ksh </s> echo something | read param
Find movies over a gigabyte in size </s> find ~/Movies/ -size +1024M
search for multiple files in the current folder </s> find . -name photoA.jpg photoB.jpg photoC.jpg
Recursively finds all files and prints all strings with 'text-to-find-here' from that files, preceding matched string with filename. </s> find ./ -type f -exec grep -H 'text-to-find-here' {} \;
Remove all files and directories called "test" from the current directory tree </s> find . -name test -delete
find files in /tmp directory that named are core and deletes them </s> find /tmp -name core -type f -print | xargs /bin/rm -f
display all the regular/normal files in current folder </s> find . -type f -print0
Search for 'some string' in all *js files under current directory and show the matched lines with line numbers </s> find . -name '*js' | grep -n  'some string'
Make directories "foo" and "bar" </s> mkdir foo bar
Get a two column list of all regular .rb files residing in the current directory tree </s> find . -name "*.rb" -type f -print0 | xargs -0 -n 2 echo
Numerically sort file "temp.txt" by the second "-" separated value of each line ordered from highest value to least value </s> tac temp.txt | sort -k2,2 -r -u
Resolve symbolic link of path of "python2.7" </s> readlink $(which python2.7)
Pops the top directory of dirs stack and changes to it. </s> popd
Print the $N'th line from file by replacing commas (',') with newlines </s> head -$N file | tail -1 | tr ',' '\n'
Set variable 'path' to name of current directory (without the containing directories) converted to lowercase. </s> path=$(basename $(pwd) | tr 'A-Z' 'a-z' )
Print all directories under $root appending a : (colon) at the end of each path </s> find $root -type d -printf '%p:'
Copy all regular files from the current directory tree to directory `TARGET' </s> find . -type f -exec cp -t TARGET {} \+
Sends current job to the background. </s> bg %
find the path of a specfic video file in the current directory </s> find ./ -name "foo.mp4" -printf "%h\n"
create directory ".hiddendir" </s> mkdir .hiddendir
List all files/directories under current directory </s> find . -ls
Change the permission to 0755 for all directories under current directory </s> find . -type d -exec chmod 0755 {} \;
download contents from "https://www.npmjs.com/install.sh" and execute </s> curl https://www.npmjs.com/install.sh | sh
Set permissions to 700 for every subdirectory of the current directory </s> find . -mindepth 1 -type d -print0 | xargs -0 chmod -R 700
List all regular files from the current directory tree that were modified less than 60 minutes ago </s> find . -mmin -60 -type f -exec ls -l {} \;
Find all files under /home/username/public_html/themes and set their permission to 640 </s> find /home/username/public_html/themes -type f -exec chmod 640 {} +
find all posix-extended regex  "[a-f0-9\-]\{36\}\.jpg" files </s> find . -regextype posix-extended -regex "[a-f0-9\-]\{36\}\.jpg"
Print numbers from 1 to 100 </s> seq 1 100
Find all files/directories under current directory and put the output into full_backup_dir variable </s> full_backup_dir="`find . -depth -print0`"
Delete all files under $DESTINATION directory tree that were modified more than 7 days ago </s> find $DESTINATION -mtime +7 -exec rm {} \;
Search for files/directories that are readable for everybody, have at least one write bit set but are not executable for anybody </s> find . -perm -444 -perm /222 ! -perm /111
Move all files listed in $i file to dir.$count directory </s> cat $i | xargs mv -t dir.$count
Set variable 'path' to name of current directory (without the containing directories). </s> path=$(basename $(pwd))
Search directory lpi104-6 for files with inode number 1988884 </s> find lpi104-6 -inum 1988884
Find files in the current directory tree whose size is greater than 24000 bytes </s> find . -size +24000c
Find files named 'core' in or below the directory /tmp and delete them </s> find /tmp -depth -name core -type f -delete
display all text, mpg, jpg files  in the folder /Users/david/Desktop </s> find /Users/david/Desktop -type f \( -name '*.txt' -o -name '*.mpg' -o -name '*.jpg' \)
find all the xml files in the current folder except those that are present in the workspace folder and create a tarball of these files </s> find . -name \*.xml | grep -v /workspace/ | tr '\n' '\0' | xargs -0 tar -cf xml.tar
Print joined strings from 'file', using space symbol as separator. </s> cat file | xargs
Search for all files in the current directory recursively whose names begin with "Linkin Park" </s> find . -name "Linkin Park*"
Search for "largecalculation" in all processes owned by the current user </s> ps -u `whoami` | grep largecalculation
Remove all *.tmp files from the /tmp directory tree </s> find /tmp -name "*.tmp" | xargs rm
find all the configuration files in the file system </s> find / -name "*.conf"
remove all the ".core" files in the file system </s> find / -name "*.core" -print -exec rm {} \;
Print the IP addresses of the host name </s> hostname -I
Print timestamp as HH:MM:SS </s> date +"%T"
display a long listing of all the files that begin with the name "Metallica" in the entire file system </s> find / -name 'Metallica*' -exec ls -l {} \;
display all files in current folder and follow the symbolic links and display the pointed file </s> find -L .
find all the files in the current folder which have been accessed in the last 60 minutes </s> find . -amin -60
display the count of total number of text files in the folder /home/you which have been modified in the last 60*24 hours </s> find /home/you -iname "*.txt" -mtime -60 | wc -l
Rename "new" to "old" and make a backup if "old" exists </s> mv new old -b
Prints calendars of July, 2009 and July, 2010 side-by-side. </s> paste <(cal 6 2009) <(cal 6 2010)
Find all directories in the current directory tree that do not have `execute' permissions for anyone </s> find . -type d ! -perm -111
Read a line from standard input with a timeout of 10 seconds </s> read -t 10
delete all the core files in the folder /prog which are bigger than 1KB </s> find /prog -type f -size +1000 -print -name core -exec rm {} \;
Count the number of files/directories with '.php' extension under current directory tree and change the permissions to 755 </s> find . -name "*.php" -exec chmod 755 {} \; -exec /bin/echo {} \; | wc -l
Copies all files like "*FooBar*" under the current directory to the '~/foobar' directory. </s> find . -name '*FooBar*' -exec cp -t ~/foobar -- {} +
find suffix tcl files under all directories started with 'n' </s> find ./n* -name "*.tcl"
Change all "JPG" filename suffixes in current directory to "jpeg". </s> rename -v 's/\.JPG/\.jpeg/' *.JPG
display all the files in the current folder excluding those that are present in the sub directory aa and display those files that start with the word "file" </s> find . \( -type d -name aa -prune \) -o \( -type f -name 'file*' -print \)
Search the current directory tree for regular files that contain "string" </s> find . -type f -print0 | xargs -0 grep string
find all the files in the current folder which which have been modified yesterday and day before yesterday and whose name is of length 1 </s> find . -name \? -daystart -mtime +0 -mtime -3
display all the regular files in the current folder that are exactly 10KB </s> find . -type f -size 10k
Find all files under current directory matching the regex '.*\(\(error\|access\)\(_log\)?\|mod_jk\.log\)\.[0-9]+' in their paths </s> find -type f -regex '.*\(\(error\|access\)\(_log\)?\|mod_jk\.log\)\.[0-9]+'
find the count of all the charcters of the list of regular files present in the current folder </s> find . -type f | xargs | wc -c
Save the numerically greater value of "$kf" and "$mp" into variable "gv" </s> gv=$(echo -e $kf'\n'$mp | sort -t'.' -g | tail -n 1)
search for files having python in filename </s> find / -name '*python*'
Extracts single file 'filename' from bzip2-compressed tarball archive.tbz. </s> bzip2 -dc archive.tbz | tar xvf - filename
Update timestamps of all files in entire filesystem which are not newer than /tmp/timestamp </s> find / ! -newer /tmp/timestamp -exec touch {} \;
Enables shell option 'autocd'. </s> shopt -s autocd
Show all files in /etc that are owned by root have been modified within the last minute </s> find /etc/ -user root -mtime 1
Display all files in the folder home which are owned by the group test. </s> find /home -group test
find file which case-insensitive name is foo in current directory. </s> find . -iname foo
Remove all empty regular files under the current directory and below </s> find ./ -type f -empty -print0 | xargs -0 rm
Delete all empty subdirectories in and below directory/ </s> find directory -mindepth 1 -type d -empty -delete
Print the list of all regular files on the system using "echo" </s> find / -type f -exec echo {} \;
Find and clear UTF-8 files with BOM </s> find . -type f -exec sed '1s/^\xEF\xBB\xBF//' -i.bak {} \; -exec rm {}.bak \;
display the commands to force delete all jpg files in current directory which are less than 50KB and do not search in the sub directories </s> find . -maxdepth 1 -name "*.jpg" -size -50k | xargs echo rm -f
Find files whose data was modified within the given days of the month </s> find ./ -daystart -mtime -10 -and -mtime +1
Search for the string 'foo' in *.html files under /usr/src/linux directory </s> grep foo `find /usr/src/linux -name "*.html"`
Find all files/directories under current directory and print their paths </s> find . -exec echo {} \+
Find recursively the files named "file" in the current directory ignoring all .git directories </s> find . -name .git  -prune -o -name file  -print
Show find's version </s> find --version
searches through the root filesystem ("/") for the file named Chapter1, and prints the location </s> find / -name Chapter1 -type f
find all directories with the name root in the entire file system. </s> find / -type d -name root
Print the list of files in the current directory tree skipping SVN files </s> find . -path '*/.svn*' -prune -o -print
Recursively changes group ownership on everything in the 'public_html' folder to 'website' group. </s> chgrp --recursive website public_html
split processed content of the file temp into pieces per 1 line named "tempNNN" with numeric suffix </s> sed 's/3d3d/\n&/2g' temp | split -dl1 - temp
Display all symlinks and their targets in the current directory </s> find -P .  -maxdepth 1 -type l -exec echo -n "{} -> " \; -exec readlink {} \;
Find all files with the name "MyProgram.c" in the current directory and all of it's sub-directories. </s> find -name "MyCProgram.c"
list all javascipts file which whole name does not contain excludeddir </s> find . -name '*.js' | grep -v excludeddir
Split "$file" into files with at most 1000 lines each and use a prefix length of 5 </s> split -a 5 $file
find all the files in the entire file system that have been modified exactly  50 days ago </s> find / -mtime 50
find all the files in the entire file system that have been changed exactly  60 days  and display ten files </s> find / -cmin -60 | head
Find all files in the current directory tree that match pattern 'a(b*' </s> find . -name 'a(b*' -print
Composes full process tree with process id numbers, and prints only those strings that contain 'git'. </s> pstree -p | grep git
Set permissions to 400 for regular files under the current directory </s> find . -type f -exec chmod 400 {} \;
display all normal/regular files in current  folder </s> find . -type f
display a long listing of all the directories in current directory </s> find . -type d -ls
Print a count of each unique line from standard input </s> sort | uniq -c
Read lookup requests from text file '1.txt' and uses them to fetch TXT records. </s> dig TXT -f 1.txt
find all files that have been used more than two days since their status was last changed </s> find -used +2
Save hexadecimal byte 10 in binary file "file.moi" to variable "day" </s> day=$(od -t x1 --skip-bytes=9 --read-bytes=1 file.moi | head -1 | awk '{print $2}')
get a PID of a process with name 'test.sh &' </s> jobs -l | grep 'test.sh &' | grep -v grep | awk '{print $2}'
Find all regular files in the current directory and its subdirectories. </s> find . -type f
Read a line from standard input in an interactive shell into variable "input" with prompt "Do that? [Y,n]" and suggestion "Y" </s> read -e -p "Do that? [Y,n]" -i Y input
Run an awk program on every TXT file found in the current directory tree </s> find . -name "*.txt" -print -exec awk '{if($9!=""&&n<11){print;n++}}' {} \;
display all the php files in the current folder which do not have the permission 644 </s> find . -type f -name "*.php" ! -perm 644
Find all files/directories under /myfiles that are 2560 bytes in size </s> find /myfiles -size 5
change cgi files to mode 755 under htdocs or cgi-bin directories </s> find htdocs cgi-bin -name "*.cgi" -type f -exec chmod 755 {} \;
recursively change owner of the directory and all files into it to user  nobody </s> chown -R nobody upload_directory
Recursively finds all files and prints only names of files that contain "word" and suppressing error messages . </s> find . | xargs grep 'word' -sl
delete all the text files in the current folder </s> find . -type f -name "*.txt" -delete
Replace all commas with tab characters in 'filename.csv' and page interactively through the result. </s> sed "s/,/\t/g" filename.csv | less
Search for files/directories with the case insensitive pattern anaconda.* in var/log directory and create an archive (file.tar) of the last file found </s> find var/log/ -iname anaconda.* -exec tar -cvf file.tar {} \;
Change the owner of all files in the current directory tree excluding those who match "./var/foo*" to "www-data" </s> find . -not -iwholename './var/foo*' -exec chown www-data '{}' \;
Calculate the md5 sum of all ".py" files in "/your/dir" including content and filenames </s> grep -ar -e . --include="*.py" /your/dir | md5sum | cut -c-32
Remove empty folder, and skip error message if one is not empty. </s> rmdir --ignore-fail-on-non-empty newBaseDir/Data/NewDataCopy
Set the 'xtrace' shell option </s> set -x
search for the word error in all the xml files in the current folder </s> find . -name "*.xml" -exec grep "ERROR" /dev/null '{}' \+
Display a list of files with sizes in decreasing order of size of all the regular files under '/your/dir' directory tree that are bigger than 5 MB in size </s> find /your/dir -type f -size +5M -print0 | xargs -0 ls -1Ssh
Search for 'example' in all regular files under current directory tree and also print the filenames </s> find . -type f -exec grep "example" '{}' \; -print
List all empty files in the current directory tree </s> find . -type f -empty
Extract and print hostname and protocol part from URL like "http://www.suepearson.co.uk/product/174/71/3816/". </s> echo "http://www.suepearson.co.uk/product/174/71/3816/" | cut -d'/' -f1-3
Print last 10 commands in history with the first 7 characters removed </s> history 10 | cut -c 8-
Find and print the names of all files found in the current directory and all of its sub-directories. </s> find . -print
Find all *.php (case insensitive) files and *.js files/directories (case insensitive) under /home/jul/here excluding /home/jul/here/exclude/* paths </s> find /home/jul/here -type f -iname "*.php" ! -path "/home/jul/here/exclude/*" -o -iname "*.js" ! -path "/home/jul/here/exclude/*"
display the names without extensions of all the data files in current folder which have not been changed in the last 60 mins </s> find ./ -name "*.dat" -type f -cmin +60 -exec basename {} \;
Find user daniel's files of type jpeg without `autumn' in the name </s> find . -user daniel -type f -name *.jpg ! -name autumn*
Change permissions of all directories residing under and below ./debian to 755 </s> find ./debian -type d | xargs chmod 755
Print the path of all the network mounts </s> mount | sed -n -e "s/\/\/mynetaddr on \([^ ]*\).*$/\1/p"
Shows state of 'extglob' shell option. </s> shopt -o extglob
List files larger than 10MB under /var/log /tmp that haven't changed in a month </s> find /tmp /var/tmp -size +30M -mtime 31 -print0 | xargs -0 ls -l
Print the most recently modified file </s> ls -1tr * | tail -1
compresses all the files in the current folder with default depth </s> find . -depth -print | cpio -dump /backup
find regular file named foo.txt under root / directory. </s> find / -name foo.txt -type f -print
Find all *.txt files under current directory and print their timestamps and paths </s> find . -name "*.txt" -printf "%T+ %p\n"
display the number of lines in all the ".c" files in the current folder </s> find . -name "*.c" -exec wc -l {} \;
Write output of "ls -lR /" to standard output and append to "output.file" </s> ls -lR / | tee -a output.file
Find all files under directory tree /path/to/dir whose permissions are not 644 </s> find /path/to/dir ! -perm 644
Find all executables in the current directory tree </s> find ./ -executable
Create a symbolic link to file "/usr/bin/perl" named with escaped characters "/usr/local/bin/perl\r\n" </s> sudo ln -s /usr/bin/perl /usr/local/bin/perl`echo -e '\r'`
Opens gcc info manual and selects "option index" menu entry. </s> info gcc "option index"
Find all *.cgi files/directories under current directory and change their permission to 755 </s> find . -name '*.cgi' -print0 | xargs -0 chmod 755
Prints sequentially listing of a current folder and calendar of a current month. </s> echo `ls` "`cal`"
Displays calendar for a previous, current and next month. </s> cal -3
For each .def file under the current directory, create an empty .def.out file with current timestamp. </s> find . -name '*.def' | sed 's/\(.*\)/\1.out/' | xargs touch
List *.txt files residing in the current directory tree </s> find . -name *.txt -exec ls {} ;\
Remount "/dev/sda7" partition as executable </s> sudo mount -o remount -o exec /dev/sda7
Find all files under current directory and print them appending a null character at the end of each file paths </s> find . -type f -print0
Find all *.txt files of user Tecmint under /home directory </s> find /home -user tecmint -iname "*.txt"
Print canonical filename of "/path/here/.." </s> readlink -f  /path/here/..
Replace all instances of "STRING_TO_REPLACE" with "STRING_TO_REPLACE_IT" in file "index.html" and make a backup with suffix ".bak" </s> sed -i.bak s/STRING_TO_REPLACE/STRING_TO_REPLACE_IT/g index.html
display all the files in current folder which are bigger than 10KB </s> find . -size +10k
List all aliencoders.[0-9]+ files/directories under /home/jassi/ directory </s> find /home/jassi/ -name "aliencoders.[0-9]+" |& xargs ls -lrt | awk '{print $9}'
Numerically sort file "table" by the fourth character of the second field, ignoring leading spaces </s> sort -b -n -k2.4 table
Finds $a pattern in a $b string, and returns exit code 0 if found, suppressing any visible output. </s> echo $b|grep -q $a
update the permissions of the directories in the folder folder_name to 775 </s> find folder_name -type d -exec chmod 775 ‘{}’ \;
search in the current folder for the file with the name "test" </s> find . -name test
change owner of the files into directory "/mydir" with ".txt" extension to user root </s> find /mydir -type f -name "*.txt" -print0 | xargs -0 chown root $(mktemp)
Find all regular files that reside in the current directory tree and were last modified more than 2 days ago </s> find . -type f -mtime +2
Find all foo.mp4 files in the current directory tree and print the pathnames of their parent directories </s> find . -name foo.mp4 | sed 's|/[^/]*$||'
Counts lines in each of *.php files in a current folder and subfolders and prints total count. </s> find . -name '*.php' | awk '{gsub(" ","\\ ", $0);print $0}' |xargs wc -l
Write every two lines in "infile" on a single line separated by a space </s> cat infile | paste -sd '  \n'
Lists all subdirectories in a current folder, removing trailing slash. </s> ls -d */|sed 's|[/]||g'
Find all *.c files under and below the current directory that contain "wait_event_interruptible" </s> find . -name \*.c -print | xargs grep wait_event_interruptible /dev/null
Save 'echo whatever you "want your" command to be' in history </s> history -s 'echo whatever you "want your" command to be'
display all the files in the file system which belong to no user </s> find / -nouser -print
Prints long listing of content in a root folder, including hidden files, with human-readable sizes, and stores output to '/root/test.out' file. </s> ls -hal /root/ | sudo tee /root/test.out
Show all files in user's home directory that have read, write and execute permissions set for user, group and others. </s> find ~ -perm 777
Identify CMS version/releases accross all your PHPBB installations </s> find /home/*/public_html/ -type f -wholename *includes/constants.php -exec grep -H "PHPBB_VERSION" {} \;
Go back to last directory. </s> cd -
Finds all php processes running in system. </s> pstree | grep php
Find files/directories that are newer than 'foo.txt' under current directory tree </s> find -newer foo.txt
find all the files in the file system which have sticky bit enabled to the user </s> find / -perm -u+s
Print full path of command "c++" </s> which c++
Searches the manual pages with descriptions in section 3, that name begins with lowercase letter. </s> apropos -s 3 . | grep ^[a-z]
Read the first line of output from "du -s $i" into variable "k" in ksh </s> du -s $i | read k
display a long listing of the files all non emoty files in current folder which have been modified 60 minutes ago </s> find . -mmin 60 -print0 | xargs -0r ls -l
Find all files/directories that are not newer than Jul 01 by modification time </s> find /file/path ! -newermt "Jul 01"
Make all the bugzilla subdirectories permission 775 </s> find bugzilla -type d -exec chmod 775 {} \;
Find all *fink* files/directories in entire file system </s> find / -name "*fink*" -print
find all the backup files in the current folder and delete them </s> find . -type f -name "*.bak" -exec rm -f {} \;
create a gzip of all the files in the current folder excluding the already gzipped files. </s> find . \! -name "*.gz" -exec gzip {} \;
Delete all files in the /myDir directory tree that were last modfied 7 days ago </s> find /myDir -mindepth 1 -mtime 7 -delete
Search only for directories </s> find -type d
Search directory trees /usr/share/doc, /usr/doc, and /usr/locale/doc for files named 'instr.txt' </s> find /usr/share/doc /usr/doc /usr/locale/doc -name instr.txt
Replace "_" with newlines in "Testing\r\nTested_Hello_World" and display the named characters </s> echo -e "Testing\r\nTested_Hello_World" | awk -v RS="_" '{ print $0; }' | od -a
print apparent size rather than disk usage </s> du -B1 --apparent-size /tmp/foo.txt
Find all files/directories named '.todo' under $STORAGEFOLDER directory tree and print their parent paths </s> find "$STORAGEFOLDER" -name .todo -printf '%h\n'
Archive all *.xml files under current directory tree to xml.tar excluding the files that match '/workspace/' in their paths </s> find . -name \*.xml | grep -v /workspace/ | tr '\n' '\0' | xargs -0 tar -cf xml.tar
Remove all CVS directories in the current directory tree </s> find . -type d -name CVS -exec rm -r {} \;
search normal files called ' banckup '  from /usr directory downward and print them. </s> find /usr -type f -name backup -print
display all the regular/normal files in the entire file system </s> find / -type f -exec echo {} \;
List all files in /home/bozo/projects directory tree that were modified within the last day. </s> find /home/bozo/projects -mtime -1
Keep the last 3 components (directories) of $path </s> echo $path | rev | cut -d'/' -f-3 | rev
display the name and size of all the regular/normal files  in the var/log folder which are bigger than 100MB </s> find /var/log -type f -size +100000k -exec ls -lh {} \; | awk '{ print $9 ": " $5 }'
find all the files which start with the name "Metallica" in the folder "/mp3-collection" and which are bigger than 10MB </s> find /mp3-collection -name 'Metallica*' -and -size +10000k
Find all files in current directory and search for 'searchName' in those files and show errors for files that are not directly on the current directory </s> find ./ -name "*" -printf "%f\n" | xargs grep "searchName"
Create a symbolc link in the current directory to "target" </s> ln -s target
Read a line from standard input into variable "SSHPASS" with prompt "Password: " and without echoing the input </s> read -p "Password: " -s SSHPASS
search for the word text in all the python files in the current folder </s> find . -iname '*py' -exec grep "text" {} \;
display all symbolic links in the folder "myfiles" </s> find /myfiles -type l
find all the files starting with "config" in the folder Symfony </s> find Symfony -name '*config*';
Continuously send "y" to all prompts of command "rm" </s> yes | rm
Find all files/directories under current directory tree excluding files/directories with name 'query_to_avoid' </s> find -not -name "query_to_avoid"
Find files/directories in entire file system that were modified a day ago </s> find / -mtime 1
List all files in current directory whose name or file type description contains the word "ASCII". </s> file * | grep ASCII
Show the number of regular files in the current directory tree </s> find . -type f | wc -l
Find all files whose names begin with 'Makefile' at the /usr/ports directory tree's level 3 and count the number of lines with NOPORTDOCS or NOPORTEXAMPLES in them. </s> find /usr/ports/ -name Makefile\* -mindepth 3 -maxdepth 3 -exec egrep "NOPORTDOCS|NOPORTEXAMPLES" '{}' '+' | wc -l
Sort "," delimited lines in "file" by the first field preserving only unique lines </s> sort -u -t, -k1,1 file
Print the base name via grep of the current working directory </s> pwd | grep -o '[^/]*$'
Change permissions to 644 for all regular files under the /path/to/dir/ tree unless these permissions are already set </s> find /path/to/dir ! -perm 0644 -exec chmod 0644 {} \;
Go into the first directory whose name contains 1670 </s> cd $(ls -d */ | grep 1670)
List files larger than 9MB residing in the current directory and below </s> find . -size +9M
List .log files from the current directory tree </s> find . -name "*.log" -exec echo {} \;
find all the directories in the current folder and replace the </s> find -type d|sed -r '/^.$/{s:.:#!/bin/bash:};{s/^\./mkdir -p &/}'
Recursively copies '$1' directory to '$2' directory. </s> cp -r $1 $2
Display the contents of "file" formatted into a table, removing duplicate lines where the first 12 characters are duplicates, and display the number of occurrences at the beginning of each line. </s> column -t file | uniq -w12 -c
Find all directories under /home/username/public_html/sites/all/themes and set their permission to 750 </s> find /home/username/public_html/sites/all/themes -type d -exec chmod 750 {} +
Decompresses file. </s> bzip2 -d /tmp/itunes20140618.tbz
search  all block spacial files called backup from /usr directory downwards and print them . </s> find /usr -type b -name backup -print
Force the group stickiness for directories under /var/www </s> find /var/www -type d -print0 | xargs -0 chmod g+s
Find all .py files in the current directory except "setup.py" and those beginning with "test_" </s> find . -maxdepth 1 -mindepth 1 \( -name '*.py' -not -name 'test_*' -not -name 'setup.py' \)
show all the files in the current folder which has the word "ITM" </s> find . -name ‘*ITM*’
Prints path to folder that contains file "/path/to/vm.vmwarevm/vm.vmx". </s> dirname "/path/to/vm.vmwarevm/vm.vmx"
calculate the total size of jpg files in current folder </s> find . -name "*jpg" -exec du -k {} \; | awk '{ total += $1 } END { print total/1024 " Mb total" }'
Run checksums recursively from the current directory, and give back the filenames of all identical checksum results </s> find ./ -type f -print0 | xargs -0 -n1 md5sum | sort -k 1,32 | uniq -w 32 -d --all-repeated=separate | sed -e 's/^[0-9a-f]*\ *//;'
Replace each non-blank line in "YOURFILE" preceded with "pX=" where "X" is the line number </s> grep -v '^$' YOURFILE | nl -s= -w99 | tr -s ' ' p
Copy "src/prog.js" and "images/icon.jpg" to "/tmp/package/" keeping relative path names </s> rsync -Rv src/prog.js images/icon.jpg /tmp/package/
Print a single line of numbers from "001" to "100" </s> yes | head -n 100 | awk '{printf( "%03d ", NR )}'   ##for 001...100
Decompress 'file.gz' to standard output and execute the output in bash </s> gzip -d --stdout file.gz | bash
Print the list of files and directories of the /etc directory </s> find /etc   ! -name /etc
Find all *~ files/directories under dir and  print an rm command for each of them for deletion </s> find dir -name \*~ | xargs echo rm
Sort file.txt ignoring the last 10 characters of each line. </s> sort file.txt | rev | uniq -f 10 | rev
Find all *.dbf files/directories in entire file system </s> find / -name "*.dbf"
Search for 'example' in all regular files from the current directory </s> find -maxdepth 1 -type f | xargs grep -F 'example'
Report all files starting in the directories /mydir1 and /mydir2 larger than 2,000 blocks that have not been accessed in over 30 days </s> find /mydir1 /mydir2 -size +2000 -atime +30 -print
Search the "test1" directory recursively for regular files named "textfile.txt" </s> find test1 -type f -name 'textfile.txt' -print
Find files in the current directory tree whose content was changed within the last 60 minutes </s> find . -mmin -60
Find all files/directories that do not belong to any user under '/home' directory tree </s> find /home -nouser -print
Find all files/directories under test directory </s> find test
find all text files in current folder and trim the extra spaces in all lines in these files </s> find . -type f -name '*.txt' -exec sed --in-place 's/[[:space:]]\+$//' {} \+
Find files containing string "#!/bin/ksh" and append their names and matching strings to /tmp/allfiles </s> find . -type f -print | xargs /usr/bin/grep -il 'bin/ksh' | tee /tmp/allfiles
find all the "error_log" files in the folder "/home" which are bigger than 5MB and force delete them </s> find /home -size +5000000b -name "error_log" -exec rm -rf {} \;
Reverse the space separated words in "35 53 102 342" </s> echo 35 53 102 342|tr ' ' '\n'|tac|tr '\n' ' '
Print the first 10 files or directories found in the /tmp directory tree by `find' </s> find /tmp  | head
find all the normal/regualar files in the current folder which have a size of 10KB and display a long listing details of them. </s> find . -type f -size +10000 -exec ls -al {} \;
this find command Substitute space with underscore in the file name replaces space in all the *.mp3 files with _ </s> find . -type f -iname '*.mp3' -exec rename '/ /_/'  {} \;
Creates temporary file and saves path to it in 'content_dir2' variable. </s> content_dir2=$(mktemp)
Remove all "work" directories residing in /usr/ports and below </s> find /usr/ports/ -name work -type d -print -exec rm -rf {} \;
Find all regular files with 755 permission under current directory tree and change their permission to 644 </s> find . -type f -perm 755 -exec chmod 644 {} \;
Compress from standard input and print the byte count preceded with 'gzip.' </s> echo gzip. $( gzip | wc -c )
Print file information of the executable file of command "gcc" </s> ls `which gcc` -al
Search for files/directories which are writable by either their owner or their group </s> find . -perm /u=w,g=w
Search the /path directory tree for regular files </s> find /path -type f
Read a line from standard input into variable "message" with the prompt "Please Enter a Message: $cr" </s> read -p "Please Enter a Message: $cr" message
Search .c and .h files in the current directory tree for "expr" </s> find . -name '*.[ch]' | xargs grep -E 'expr'
Removes 'latest' folder if empty. </s> rmdir latest
Counts lines of /dir/file.txt file. </s> wc -l /dir/file.txt
display the filenames which do not have begin with dot (.) </s> find . -maxdepth 1 -name '[!.]*' -printf 'Name: %16f Size: %6s\n'
Recursively removes all files like '*.pyc' in a current folder. </s> find . -name "*.pyc" -exec rm -rf {} \;
Recursively finds strings like "texthere"  in all "*.txt" files of a current folder. </s> grep -r --include "*.txt" texthere .
Run "./configure" with a new environment variable CC set to the full path of the command 'gcc' </s> CC=$(which gcc) ./configure
Find all  'custlist*' files under current directory </s> find . -name custlist\*
Find & Substitute Only 2nd Occurrence of a Word Using sed s//2 in all .txt files </s> find . -type f -name "*.txt" -exec sed 's/Linux/Linux-Unix/2' thegeekstuff.txt
Removes empty folder 'symlink'. </s> rm -d symlink
Find all symlinks in the /myfiles directory tree </s> find /myfiles -type l
Find all files recursively which end in ".php" </s> find . -name "*.php" -print
find the oldest normal file in the current directory </s> find -type f -printf '%T+ %p\n' | sort | head -n 1
Print position number of day '9' in fourth line of calendar output for September, 2009. </s> cal 09 2009 | awk '{day="9"; if (NR==4) {col=index($0,day); print col } }'
Delete all but the most recent 5 files </s> ls -tr | head -n -5 | xargs rm
Calculate md5 sum of the md5 sum of all the sorted files under $path </s> find "$path" -type f -print0 | sort -z | xargs -r0 md5sum | md5sum
Find recursively the latest modified file in the current directory </s> find . -type f -printf '%T@ %p\n' | sort -n | tail -1 | cut -f2- -d" "
Print your/dir if it's empty </s> find "your/dir" -prune -empty
Find all the files under /tmp directory and show a few lines of output from the beginning </s> find /tmp  | head
Search the current directory up to depth level 2 for files and directories </s> find . -maxdepth 2
Find symbolic links in lpi104-6 and research/lpi104-6 to files whose pathnames end in "file1" </s> find lpi104-6 research/lpi104-6 -lname "*file1"
Extract five digits sequence from a filename with x number of alphanumeric characters followed by the five digit sequence surrounded by a single underscore on either side then another set of x number of alphanumeric characters. </s> echo 'someletters_12345_moreleters.ext' | cut -d'_' -f 2
find all the regular/normal files in the current directory and print them skip searching all the directories in the current folders. </s> find * -type f -print -o -type d -prune
Find files under /usr that are newer than the first file `FirstFile' </s> find /usr -newer /usr/FirstFile -print
check if myfile has 0644 permissions </s> find myfile -perm 0644 -print
Search for 'string_to_find' in all files under current directory </s> find -type f | sed 's/./\\&/g' | xargs grep string_to_find
Store info about all mounted file systems, printing all sizes in powers of 1000 </s> a=$( df -H )
Remove all files whose names end with "~" in the /home/peter directory tree </s> find /home/peter -name *~ -print0 |xargs -0 rm
show all files in the current directory and all subdirectories </s> find . -print
Read a single character from standard input with prompt "Is this a good question (y/n)?" and save the response to variable "answer" </s> read -n 1 -p "Is this a good question (y/n)? " answer
display all the ".c" files which have been modified in the last 10 minutes </s> find /home/david -amin -10 -name '*.c'
display all the trace files (".trc") from the folder $DBA/$ORACLE_SID/bdump/ which have not been accessed in the last 7*24 hours </s> find $DBA/$ORACLE_SID/bdump/*.trc -mtime +7
List all paths to files or directories under "/data/" that start with "command-" and end with "-setup", sort the result by the version number specified between "command-" and "-setup" (least to greatest) </s> find /data/ -name 'command-*-setup' | sort -t - -V -k 2,2
Get the disk space used by all *.txt (case insensitive) files/directories under current directory </s> find . -iname "*.txt" -exec du -b {} + | awk '{total += $1} END {print total}'
delete all instances of the file "bad" if its size is 0 bytes </s> find . -name bad -empty -delete
List all files from the current directory tree that were modified less than 60 minutes ago, omitting "." </s> find . -mindepth 1 -mmin -60 | xargs -r ls -ld
Traverse the filesystem just once, listing setuid files and directories into /root/suid.txt and large files into /root/big.txt. </s> find /       \( -perm -4000 -fprintf /root/suid.txt '%#m %u %p\n' \) , \              \( -size +100M -fprintf /root/big.txt  '%-10s %p\n' \)
search for the word echo all the bash files(files ending with .bash) in the current folder </s> find . -name "*.bash" |xargs grep "echo"
find all the core files in the entire file system and  delete them </s> find / -name core -exec rm -f {} \;
Locate symlinks in directory trees lpi104-6 and research/lpi104-6 </s> find lpi104-6 research/lpi104-6 -type l
Find files in the /var/log folder which were modified modified 2 weeks ago </s> find /var/log/ -mtime +7 -mtime -8
Search for the string 'device' in all regular files in the entire filesystem </s> find / -type f -print | xargs grep "device"
find all the php/javascript files in current folder using regular expressions </s> find . -regex '.+\.\(php|js\)'
delete all the files in the current folder which end with ".bak" or ".backup" and which have not been accessed in the last 30 days </s> find . ( -name '*.bak' -o -name *.backup ) -type f -atime +30 -exec rm '{}' ;
find all the files in the current folder that have been accessed in today </s> find -atime 0
Find files in the current directory tree that are named "some_pattern" and move them to directory "target_location" </s> find . -name some_pattern -print0 | xargs -0 -i mv {} target_location
find all the files that are modified in the last 1 day </s> find  -mtime -1
Find recursively all files under current directory tree that contain a colon in the filename </s> find . -name \*\:\*
Change permissions for all PHP files under the current directory tree to 755 </s> find . -name "*.php" -exec chmod 755 {} \;
Remove `core' files whose status was changed more than 4 days ago </s> find `pwd` -name core -ctime +4 -execdir /bin/rm -f {} \;
Find all *.c files under and below the current directory that contain "wait_event_interruptible" </s> find . -name \*.c -print0 | xargs -0 grep wait_event_interruptible /dev/null
Print content of 'a' file, showing all non-printing characters including TAB characters, and displaying $ at the end of each line. </s> cat -vet a
Search for 'string-to-find' in all HTML files under current directory tree and show the matched lines with their filenames </s> find . -name \*.html -exec grep -H string-to-find {} \;
display all the files in the folder /home which do not belong to the group test </s> find /home -not -group test
Find all directories whose status were changed $FTIME days ago </s> find . -type d -ctime $FTIME
Counts total number of only lines with alphanumeric symbols in all *.php files in a current folder and subfolders. </s> find . -name '*.php' | xargs cat | awk '/[a-zA-Z0-9]/ {i++} END{print i}'
Print the contents of "file" in reverse order </s> nl file | sort -nr | cut -b8-
Finds all user session in system, and shows sorted user names with number of sessions of each user. </s> w | sed '1,2d' | cut -f1 -d' ' | sort | uniq -c
Archive "/local/path/some_file" to "/some/path" on host "server.com" authenticating as user "usr", compress data during transmission, show progress details. </s> rsync -avz --progress local/path/some_file usr@server.com:"/some/path/"
Print the filenames taken by the glob pattern * with null character as the delimiter </s> find * -maxdepth 0 -type d -print0
Find all symbolic links containg 'vim' in their names under '/usr/bin' directory tree </s> find /usr/bin -name '*vim*' -type l
Count the number of lines in "/etc/fstab" </s> cat /etc/fstab | wc -l
delete all the files in the current folder  which do not belong to any user </s> find / -nouser -exec rm {}\;
Find x* files/directories under /tmp directory whose status was changed less than 1 day ago </s> find /tmp/ -ctime -1 -name x*
Delete all regular files that start with 'sess_' in their names, are at least 1 level deep and were modified more than $gc_maxlifetime minutes ago under $save_path directory tree </s> find -O3 "$save_path" -depth -mindepth 1 -name 'sess_*' -ignore_readdir_race -type f -cmin "+$gc_maxlifetime" -delete
Gets IP address of 'eth0' network interface. </s> ifconfig eth0 | grep 'inet addr:' | cut -d: -f2 | awk '{print $1}'
Find file1 in the level 1 directories and above </s> find -maxdepth 2 -name file1
as root, find from / all files called "file.txt" </s> sudo find / -name file.txt
Synchronize "/path/to/dir_a" with files in "/path/to/dir_b/" if the files are newer </s> rsync -rtuv /path/to/dir_b/* /path/to/dir_a
Find all files which have 211028 inode number in current directory then Locating and renaming unprintable directories </s> find . -inum 211028 -exec mv {} newname.dir \;
Find all files/directories under /var/www/some/subset and change their owner and group to www-data </s> sudo find /var/www/some/subset -print0 | xargs -0 chown www-data:www-data
list files that the user does not have permissions to read, do not try to descend into directories that cannot be read. </s> find . ! -perm -g+r,u+r,o+r -prune
Find all regular files in the current directory tree ignoring GIT and SVN directories </s> find . \( -type d -regex '^.*/\.\(git\|svn\)$' -prune -false \) -o -type f -print0
Search for files with "demo" in their names and "sitesearch" in their path names </s> find . -iname '*demo*' | grep -i sitesearch
find all the text files in the current folder </s> find . -type f -name '*.txt' -print
Copies all files like "*FooBar*" under the current directory to the '~/foo/bar' directory. </s> find . -name '*FoooBar*' | sed 's/.*/"&"/' | xargs cp ~/foo/bar
find all the text files in the current directory which have been modified in the last 4 days and not today and copy them to another folder </s> find . -name "*.txt" -type f -daystart -mtime -4 -mtime +0|xargs -i cp {} /home/ozuma/tmp
Find all flies under current directory excluding *.png files and print the file paths (with match count) that match the case insensitive regex 'foo=' in their contents </s> find . -not -name '*.png' -o -type f -print | xargs grep -icl "foo="
display all normal/regular files in a folder </s> find /home/the_peasant -type f
find directories under the $LOGDIR directory where there have been no modifications for 5 days and deletes them. </s> find $LOGDIR -type d -mtime +5 -exec rm -f {} \;
Creates temporary file in a current folder and saves path to it in 'f' variable. </s> f=`mktemp -p .`
For each line whose first field is the same in file1 and file2, output the common first field followed by all other fields in file1 and file2. </s> join -j1 file2 file1
Use ANSI escape codes to make "World" bold from input "Hello World!" </s> echo 'Hello World!' | sed $'s/World/\e[1m&\e[0m/'
search for text files in the current folder which have write access to others </s> find . -type f \( -iname "*.txt" -and -perm -o=w \)
find all the swap files (files ending with ~) in the current folder and delete them </s> find . -name "*~" -exec rm {} \;
display the count of number of files in the current folder </s> find | wc -l
search all the files in the current folder using regex excluding those that are present in the folder test </s> find . -name test -prune -o -regex ".*/my.*p.$"
print lines from last match of ^Statistics until end of file </s> tac INPUTFILE | sed '/^Statistics |/q' | tac
Find all files with the extension jpg regardless of case </s> find . -type f -iname '*.jpg' -print0
Read a line from standard input with prompt "Continue (y/n)?" and save response in variable "choice" </s> read -p "Continue (y/n)?" choice
Find all files under current directory tree named 'filename_regex' excluding '.svn' and '.pdv' directories and files then search for the case insensitive pattern 'your search string' in those files </s> find . -name "filename_regex"|grep -v '.svn' -v '.pdv'|xargs grep -i 'your search string'
Print 'cp' commands that would copy a file xyz.c to all the files with '.c' extension present in the ./C directory and below </s> find ./C -name "*.c" | xargs -n1  echo cp xyz.c
Search the files from the current directory tree for "chrome" </s> find . -exec grep chrome {} +
List each unique character in "file" prefixed by number of occurrences </s> grep -o . file | sort | uniq -c
Find all files with '.txt' extension under '/home/my_dir' dirctory tree and display the number of lines in these files </s> find /home/my_dir -name '*.txt' | xargs grep -c ^.*
Search the /path directory tree for files lacking the group writable bit </s> find /path ! -perm /020
Find "file.xml" under the current directory and change directory to its parent </s> cd `find . -name file.xml -exec dirname {} \;`
List each subdirectory name composing the current working directory </s> pwd | cut -f 1- -d\/ --output-delimiter=$'\n'
Update timestamps of all files and directories under directory /path/to/dir. </s> find /path/to/dir -print0 | xargs -0 touch
Search the /root directory recursively for the regular file named "myfile" ignoring /root/work/ </s> find /root/ -path '/root/work' -prune -o -name myfile -type f -print
Recursively find the latest modified file in the current directory </s> find . -type f -printf '%T@ %p\n' | sort -n | tail -1 | cut -f2- -d" "
Add read and execute permission to every directory under the current directory </s> find . -type d -exec chmod +rx {} \;
Find all regular files undee '/usr/bin' directoryt tree that are less than 50 bytes in size </s> find /usr/bin -type f -size -50c
display all the files in the current folder which have the permissions 777 and which have been modified in the last 24 hours. </s> find . -perm 777  -mtime 0 -print
find the oldest normal file in the current directory </s> find . -type f -print0 | xargs -0 ls -ltr | head -n 1
Sort all files/directories under current directory according to modification time and print only the recent 7 of them </s> find -mindepth 1 -printf "%T@ %P\n" | sort -n -r | cut -d' ' -f 2- | tail -n +7
change the ownership of all the files in the file system from edwarda to earnestc </s> find / -user edwarda -print | xargs chown earnestc
Change directory to the current user's home directory </s> cd /home/`whoami`
Update the archived copy of the home directory, "alldata.tar" </s> find ~/ -newer alldata.tar -exec tar uvf alldata.tar {} ;
search for a word in all the php files in the current folder and display the count of all matching lines. </s> find . -name \*.php -type f -print0 | xargs -0 -n1 grep -Hn '$test' | wc -l
Merge already sorted files "file*.txt" and split the result into files of at most 100000 lines each with a prefix "sorted_file" </s> sort --merge file*.txt | split -l 100000 - sorted_file
Rename all "thumbs" directories to "thumb" in the current directory tree </s> find . -type d -exec rename 's/^thumbs$/thumb/' {} ";"
Find all regular files in the current directory tree that match pattern 'btree*.c' </s> find . -type f -name 'btree*.c'
Find all files/directories in directories/files taken from the glob pattern '/tmp/test/*' that were modified within the last day (day counted from today) </s> find /tmp/test/* -daystart -mtime -1
calculate the disk usage for all the files which have been modified in the last 24 hours in ~/tmp folder and display the file sizes </s> find ~/tmp -mtime 0 -exec du -ks {} \; | cut -f1
Counts all files in a DIR_NAME folder and subfolders. </s> find DIR_NAME -type f | wc -l
Find all directories that have been modified in the last seven days. </s> find . -mtime -7 -type d
get the root user access </s> sudo su
Copy file 'src' to 'dest', except if 'dest' already exists. </s> cp -n src dest
Find files owned by no user </s> find / -nouser
Find all *.txt files under the current directory whose names are not "File.txt" </s> find . -maxdepth 1 -type f -name '*.txt' -not -name File.txt
Copy all files under director 'foo' whose name doesn't contain 'Music' to directory 'bar'. </s> find foo -type f ! -name '*Music*' -exec cp {} bar \;
Recursively changes group ownership of everything in a '/home/user1/project/dev' folder to 'project_dev'. </s> chgrp -R project_dev /home/user1/project/dev
display all the files in the home folder that have been modified in the last 24 hours </s> find $HOME -mtime -1
Find only files under /etc with the size of 100k-150k </s> find /etc -size +100k -size -150k
Save the absolute path of the current script to variable "SELF" </s> SELF=$(readlink /proc/$$/fd/255)
Print process tree, adjusting output width with a screen size. </s> pstree | cat
Copy all files in "/mail" to "/home/username" preserving the directory hierarchy and modification times </s> find /mail -type f | cpio -pvdmB /home/username
Find all 1.txt, 2.txt and 3.txt files under current directory and change the permission to 444 </s> find . \( -name 1.txt -o -name 2.txt -o -name 3.txt \) -print|xargs chmod 444
Archive "/usr/local/" to "/BackUp/usr/local/" on host "XXX.XXX.XXX.XXX" via ssh and show progress </s> rsync --progress -avhe ssh /usr/local/  XXX.XXX.XXX.XXX:/BackUp/usr/local/
find all the findme.txt files in the file system </s> find / -name findme.txt -type f -print
Sources script incl.sh in the folder where current running script is located </s> source "$( dirname "${BASH_SOURCE[0]}" )/incl.sh"
count the lines of java code for all the java files in the current directory </s> find . -name "*.java" -print0 | xargs -0 wc
display all text files in the folder /tmp/1 </s> find "/tmp/1" -iname "*.txt"
Find all files under current directory matching the pattern '[error,access,error_log,access_log,mod_jk.log]*.[0-9]*' in their names </s> find -name '[error,access,error_log,access_log,mod_jk.log]*.[0-9]*' -type f
Find and delete all hard links in the /home directory to file1 </s> find /home -xdev -samefile file1 -exec rm {} +
Find files and directories that are at least seven levels of nesting in the directory /usr/src </s> find /usr/src -name CVS -prune -o -mindepth 7 -print
Prints calendar for a current month. </s> cal
Find all directories under $ROOT_DIR and show the sub-directories of the directories before the directories themselves </s> find $ROOT_DIR -type d -depth -print
Counts number of *.php files in a current folder and subfolders. </s> find . -name '*.php' | wc -l
list all zero-length files under the current directory </s> find . -empty -exec ls {} \;
find all the regular/normal files in the current folder and rename them to html files </s> find main-directory -type f -exec mv -v '{}' '{}'.html \;
Read a line from standard input with prompt "Enter your age:\n" </s> read -p $'Enter your age:\n'
Print files created/modified in the last day </s> find /directory -newermt $(date +%Y-%m-%d -d '1 day ago') -type f -print
Compress all ".txt" files in the current directory tree with gzip </s> find . -type f -name "*.txt" -exec gzip {} \;
Print the paths of the directories from the paths expanded by the glob pattern /path/to/directory/* </s> find /path/to/directory/* -maxdepth 0 -type d
Search for the system host name in "/etc/hosts" and print the IP address in the first awk field </s> more /etc/hosts | grep `hostname` | awk '{print $1}'
Find all *.data files under jcho directory </s> find jcho -name *.data
Find all files/directories under '/abs/path/to/directory' directory non-recursively that match the pattern '.*invalidTemplateName.*' in their names </s> find /abs/path/to/directory -maxdepth 1 -name '.*invalidTemplateName.*'
Find all files/directories under current directory tree wihout descending into './src/emacs' directory </s> find . -path './src/emacs' -prune -o -print
Saves byte size of $myvar variable value in the 'var2' variable. </s> var2=$(echo $myvar | wc -c)
Search the /home/user1 directory tree for files whose names end in ".bin" </s> find /home/user1 -name "*.bin"
Remove all files whose names start with spam- </s> find . -name 'spam-*' | xargs rm
find all the text files which are present in the current directory excludinghidden files. </s> find . -type f \( -iname "*.txt" ! -iname ".*" \)
Add "prefix_" to every non-blank line in "a.txt" </s> nl -s "prefix_" a.txt | cut -c7-
display all files in current folder which are bigger than 1 MB </s> find . -size +1M
Creates temporary file in a TMPDIR folder or /tmp folder if TMPDIR doesn`t defined, with file name like current shell name and '-XXXXX'-formatted suffix, and saves created path to the 'tempFile' variable. </s> tempFile="$(mktemp "${TMPDIR:-/tmp/}$(basename "$0")-XXXXX")"
Reports count of characters in the value of ${FOO_NO_TRAIL_SPACE} variable as follows: "length(FOO_NO_TRAIL_SPACE)==<counted number of characters>" </s> echo -e "length(FOO_NO_TRAIL_SPACE)==$(echo -ne "${FOO_NO_TRAIL_SPACE}" | wc -m)"
Rename "file.txt" in directories "v_1", "v_2", and "v_3" each to "v_1.txt", "v_2.txt", and "v_3.txt" respectively and print the conversion </s> rename -v 's#/file##' v_{1,2,3}/file.txt
Print unique lines of "second-file-sorted.txt" compared to "first-file-sorted.txt" </s> comm -23 second-file-sorted.txt first-file-sorted.txt
Show what content owned by root has been modified within the last day </s> find /etc/ -user root -mtime 1
Verbosely change ownership of "$file" to "root" </s> chown -v root "$file"
Remove all *.swp files under current directory ensuring white space safety </s> find . -name "*.swp" -print0|xargs -0 rm
Create 6-letter named temporary file in a folder path that is provided as the first positional parameter, and save the path to it in a variable 'tmpfile' </s> tmpfile=$(mktemp $(dirname "$1")/XXXXXX)
Find the password file between sub-directory level 2 and 4. </s> find -mindepth 3 -maxdepth 5 -name passw
Find files matching regular expression regexp </s> find . | xargs grep regexp
Find which ruby files under current directory contain the string 'jump' </s> find . -name '*.rb' -exec grep -H jump {} \;
Search for all files in the current directory recursively whose names contain "linkin park", ignoring the case </s> find . -iname "*linkin park*"
Find all 1US* files/directories under current directory </s> find . -name '1US*'
Find all regular .html files in the /var/www directory tree </s> find /var/www -type f -name "*.html"
find all empty files in the current directory ( empty file = size 0 bytes ) </s> find . -size 0
Merge colon-separated information from standard input and file1.txt where the first field of both files matches, print unpairable lines from both files, replace missing fields with "no-match", and output the second field from standard input and the second and third field from file1.txt </s> join -t, -o 1.2,2.2,2.3 -a 1 -a 2 -e 'no-match' - <(sort file1.txt)
Find files/directories named 'foo' under current directory tree without descending into directories named 'foo' </s> find . -name foo -type d -prune -o -name foo -print
Make directories "mnt" and "point" </s> mkdir mnt point
Find all empty directories under /tmp and below </s> find /tmp -type d -empty
find all readable files </s> find / -readable
Replace ",," with ", ," twice in "data.csv" and display the "," delimited result as a table </s> sed 's/,,/, ,/g;s/,,/, ,/g' data.csv | column -s, -t
Calculate the md5 sum of all files in "/your/dir" including content and filenames </s> grep -ar -e . /your/dir | md5sum | cut -c-32
Find files that are 100k </s> find -size 100k
bind word "foobar" to key code "\e[24~" </s> bind '"\e[24~":"foobar"'
display all the jpg images in current folder </s> find . -type f -iregex '.*\.jpe?g'
Take the last slash-separated section of variable "FILE" and copy it to variable "NAME". </s> NAME=`basename "$FILE"`
Search for the pattern 'search string' in all the files in the ''/tmp folder and display the matched lines along with the file names </s> find /tmp -type f -exec grep 'search string' '{}' /dev/null \+
search for the file "file" in current folder and save the output to the same file </s> find -name file -fprint file
Take the section of variable "FILE" between the last slash and the following dot, if any, and store that section in variable "NAME". </s> NAME=`basename "$FILE" | cut -d'.' -f-1`
Find the first file/directory under $DIR which matches the $TMP_DIR in its path </s> /usr/bin/find $DIR -maxdepth 1 -ipath $TMP_DIR -print -quit
Prints long recursive listing of all content of a root folder, appending output to 'output.file'. </s> ls -lR / | tee -a output.file
Prints line count of each file within current directory. </s> find . -type f -print | xargs -L1 wc -l
Print last four bytes of string '0a.00.1 usb controller some text device 4dc9' </s> echo 0a.00.1 usb controller some text device 4dc9 | rev | cut -b1-4 | rev
Removes trailing and starting newlines from file </s> tac file | sed -e '/./,$!d' | tac | sed -e '/./,$!d'
Find regular files modified within the last 7 days </s> find . -mtime -7 -type f
find all the files in the entire file system that start with the word top and have 3 letters next to it. </s> find / -name 'top???'
Print the average time of 4 ping requests to "www.stackoverflow.com" </s> ping -c 4 www.stackoverflow.com | sed '$!d;s|.*/\([0-9.]*\)/.*|\1|'
Recursively copy all regular files below current directory to directory /tmp on hostname, connecting as ssh user matching current username on local host. </s> find . -type f -exec scp {} hostname:/tmp/{} \;
recursively change owner and group of the directory and group of the directory and all files into it to user and group dev_user </s> chown "dev_user"."dev_user" -R ~/.ssh/
Filters only directories from long file listing of the current directory. </s> ls -l | grep "^d"
Print the time of last boot </s> who -b
Copy all files unconditionally and directories in directory tree "myfiles" to "target-dir" preserving directory hierarchy and modification time </s> find myfiles | cpio -pmud target-dir
Search the file system for regular files whose names are shorter than 25 characters </s> find / -type f| egrep -o "/[^/]{0,24}$" | cut -c 2-
List the directory contents of the current working directory </s> echo $(ls $(pwd))
Clean the current directory from all subversion directories recursively </s> find . -type d -name ".svn" -print | xargs rm -rf
Print the contents of "$FILE" starting from line 2 </s> tail -n +2 "$FILE"
Find files modified in last 7 days </s> find . -mtime -7 -type f
search for all the file sin the current folder which are bigger than 10KB and display them smallest file </s> find . -size +10k -exec ls -lS {} \+ | head -1
Search for .pdf files </s> find / -name '*.pdf'
display all files in the current folder with the name test excluding those that are present folder test </s> find . -name test -prune -o -print
Locate all *.mov files in the current directory tree </s> find . -name '*.mov'
long list all the files in the curent folder starting with "Tes" </s> find . -type f -name "Tes*" -exec ls -l {} \;
Display inputfile all on one line (replace newlines by spaces) </s> awk '{printf "%s ", $0}' inputfile
Enables shell option 'cdable_vars'. </s> shopt -s cdable_vars
Set 444 permission to all regular files under current directory </s> find . -type f -print | xargs chmod 444
display all the files in the file system which are present in nfs system </s> find / -fstype nfs -print
Display all regular files under current directory tree ignoring files in './dir1' and './dir2' directories </s> find . -type f |sed '/.\/dir[12]\/[^/]*$/d'
Display the sizes and filepaths of all files/directories sorted in ascending order of size </s> du -a --max-depth=1 | sort -n
Find all files under /path and below writable by `group' and `other' </s> find /path -perm -022
Search the current directory and all of its sub-directory for any PDF files being careful to prevent the shell from expanding anything in '*.pdf'  before it'ss passed to find. </s> find . -name '*.pdf' -print
find all the text files in the temp folder and search for the word hello in all these files and display the matched files </s> find /tmp -type f -name ‘*.txt*’ | sed -e ‘s/.*/\”&\”/’ |xargs -n 1 grep -l hello|sed -e ‘s/.*/\”&\”/’
List the current directory recursively ignoring the "dir1" subdirectory </s> find . -path ./dir1\*  -o -print
Find *.conf files/directories only upto 2 levels down under /etc directory and show a few lines of output from the end </s> find /etc -maxdepth 2 -name "*.conf" | tail
Find all image.pdf files/directories under ./polkadots with null character as the delimiter </s> find ./polkadots -name "image.pdf" -print0
Find and uncompress all files in the current directory tree ending in ".csv.gz" </s> find . -name '*.csv.gz' -print0 | xargs -0 -n1 gzip -d
Find all file.ext files/directories under current directory with "FooBar" in their paths and copy them into the current directory </s> find . -name "file.ext"| grep "FooBar" | xargs -i cp -p "{}" .
Shows status of a shell option 'compat31'. </s> shopt compat31
Print right aligned numbers from 11 to 24 </s> yes '' | nl -ba | sed -n -e 11,24p -e 24q
Split "ADDRESSS_FILE" into files containing at most 20 lines and prefix "temp_file_" </s> split -l20 ADDRESSS_FILE temp_file_
Set variable "finalName" to the second-to-last slash-separated path component of variable "path" </s> finalName=$(basename -- "$(dirname -- "$path")")
Execute "ls" every 2 seconds </s> watch ls
Create a copy of the current working directory structure in the usr/project directory, </s> find . -type d -print|sed 's@^@/usr/project/@'|xargs mkdir -p
Searches the manual page names and descriptions by 'disk' keyword. </s> apropos disk
display all the files in the home folder which are smaller than 500 bytes </s> find ~ -size -500b
Print which files differ between "folder1" and "folder2" treating all files as text </s> diff -arq folder1 folder2
Copy all ".xml" files in the current directory tree to "/new/parent/dir" preserving the directory hierarchy </s> find . -name \*.xml -print0 | cpio -pamvd0 /new/parent/dir
find all the text files in the home directory </s> find ~/ -name '*.txt'
Remove all vmware-*.log files under current directory </s> find . -name "vmware-*.log" -exec rm '{}' \;
Remove all files 'a.out' and *.o in the home directory tree that were accessed more than 7 days ago </s> find $HOME \( -name a.out -o -name '*.o' \) -atime +7 -exec rm {} \;
Find all SUID files in entire file system </s> find / -perm +u=s
Find all files under $dir </s> find "$dir" -type f
Print numbers from 1 to 10 with padded leading zeros </s> seq -w 1 10
Find all the files/directories with '.conf' extension under '/etc' directory non-recursively and display the last ten files </s> find /etc -maxdepth 1 -name "*.conf" | tail
Find all *.css files under $DIR and print the lines matching the regex '\.ExampleClass.{/,/}' from those files </s> find ${DIR} -type f -name "*.css" -exec sed -n '/\.ExampleClass.{/,/}/p' \{\} \+
List all .gif files in the current directory tree </s> find . -name *.gif -exec ls {} \;
Print numbers from 1 to 30 with a leading 0 </s> seq -w 30
Find all files/directories under current directory with 'FooBar' in their paths and copy them to ~/foo/bar </s> find .|grep "FooBar"|xargs -I{} cp "{}" ~/foo/bar
Sort the lines of the file 'inputfile', keep only the uniq lines and change it in-place </s> sort inputfile | uniq | sort -o inputfile
Create intermediate directories as required and directory  /my/other/path/here </s> mkdir -p /my/other/path/here
search all the files in the current folder using name patterns </s> find . -name 'a(b*' -print
Find all xx* files/directories excluding 'xxx' files/directories under your home directory </s> find ~ -name 'xx*' -and -not -name 'xxx'
Search the system for regular files whose names are "filename" ignoring the case </s> find / -type f -iname "filename"
Dump "filename" as 2 byte wide hexadecimal and printable characters </s> od -xc filename
Find files containing `blah' in their names modified less than 2 days ago, case insensitive </s> find . -iname '*blah*' -mtime -2
change the ownership of all regular/normal files in the current directory </s> find . -type f -exec chown username {} \;
Print a list of case insensitive duplicate filenames in the current directory </s> ls | sort -f | uniq -i -d
Counts all *.mod files in a /boot/grub/ folder. </s> ls -l /boot/grub/*.mod | wc -l
Print whether the unique contents of "set1" and "set2" differ </s> diff -q <(sort set1 | uniq) <(sort set2 | uniq)
Search all .c and .h files in the current directory tree for string "e" </s> find . -name "*.[ch]" -exec grep --color -aHn "e" {} \;
Recursively changes group ownership of everything within '.git' to 'git'. </s> chgrp -R git .git
find all the php files in current folder using regular expressions </s> find . -regex '.+\.php'
display the number of lines in all the header files in the current folder </s> find . -name "*.h" -print | xargs wc -l
Print epoch seconds for given time string "Oct 21 1973" </s> date -d "Oct 21 1973" +%s
find symbolic links with pattern` '*sysdep.c' </s> find . -lname '*sysdep.c'
Save the absolute path of the current script to variable "SELF" </s> SELF=`readlink /proc/$$/fd/255`
Remove ESC key bind </s> bind -r '\e'
Print "y" for each line in "file2.txt" found in "file1.txt" and a blank newline otherwise </s> comm -2 file1.txt file2.txt | awk -F'\t' '{print (NF==2?"y":"")}'
Search the current directory tree for files whose name is ".note", case insensitive </s> find -type d -exec find {} -maxdepth 1 \! -type d -iname '.note' \;
Recursively finds files like 'example.com', ignoring case differences, and filters out files with 'beta' in path. </s> find -iname example.com | grep -v beta
Recursively removes all files like any-cased '*.pyc' in a current folder. </s> find . -iname '*.pyc' -print0 | xargs -0 --no-run-if-empty  rm
create a tar ball of all pdf files in current folder </s> find . -name *.pdf | xargs tar czvf /root/Desktop/evidence/pdf.tar
Find all files and directories with permissions 664 </s> find . -perm 664
List all functions defined in the shell </s> set | grep " () $" | cut -d' ' -f1
Read a line from standard input into variable "REPLY" with prompt "$*" </s> read -p "$*"
sort based on size and display top ten small normal/regular files in the current folder </s> find . -type f -exec ls -s {} \; | sort -n | head -10
Report file system disk space usage in human readable format </s> df -h
search for all the files in the current folder which start with gen and end with bt2 and assign the output list to the variable var. </s> var="$(find . -name 'gen*.bt2')"
Remove all directories called "test" from the current directory tree </s> find -name "test" -type d -delete
Delete all empty directories in minimum 1 level down the directory 'directory' </s> find directory -mindepth 1 -type d -empty -delete
Read a line from standard input into variable "text" with the prompt " Enter Here: " </s> read -p " Enter Here : " text
Set permissions for files in `foldername' and its subdirectories to 644 </s> find foldername -type f -exec chmod 644 {} ";"
Find all * * regular files under current directory </s> find .  -type f -name "* *"
recursively delete, without prompting, directories under /data/bin/test, that are older than 10 days and where the name starts with a number </s> find /data/bin/test -type d -mtime +10 -name "[0-9]*" -exec rm -rf {} \;
Clears the terminal screen. </s> clear
Create a symolic link in "/usr/local/bin/" to "/Applications/Sublime\ Text.app/Contents/SharedSupport/bin/subl" </s> ln -s /Applications/Sublime\ Text.app/Contents/SharedSupport/bin/subl /usr/local/bin/
Join lines in file "A" with lines in file "B" if the lines share a common first word </s> join <(sort -n A) <(sort -n B)
Remove all \*~ files under dir </s> find dir -name \\*~ -exec rm {} +
change owner and group of the file "file" to user "user" and group "group" </s> chown user:group file ...
split all files in directory "posns " into pieces per 10000 lines </s> find posns -type f -exec split -l 10000 {} \;
Print a colon-separated list of all directories from the ~/code directory tree, except hidden ones and those below them </s> find ~/code -name '.*' -prune -o -type f -a -perm /u+x -printf ':%h\n' | sort | uniq | tr -d '\n'
display all empty files(files with sisze 0 bytes) in home folder </s> find ~ -empty
Add "prefix" to every non-blank line in "file.txt" </s> nl -s prefix file.txt | cut -c7-
Remove files erroneously named `-F' </s> find . -name "-F" -exec rm {} \;
Print content of all files found regarding seach options '[whatever]' </s> find [whatever] | xargs cat
Recursively change the owner of all files in "upload_directory" to "nobody" </s> chown -R nobody upload_directory
Find all directories under /path/to/dir (no sub-directories) and archive them (with relative paths) into files with .tar.gz extension </s> find /path/to/dir -mindepth 1 -maxdepth 1 -type d -execdir sudo tar -zcpvf {}.tar.gz {} \;
find all the empty directories in the current folder </s> find . -type d -empty
Searches through the /usr/local directory for files that end with the extension .html. When these files are found, their permission is changed to mode 644 (rw-r--r--). </s> find /usr/local -name "*.html" -type f -exec chmod 644 {} \;
Find all $1 files/directories under current directory and enter into the parent directory of the first one found </s> cd $(find . -name $1 | xargs dirname)
Find all *.rb (regular) files under current directory and count their line numbers ensuring white space safety on file name/path. </s> find . -name "*.rb" -type f -print0 | xargs -0 wc -l
Search the current directory tree for regular files that contain "string" </s> find . -type f | xargs grep string
Fiind and remove multiple files such as *.mp3 or *.txt </s> find . -type f -name "*.txt" -exec rm -f {} \;
find all the jpg files in the directory /ftp/dir which are bigger than 500KB </s> find /ftp/dir/ -size +500k -iname "*.jpg"
List all files/directories under current directory matching the posix-egrep type regex ".+\.(c|cpp|h)$" in their names </s> find . -regextype posix-egrep -regex ".+\.(c|cpp|h)$" -print0 | xargs -0 -n 1 ls
List files and directories recursively </s> find . -print | xargs ls -gilds
View the man page of find </s> man find
Find every file under the directory /var/spool that was modified more than 60 days ago. </s> find /var/spool -mtime +60
Find *.html files in the current directory tree that were modified less than 7 days ago </s> find . -mtime -7 -name "*.html" -print
Search all of /usr for any directory named 'My Files', for each directory found, copy it to /iscsi preserving full paths and attributes, then remove it. </s> find /usr -type d -name 'My Files' -exec rsync -avR '{}' /iscsi \;  -exec rm -rf '{}'\;
Find *log files/directories within a maximum of 3 levels of directories </s> find / -maxdepth 3  -name "*log"
Change permissions to 0755 for all directories in the /path directory tree </s> find /path -type d -exec chmod 0755 {} \;
display all soft links in current folder </s> find . -type l
Find all directories under minimum 1 level down the  $GIVEN_DIR directory with null character as the delimiter </s> find "$GIVEN_DIR" -type d -mindepth 1 -print0
Find all files/directories named 'FindCommandExamples.txt' that belong to the user 'root' in the entire filesystem </s> find / -user root -name FindCommandExamples.txt
Find files in the /var/log folder which were modified an hour or more ago </s> find /var/log/ -mmin +60
List all file paths under the current directory with case insensitive name ".note" in reverse alphabetic order </s> find . -iname '.note' | sort -r
display the help of find command </s> find --help
find all files in etc which have been changed in the last 1 day </s> find /etc -daystart -ctime -1
Display differences between directories dir1 and dir2. </s> diff -r dir1 dir2
Find all hidden files under /tmp </s> find /tmp -type f -name ".*"
Read a line from standard input with prompt "Are you sure? [Y/n]" and save response in variable "response" </s> read -r -p "Are you sure? [Y/n]" response
Prints last modified file in a current folder. </s> find . -type f -printf '%T@ %p\n' | sort -n | tail -1 | cut -f2- -d" "
Dump "FILENAME" as 2 byte wide hexadecimal numbers </s> od -tx2 FILENAME
display list of all the files in the current directory (print0 handles file names with newlines or spaces) </s> find -print0 | xargs -0 ls
Find and copy all log files in the current directory tree to /tmp/log-files </s> find . -name \*.log -print0 | xargs -I{} -0 cp -v {} /tmp/log-files
Print command history </s> history
search for the regular/normal file 'myfile' in the folder /root excluding those that are present in the "work" directory </s> find /root/ -name 'work' -prune -o -name myfile -type f -print
get year-month-day hour:minute:second from date </s> date +%Y-%m-%d:%H:%M:%S
Recursively change the owner to "ec2-user" and group to "apache" of all files in "/vol/html" </s> sudo chown -R ec2-user:apache /vol/html
Get the current shell's executable name from the output of 'ps'. </s> ps | grep `echo $$` | awk '{ print $4 }'
Save the number of records in the system hostname that contain numbers in variable "server_id" </s> server_id=`hostname | tr 'A-Za-z-.' ' ' | tr -d '[[:space:]]' | awk '{print NR}'`
Find files/directories under current directory that matches the regex /path/to/something[^/]*$  in their paths </s> find . | grep -qi /path/to/something[^/]*$
Delete all files/directories with '.old' extension under current directory tree </s> find . -name “*.old” -delete
Copy loadable kernel module "mymodule.ko" to the drivers in modules directory matchig current kernel. </s> sudo cp mymodule.ko /lib/modules/$(uname -r)/kernel/drivers/
display all files in the directory "dir" which have been accessed in the last 60 minutes </s> find /dir -amin -60
Silently read standard input until the escape key is pressed ignoring backslash escapes and using the prompt $'Press escape to continue...\n' </s> read -rsp $'Press escape to continue...\n' -d $'\e'
Prints process tree of a process having id $mypid, with command options and process id number. </s> pstree -aAp $(ps -ejH | awk -v v1=$mypid '$1==v1 {print $3}')
Search the home directory tree for .tar.gz files newer than file "filename" </s> find ~/ -name *.tar.gz -newer filename
Save the percentage of packets lost of the 5 packets sent to "$host" in variable "packet_loss" </s> packet_loss=$(ping -c 5 -q $host | grep -oP '\d+(?=% packet loss)')
search for files which are writable by both their owner and their group </s> find . -perm -g+w,u+w
Remove files from the file system that are owned by nobody, asking the user before each removal </s> find / -nouser -ok rm {} \;
Find recursively all files whose names begin with "foo" </s> find . -name "foo*"
Finds all users logged in via ssh. </s> w | grep ssh
Find all regular files in the current directory tree ignoring directory ./source/script </s> find . -path ./source/script -prune -o -type f -print;
Find all files/directories that start with 'test' in their names under current directory tree </s> find . -name 'test*'
List all regular files under current directory ensuring white space safety </s> find . -type f -print0 | xargs -0 -n 1
Counts total lines in all *.php files in the current directory recursively </s> find . -name '*.php' -type f | xargs cat | wc -l
find all files in the current folder which are of size 0 bytes. </s> find . -type f -size 0b
Delete all non digits from index "$i" in bash array "depsAlastmodified" and print the hex dump as characters </s> echo "${depsAlastmodified[$i]}" | tr -cd '[[:digit:]]' | od -c
display all files in current folder ending with "~" or "#" using regular expression </s> find -regex "^.*~$\|^.*#$"
Look for files in the current directory tree to which the group users have full access </s> find . -perm -070 -print
Print '111 22 3\n4 555 66\n' by replacing the spaces with tabs and '\n' with newlines </s> echo -en '111 22 3\n4 555 66\n' | tr ' ' '\t'
Find all files/directories that are newer than 'ttt' by modification time or owned by the user 'wnj' in the entire filesystem </s> find / \( -newer ttt -or -user wnj	\) -print
Search the .css files in the /starting/directory tree for ".ExampleClass" </s> find /starting/directory -type f -name '*.css' | xargs -ti grep '\.ExampleClass' {}
Print each line in "file1.txt" that is not found in "file2.txt" </s> sort file1.txt file2.txt file2.txt | uniq -u
Find files modified within the past 24 hours </s> find . -mtime 0
Write "2-1" to standard output and to "/sys/bus/usb/drivers/usb/unbind" </s> echo '2-1' |sudo tee /sys/bus/usb/drivers/usb/unbind
Find all the files in entire file system  which are modified more than 50 days back and less than 100 days and show a few lines of output from the beginning </s> find / -mtime +50 -mtime -100 | head
delete all the normal/regular files in the current folder </s> find . -type f -print -delete
List all files/directories under current directory with their inode numbers, disk space, permission, number of hard links, user name, group name, size, status change time in Y-m-d format and name filed,  then write the outptut to /tmp/files.txt </s> find . -type f -fprintf /tmp/files.txt "%i,%b,%M,%n,%u,%g,%s,%CY-%Cm-%Cd %CT,%p\n"
Count the number of open files for PID "$PYTHONPID" every 2 seconds </s> watch "ls /proc/$PYTHONPID/fd | wc -l"
Recursively rename all files under /your/target/path replacing 'special' with 'regular' - all file/diretory names may not include spaces, and directory names containing such files may not contain the word 'special' in their name. </s> find /your/target/path/ -type f -exec rename 's/special/regular/' '{}' \;
Find blabla* files under current directory </s> find . -depth -name "blabla*" -type f | xargs rm -f
search for all the text files and display the long listing of these files from that directory </s> find . -name "*.txt" -execdir ls -la {} ";"
display all the configuration files in the etc folder </s> find /etc -name '*.conf'
Find all *.cgi files/directories under current directory and change their permission to 775 </s> find . -name '*.cgi' -print0 | xargs -0 chmod 775
Search for files/directories with the case insensitive pattern anaconda.* in var/log directory and create an archive (somefile.tar) of all the files found </s> tar -cvf file.tar `find var/log/ -iname "anaconda.*"`
find all the directories in the current folder which have been modified in 24 hours and move them to the folder  /path/to/target-dir </s> find . -type d -mtime -0 -exec mv -t /path/to/target-dir {} +
Format output of "mount" as a table </s> mount | column -t
find all the files that have been modified in the last 60 minutes </s> find -mmin -60
Save number of processors in system to 'NP' variable </s> NP=`cat /proc/cpuinfo | grep processor | wc -l`
Delete current cron job list, and use those in yourFile.text </s> crontab yourFile.text
create directory subdirectory </s> mkdir subdirectory
Find all broken symlinks under /path/to/search directory </s> find /path/to/search -xtype l
Check that the master ssh connection "officefirewall" is running </s> ssh -O check officefirewall
Search  in current directory downwards all files whose size is greater than 10 bytes . </s> find . -size +10c -print
Add "new." to the beginning of the name of "original.filename", renaming it to "new.original.filename". </s> rename 's/^/new./' original.filename
find all the directories in the folder $LOGDIR which have been modified in the last 5 days and delete them. </s> find $LOGDIR -type d -mtime +5 -exec rm -f {} \;
Find all *.gz files in the current directory and decompress them using gunzip </s> find . -name '*.gz' -print0 | xargs -0 gunzip
display all the files in the folder a </s> find a
Lists content of compressed text file. </s> zless MyFile
Find all files/directories with 755 permission under current directory tree </s> find ./ -perm 755
Find x* files/directories under /tmp directory whose status was changed less than 1 day ago and move them to ~/play </s> find /tmp/ -ctime -1 -name "x*" -exec mv '{}' ~/play/
List all files/directories under current directory </s> find -ls
Extract protocol and host name from URL. </s> echo "$url" | cut -d'/' -f1-3
Read a line from standard input into variable "ans" without backslash escapes </s> read -r ans
Find all regular files under ./Desktop directory </s> find ./Desktop -type f
Print 'bla.txt' if at least one file with such name is present below the current directory. </s> ls -alFt `find . -name "bla.txt"` | rev | cut -d" " -f1 | rev | head -1
display long listing of all files in the current directory whose size is 24 or 25 bytes (doesnt display inode information) . </s> find . -size -26c -size +23c -exec ls -l '{}' \;
Prints $m latest modified files within the $d folder, using $f format for printing timestamp. </s> find "$d" -type f -printf "%T@ :$f %p\n" | sort -nr | cut -d: -f2- | head -n"$m"
find all the files in the current directory that have the word "bash" in their name </s> find . -name "*bash*"
Find all the regular files under '/your/dir' directory tree which are bigger than 5 MB and display them in decreasing order of their sizes </s> find /your/dir -type f -size +5M -exec du -h '{}' + | sort -hr
Search all the regular files from the current directory tree for "search string" </s> find . -type f -print -exec grep --color=auto --no-messages -nH "search string" "{}" \;
Find files/directories named 'articles.jpg' under current directory tree and change their permission to 644 </s> find . -name "articles.jpg" -exec chmod 644 {} \;
Remove all files with names like "vmware-*.log" from the current directory tree </s> find . -name vmware-*.log | xargs rm
Delete all files under $INTRANETDESTINATION/monthly directory tree that were modified more than 366 days ago </s> find $INTRANETDESTINATION/monthly -mtime +366 -exec rm {} \;
Determine DISPLAY variable for the session when logged in via SSH </s> who am i | awk '{print $5}' | sed 's/[()]//g' | cut -f1 -d "." | sed 's/-/./g'
find all files that do not have read permission to all </s> find . -type f ! -perm -444
Report file system containing path to the current working directory inodes usage. </s> df -i $PWD
Replace commas (',') with newlines in $MOUNT_OPTS and search for the regex '^acl$' </s> echo $MOUNT_OPTS | tr , \\\n | grep '^acl$' -q
search for the file "myletter.doc" in the home folder </s> find ~ -name myletter.doc -print
Find files in /var/tmp/stuff and below that have not been modified in over 90 days </s> find /var/tmp/stuff -mtime +90 -print
Recursively set all permissions under "/opt/lampp/htdocs" to 755 </s> sudo chmod 755 -R /opt/lampp/htdocs
Archive directory "symdir" to "symdir_output" preserving symbolic links. </s> rsync symdir/ symdir_output/ -a --copy-links -v
split compressed content of the file www into pieces per 1073741824 bytes named as "backup.tar.NNN" </s> tar czf - www|split -b 1073741824 - www-backup.tar.
display all the files in the file system which belong to the user "user1" </s> find / -user user1
Change permissions to u=rwx,g=rx,o= for all directories in the current directory tree </s> find . -type d -exec chmod u=rwx,g=rx,o= '{}' \;
create a zip of log files in the current directory which have not been accessed in the last 3 days (-p is for parallel processing for a 4 cpu machine) </s> find . -name '*.log' -mtime +3 -print0 | xargs -0 -P 4 bzip2
Set permissions to 700 for directories under media/ </s> find media/ -type d -exec chmod 700 {} \;
Count the number of files named `file1' </s> find -name file1 | wc -l
Find only directories </s> find . -type d
display all the text and pdf files in the current folder </s> find . -regex ".*\(\.txt\|\.pdf\)$"
Search the home directory for files accessed more than 10 days ago </s> find ~/ -atime +10
Merge lines from "file_1" and "file_2" and format the output as a table with tab separators </s> paste file_1 file_2 | column -s $'\t' -t
Search for files in your home directory which have been modified in the last twenty-four hours. </s> find $HOME  -mtime 0
find all the files in the current directory which have the inode number 31246 and remove them. </s> find . -inum 31246 -exec rm [] ';'
Merge colon-separated information from file1 and file2 where first field of both files matches </s> join -t: <(sort file1) <(sort file2)
Reports count of processors in system. </s> grep '^core id' /proc/cpuinfo |sort -u|wc -l
Find .txt files on the system whose size is greater than 12000 bytes </s> find / -name "*.txt" -size +12000c
Set timestamp of all PHP files in current directory to date specified. </s> touch -d '30 August 2013' *.php
Find all files in current directory excluding hidden files and put the output into full_backup_dir variable </s> full_backup_dir=$(find . -depth '(' -wholename './.*' ')' -prune -o -print)
Find all the files which are greater than 50MB but less than 100MB in size </s> find / -size +50M -size -100M
Find all .txt files in the current directory tree and edit them with `vim' </s> find . -name "*.txt" | xargs vim
search for files cart4 or cart5 or cart6 in the folder junk which is in home folder and delete it. </s> find ~/junk  -name 'cart[4-6]' -exec rm {}  \;
Find all Subscription.java files/directories under current directory and enter into the parent directory of the first one found </s> cd $(find . -name Subscription.java | xargs dirname)
Print a count of each unique line from standard input sorted from least frequent to most frequent </s> sort | uniq -c | sort -n
Find all directories under current directory excluding  directories (along with their contents) that start with a . (dot) in their names </s> find -type d -a ! -name '.?*' -o ! -prune
Saves hostname that matches ${ip_address} in 'host' variable, without trailing dot. </s> host=$(dig +short -x "${ip_address}" | sed 's/\.$//g')
Delete all files in the current directory tree whose names end with ~ </s> find . -name "*~" -delete
Remove trailing white spaces and replace CRLF with LF in all files under current directory ignoring .git and .svn directories </s> find . -not \( -name .svn -prune -o -name .git -prune \) -type f -exec sed -i 's/[:space:]+$//' \{} \;  -exec sed -i 's/\r\n$/\n/' \{} \;
Use multiple -exec command in find . Find all .txt files & grep banna in .txt files . </s> find . -name "*.txt" -exec echo {} \; -exec grep banana {} \;
find all the reglar files which ahve been changed in the last 5 minutes and do not search in the sub directories. </s> find /home/pankaj -maxdepth 1 -cmin -5 -type f
Find files ending in "*macs" </s> find -name '*macs'
display all the files in the current folder which end with ".bash" </s> find . -name "*.bash"
Recursively changes group ownership of everything within current folder to 'git'. </s> chgrp -R git ./
create the compressed tar archive images.tar.gz containing all jpg files found under / </s> find / -name *.jpg -type f -print | xargs tar -cvzf images.tar.gz
Recursively finds string with text "foo" in all files of a current folder. </s> find ./ -type f | xargs grep "foo"
Remove all directories called "test" from the current directory tree </s> find -path "*/test/*" -delete
Find all *.jpg files/directories under current directory </s> find . -name '*.jpg'
start from current directory, skip the directory src/emacs and print it then skip all files and directories under it, and print the names of the other files found </s> find . -wholename './src/emacs' -prune , -print
Print the list of files in the current directory tree skipping Git files </s> find . -path './.git' -prune -o -type f
list regular file which file name end with '*.c' or '*.sh' in current directory </s> find . -type f \( -name "*.c" -o -name "*.sh" \)
Change the group of all directories (except those with a '.') under current directory tree to a group with the same name as the directory name </s> find . -type d | sed -e 's/\.\///g' | awk '{print $1, $1}' | xargs chgrp
find the ten biggest files </s> find /home -type f -exec du -s {} \; | sort -r -k1,1n | head
Print a colon-separated list of all directories from the ~/code directory tree, except hidden ones and those below them </s> find ~/code -type d | sed '/\/\\./d' | tr '\n' ':' | sed 's/:$//'
find all files in the file system which belong to no user or which have no user </s> find / -nouser
Find all SGID set files in the file system </s> find / -perm /g=s
Unzip all ".gz" files in the current directory tree excluding files containing "dvportgroups", "nsanity", "vcsupport", "viclient", and "vsantraces" </s> find . -name '*.gz' ! -name '*dvportgroups*' ! -name '*nsanity*' ! -name '*vcsupport*' ! -name '*viclient*' ! -name 'vsantraces*' -exec gunzip -vf {} \;
display all the regular/normal files in current folder which have been modified exactly 60 minutes before </s> find . -mmin 60 -type f
Find files in the current directory and below that are newer than /bin/sh </s> find . -newer /bin/sh
Format each line as 3 columns based on extraneous columns </s> awk '{for(i=3;i<=NF;i++){print $1,$2,$i}}' file | column -t
Calculate md5 checksum of '/etc/localtime' and save the first space separated part in variable 'checksum' </s> checksum=`md5sum /etc/localtime | cut -d' ' -f1`
Find all files and directories in the current directory tree with "linkin park" in their names and copy them to /Users/tommye/Desktop/LP </s> find . -iname "*linkin park*" -exec cp -r {} /Users/tommye/Desktop/LP \;
Search the current directory tree for file `teste.tex' </s> find -name teste.tex
Recursively changes group ownership of everything within '/git/our_repos' to 'shared_group'. </s> chgrp -R shared_group /git/our_repos
Remount root filesystem "/" </s> mount -oremount /
Find files owned by the "shadow" group </s> find / -group shadow
Copy the directory hierarchy from "original" to "new" </s> find original -type d -exec mkdir new/{} \;
recursively change owner of the directory /Users/xxx/Library/Developer/Xcode/Templates and all files to user xxx </s> sudo chown -R xxx /Users/xxx/Library/Developer/Xcode/Templates
Search the system for files named "findcommandexamples.txt", ignoring the case </s> find  / -iname findcommandexamples.txt
Dump "testscript.sh" as 2 byte hexadecimale, printable characters, and octal values </s> od -xcb testscript.sh
Find all files/directories that do not contain 'photo' in their names under current directory tree </s> find . ! -name "*photo*"
Shows state of shell option 'extglob'. </s> shopt extglob
Find directories that are directly under /home/user/workspace directory (no-subdirectories) and were modified more than 30 days ago and print a message saying that the directory wasn't modified during last 30 days </s> find /home/user/workspace -mindepth 1 -maxdepth 1 -type d -mtime +30 -printf "\t- It seems that %p wasn't modified during last 30 day\n"
search files in current folder using name patterns </s> find . -name "$pattern"
display all the files in the current folder for the files which have not been accessed in the last 24 hours </s> find . -type f -atime +1
Delete all hidden files in the directory tree given as variable $FOLDER </s> find $FOLDER -name ".*" -delete
Display only mimetype of myfile.txt, without the filename. </s> file -bi myfile.txt
List all variables (names and values) whose name or value contains X. </s> env | grep ".*X.*"
Print the first line of "filename" as a hex dump of characters </s> head -n 1 filename | od -c
display all the directories in the current folder </s> find . -type d -print
Print all distinct characters in input "He likes cats, really?" </s> echo "He likes cats, really?" | fold -w1 | sort -u
Move all files including hidden files in "/path/subfolder/" to "/path/" </s> mv /path/subfolder/{.,}* /path/
find all normal/regular files in current folder and display them in sorted order </s> find . -type f -ls | awk '{print $(NF-3), $(NF-2), $(NF-1), $NF}'
Find all files in the current user's home directory and its sub-directories with the optional constraints of опция_поиска, значение and/or опция_действия. </s> find ~/ [опция_поиска] [значение] [опция_действия]
Count number of lines in all files matching "*R1*.fastq.gz" </s> zcat *R1*.fastq.gz | wc -l
Update the history file in the current session </s> history -w
Find all files on smbfs mounts and print its information and file type </s> find $(mount -t smbfs | awk '{print $3}') -mount -type f -ls -execdir file {} \;
Save absolute path of "$path" that may not exist to variable "abspath" </s> abspath=$(readlink -m $path)
Find all files starting from the current directory that match regular expression '.*Message.*\.java' </s> find . -print | grep '.*Message.*\.java'
Find all files/directories under /home/feeds/data directory </s> find /home/feeds/data
Set the permissions of all directories inside the current directory tree to u=rwx,g=rx,o=x </s> find . -type d -exec chmod u=rwx,g=rx,o=x {} \;
find setuid files and directories writing the details to /root/suid.txt , and find large files writing the details to /root/big.txt, traversing the filesystem just once </s> find / \( -perm -4000 -fprintf /root/suid.txt '%#m %u %p\n' \) , \  \( -size +100M -fprintf /root/big.txt '%-10s %p\n' \)
Print the file names along with their sizes under current directory tree </s> find . -type f -printf "%f %s\n"
create a soft link of the files in the folder /media/movies which have been modified in the last 30 days </s> find /media/Movies -type f -mtime -30 -exec ln -s {} /media/Movies/New/ \;
delete all the empty files in the current directory only if they are ok and the user has the permission to delete them </s> find . -empty -ok rm {}\;
Find all directories matching the regex '.texturedata' in their names under '/path/to/look/in/' directory tree </s> find /path/to/look/in/ -type d | grep .texturedata
Search the current directory tree for regular files modified within the past 24 hours whose names do not end with ".DS_Store" </s> find . -mtime -1 ! -name '.DS_Store' -type f -printf '%f\n'
Force create a symbolic link without dereferencing named "alpha" to "alpha_2" </s> ln -nsf alpha_2 alpha
Connect to host "server_b" as ssh user "user" and copy local file "/my_folder/my_file.xml" to server_b's directory "/my_new_folder/". </s> scp -v /my_folder/my_file.xml user@server_b:/my_new_folder/
Delete all files named "filename" in the current directory tree, except those with paths ending in "/myfolder/filename" </s> find . -name "filename" -and -not -path "*/myfolder/filename" -delete
Find all files under current directory and set read permission for group and other for these files </s> find . -type f -print0 | xargs -0 chmod go+r
Find files and directories modified within the last 7 days </s> find . -mtime -7
Search the current directory tree for all files except SVN ones </s> find . | grep -v \.svn
Save the current user name in variable "myvariable" </s> myvariable=$(whoami)
Saves index number of file 'script.sh' in the 'inode' variable. </s> inode=`ls -i ./script.sh | cut -d" " -f1`
display all files in the current folder with the name test excluding those that are present in the sub folders of the test folder </s> find . -name test -prune
Print the time to ping "8.8.8.8" followed by a time stamp if the ping is greater than 50 </s> ping 8.8.8.8 | awk -F"[= ]" '{if($10>50) {cmd="date"; cmd | getline dt; close(cmd) ; print $10, dt}}'
Recursively change the user and group of all files in "/var/cache/jenkins" to "root" </s> chown -R root:root /var/cache/jenkins
Run 'join' with the number-sorted output of file1 and file2, without modifying file1 or file2: for each line with a common first field in file1 and file2, output the common field followed by the extra fields in both files. </s> join <(sort -n file1) <(sort -n file2)
search for files having python in filename </s> find / -iname '*python*'
display all the files  in the current folder excluding those which are present in "./src/emacs" folder </s> find  .  -path  './src/emacs'  -prune  -o -print
Read a single character from standard input with prompt "Are you sure? (y/n) " </s> read -p "Are you sure? (y/n) " -n 1
Sort standard input in alphabetical order </s> sort
Print 1000 astarisk ('*') </s> head -c 1000 /dev/zero | tr '\0' '*'
List all files in entire file system that are not newer than the ttt file and do not belong to the user wnj </s> find / \! \( -newer ttt -user wnj \) -print
Display 12345 backwards </s> echo 12345 | rev
find all files in the current directory do not display the files which are not readable </s> find . ! -readable -prune
Save standard input to variable 'stdin' until the first character encoded as '\004' is read </s> read -d "$(echo -e '\004')" stdin
Search the current directory tree for files whose names start with "f" </s> find . -name f* -print
Find and delete the file with inode number 1316256 </s> find ./ -inum 1316256 -delete
Search the current directory recursively for files last modified within the past 24 hours ignoring .swp files and paths ./es* and ./en* </s> find . -mtime 0 -not \( -name '*.swp' -o -regex '\./es.*' -o -regex '\./en.*' \)
Find all empty folders in the current directory and below </s> find . -type d -empty
Print content of all files found regarding seach options '[whatever]' </s> find [whatever] -exec cat {} +
find all CSS files that do something with your HTML ID #content </s> find . -name "*.css" -exec grep -l "#content" {} \;
Search the files under and below /directory/containing/files for "text to search" </s> find /directory/containing/files -type f -print0 | xargs -0 grep "text to search"
list all samba files in /var/l* directory ( /var/lib or /var/log ) </s> find  /var -path */l??/samba*
Print all files that exceed 1000 blocks and were modified at least a month ago </s> find / -size +1000 -mtime +30 -exec ls -l {} \;
display all regular files in current folder which have spaces in their name </s> find -type f -name "* *"
Remove the "123_" prefix from all filenames of .txt files in current directory. </s> find -name "123*.txt" -exec rename 's/^123_//' {} ";"
Find all the files in file system which are changed in last 1 hour </s> find / -cmin -60
Show directory sizes in KB and sort to give the largest at the end </s> find . -type d -exec du -sk {} \; |  sort -n -k 1
Find .jpg files owned by user daniel in the current directory and its sub-directories but ignore any file beginning with "autumn". </s> find . -user daniel -type f -name *.jpg ! -name autumn*
create symbolic links in current directory to all files located in directory "/original" and have filename extension ".processname" </s> find /original -name '*.processme' -exec echo ln -s '{}' . \;
Search the current directory tree for files matching regular expression '.*myfile[0-9][0-9]?' </s> find . -regex '.*myfile[0-9][0-9]?'
Print a minimal set of differences between files in directories "teste1" and "teste2", treat absent files as empty, ignore differences in whitespace, treat all files as text, and print 3 lines of unified context </s> diff -burNad teste1 teste2
Output "file.txt", omitting all containing directories "some/unknown/amoutn/of/sub/folder/" </s> basename "some/unknown/amount/of/sub/folder/file.txt"
Create links for all files in the current directory tree that are more than 1000 days old in "/home/user/archives" </s> find . -type f -mtime +1000 -print0 | cpio -dumpl0 /home/user/archives
Saves date of the first Sunday in month $mo of year $yo in the 'do' variable. </s> do=$(cal -m $mo $yo|awk 'NR>2&&!/^  /{print$1;exit}')
Print "test=hello world" </s> echo "hello world" | echo test=$(cat)
Find all l files in the 'foo' folder but ones with name like '*Music*' to the 'bar' folder. </s> find foo -type f ! -name '*Music*' -exec cp {} bar \;
Delete all 'restore.php' files in /var/www and 3 levels below </s> find /var/www -maxdepth 4 -name 'restore.php' -exec rm -r {} \;
Treat references to unset variables as errors </s> set -o nounset
Delete all contents form the files that contain the case insensitive regex 'stringtofind' in maximum 1 level down the / directory excluding other partitions </s> find / -maxdepth 1 -xdev -type f -exec grep -i "stringtofind" -l {} \; -exec sed -i '/./d' {} \;
Remove all files/directories in the current directory without '.git' and '.gitignore' </s> find -mindepth 1 -depth -print0 | grep -vEzZ '(\.git(/|$)|/\.gitignore$)' | xargs -0 rm -rvf
Search the current directory tree for regular files whose names end in "log" </s> find `pwd` -name "*log" -type f
Search the home directory tree for regular files modified yesterday </s> find ~ -daystart -type f -mtime 1
display the long listing of all files in /var/log which were modified 60 days or more ago. </s> find /var/log/ -mtime +60 -type f -exec ls -l {} \;
display all the file in the folder /home/david/ which start with the word "index" </s> find /home/david -name 'index*'
Print all lines from the last occurrence of the regex 'pattern' to the end of the file 'file' </s> tac file | sed '/pattern/q' | tac
Find all .mp3 files with more than 10MB and delete them </s> find / -type f -name *.mp3 -size +10M -exec rm {} \;
Print file extension assuming there is only one dot in the file name. </s> echo "$FILE" | cut -d'.' -f2
display all regular/normal files in the current folder which are accessed in the last 7*24 hours </s> find . -type f -atime -7
Show the date in default format for tomorrow + 2 days + 10 minutes </s> date -d tomorrow+2days-10minutes
Remove symbolic links and get absolute path of "${the_stuff_you_test}" and save to variable "DIR_PATH" </s> DIR_PATH=`readlink -f "${the_stuff_you_test}"`
Find all *.p[lm] files/directories under current directory </s> find -name '*.p[lm]'
create a symbolic link named "test" to file ".bashrc" </s> ln -s .bashrc test
Find mysong.ogg anywhere under the home directory </s> find $HOME -name 'mysong.ogg'
Search for 'mystring' in all *.txt files under current directory </s> find . -name "*.txt" -exec egrep mystring {} \;
find all the empty regular/normal files in the current folder and delete them </s> find . -type f -empty -delete
display ten files in the tmp directory </s> find /tmp  | head
Search the /etc directory tree for symbolic links </s> find /etc -type l -print
Display the count of regular files under 'home/magie/d2' directory tree which have execute permission to all the users </s> find home/magie/d2 -type f -perm +111 | wc -l
List the commands in /usr/bin, pausing for user input after each page. </s> ls /usr/bin | more
Print the directory name of the full real path to the current script </s> echo "dirname/readlink: $(dirname $(readlink -f $0))"
Find all directories in the current directory tree that are not accessible by all </s> find -type d ! -perm -111
find all the shell scripts or perl files in the current directory </s> find . -type f \( -name "*.sh" -o -name "*.pl" \)
Recursively copy "source", "dir", and "target" to "dir" as a dry run </s> rsync -rvc --delete --size-only --dry-run source dir target dir
find all the files in the current folder that have been modified exactly 24*3 hours ago </s> find ./ -mtime 3
Replace all instances of "STRING_TO_REPLACE" with "STRING_TO_REPLACE_IT" in file "index.html" and make a backup with suffix "bak" on OSX </s> sed -i bak -e s/STRING_TO_REPLACE/REPLACE_WITH/g index.html
Sets shell option 'dotglob'. </s> shopt -s dotglob
Find all files under /home/username/public_html/modules  and set their permission to 640 </s> find /home/username/public_html/modules -type f -exec chmod 640 {} +
Change permssions of *.cgi files under directories htdocs and cgi-bin to 755 </s> find htdocs cgi-bin -name "*.cgi" -type f -exec chmod 755 {} \;
Find all fglrx-libglx* files under and below debian/fglrx/ </s> find debian/fglrx/ -name 'fglrx-libglx*'
Display infinite scroll of random ASCII art </s> yes 'c=(╱ ╲);printf ${c[RANDOM%2]}'|bash
Save the line number matching "}]" in lines starting with "item_1" to "item_2" in "itemlist.json" to variable "line_to_be_replaced" </s> line_to_be_replaced=`cat itemlist.json | nl |  sed -n '/"item_1"/,/"item_2"/p' | grep -in "}]" | awk '{print $2}'`
Find all regular files under /home/www and replace every occurrences of 'subdomainA.example.com' with 'subdomainB.example.com' in those files invoking sed as few times as possible </s> find /home/www/ -type f -exec sed -i 's/subdomainA\.example\.com/subdomainB.example.com/g' {} +
Lists all subdirectories in the current directory with the trailing slash removed </s> ls -d1 */ | tr -d "/"
find all the files which end with ".deb" and display their base name (strip the extension) </s> find . -name '*.deb' | xargs -n1 basename
Print the list of files and directories of the current directory including "." </s> find . \( -name . -o -prune \)
find in $HOME files ending in "txt" and do nothing with them, or files ending in "html" and list them null separated. </s> find $HOME -name \*txt -o -name \*html -print0
Find all files/directories in directories/files taken from the glob pattern '/folder/path/*' recursively that have not been modified in the last 2 hours and delete them </s> find /folder/path/* -mmin +120 -delete
Find all files/directories named orm.properties in entire file system </s> sudo find / -name "orm.properties"
Search the current directory tree for files whose names end in "rb" or "js" </s> find . -regextype posix-egrep -regex ".*(rb|js)$"
Create a symbolic link named the basename of "$file" to "$file" </s> ln -s $file `basename $file`
Grab "variable = value" pairs from a windows style .ini file into the current shell. </s> source <(grep = file.ini | sed 's/ *= */=/g')
Change the owner to "root" and group to "specialusers" of "dir1" </s> chown root:specialusers dir1
find all the files that have been changed today </s> find . -ctime 0 -type f
Find all files, starting from / but ignoring removable media, whose names end with ".rpm" </s> find / -xdev -name "*.rpm"
find all '*.c' files under $HOME directory which context contains sprintf </s> find $HOME -name '*.c' -print | xargs grep -l sprintf
display a long listing of all the files in the current folder in sorted order, which are bigger than 10KB </s> find . -size +10k -exec ls -ls {} \+ | sort -nr
show the sum of disk used by all the files that belong to the user "test1" in the entire file system </s> find / -user test1 -exec du -sm {} \;|awk '{s+=$1}END{print s}'
find all the wav files in the current folder and do not search in the sub directories </s> find . -name '*.wav' -maxdepth 1
Enables shell option 'compat31'. </s> shopt -s compat31
list all javascipts file expect files under proc folder </s> find . -type d -name proc -prune -o -name '*.js'
Find all files in the current directory tree whose names are "file_name", except for those with pathnames matching pattern "./dirt to be Excluded/*" </s> find ./ -iname file_name ! -path "./dirt to be Excluded/*"
Check if "/path/to/dir" is a nfs mount point </s> mount -l | grep 'type nfs' | sed 's/.* on \([^ ]*\) .*/\1/' | grep /path/to/dir
Search the current directory tree for regular .mkv files </s> find . -type f -name "*.mkv"
Views text content of compressed FileB file in TarFile archive. </s> tar -xOf TarFile FileB.gz | zless
Find all files under current directory matching either of the patterns 'error.[0-9]*', 'access.[0-9]*', 'error_log.[0-9]*', 'access_log.[0-9]*', 'mod_jk.log.[0-9]*' in their names </s> find -type f -name 'error.[0-9]*' -o -name 'access.[0-9]*' -o -name 'error_log.[0-9]*' -o -name 'access_log.[0-9]*' -o -name 'mod_jk.log.[0-9]*'
Find all *.rb (regular) files under current directory and change their mode to 600 </s> find . -name "*.rb" -type f -exec chmod 600 {} \;
Exit the shell immediately if an error is encountered </s> set -e
Read first column of each row, find all other first columns which have a difference less than 10, and append that comma separated list to the row </s> awk 'FNR==NR { array[$1]++; next } { n = asorti(array,sort); for (i=1; i<=n; i++) if (sort[i] <= $1 + 10 && sort[i] >= $1 - 10 && $1 != sort[i]) line = (line ? line "," : line) sort[i]; print $0, line; line = "" }' file.txt{,} | column -t
Search directory tree $DIR for *.txt files </s> find $DIR -name "*.txt"
Find all empty files in the current directory and delete them </s> find . -maxdepth 1 -type f -empty -delete
display all the regular/normal files in the folder /path/ which have not been modified today ( from day start ie, 00:00 ) </s> find /path/ -type f -daystart -mtime +0
Remove all regular files named "Waldo" in the ~/Books directory tree </s> find ~/Books -type f -name Waldo -exec rm {} \;
Find the file in the current directory tree with inode number $inum and delete it </s> find . -inum $inum -exec rm {} \;
Print the sizes of all files from the current directory tree </s> find . -iname '*.jpg' -type f -printf +%b
Prints day of first Tuesday in a month. </s> cal | awk 'NR>2 && NF>4 {printf "%02d\n",$(NF-4);exit}'
Change to folder where the oracle binary is. </s> cd "$(dirname "$(which oracle)")"
Delete the line containing "start" plus the next 4 lines from standard input </s> sed '/start/,+4d'
Display the 'bash' manpage, going to the first occurence of \' sequence of characters. </s> man bash | less -Ip "\\\'"
Find all regular files in the current directory tree that are not readable by all </s> find -type f ! -perm -444
Move files from $sourcePath to $destPath that have not been modified in the last 10 days </s> find $sourcePath -type f -mtime +10 -name "*.log" -exec mv {} $destPath \;
List unique MD5 digests of all files in the current directory ending in .txt </s> md5sum *.txt | cut -d ' ' -f 1 | sort -u
Enables shell option 'cmdhist'. </s> shopt -s cmdhist
find all the header files in /usr/include which have been modified in the last 399 days and display the number of lines, number of files, number of characters of all these files </s> find usr/include -name '*.h' -mtime -399 | wc
Finds recursively all files in '/path/' excluding folders dir1, dir2 and all like *.dst, that contain 'pattern', and prints matched strings with string number and file name. </s> grep --exclude-dir={dir1,dir2,*.dst} -rnw '/path/to/somewhere/' -e "pattern"
display list of all the hidden files in the home folder </s> find $HOME -name ".*" -ls
search in the current folder for the files that begin with "myletter" </s> find . -name 'myletter*' -print
Exit the shell immediately if an error is encountered </s> set -o errexit
Display standard input as octal bytes </s> cat | od -b
Find all files/directories named 'query' (case insensitive) under current directory tree </s> find -iname "query"
find dirctory files which modification time is  7 days ago </s> find . -mtime -7 -type d
Check if a drive is mounted to nfs </s> mount |grep nfs
Write "Hello, world" to standard output and to "/tmp/outfile" </s> echo "Hello, world" | tee /tmp/outfile
Set permissions to 700 for directories under var/ </s> find var/ -type d -exec chmod 700 {} \;
Create a symbolic link named "temp" to "newtarget" </s> ln -s newtarget temp
Find all files under ${searchpath} that match the regex '"${string1}".*"${string2}".*"${string3}"' (${string1} ... won't be expanded) in their contents </s> find `echo "${searchpath}"` -type f -print0 | xargs -0 grep -l -E '"${string1}".*"${string2}".*"${string3}"'
Search the current directory recursively for text files containing at least one character </s> find -type f -exec grep -Iq . {} \; -and -print
Change permissions for all PHP files under the current directory tree to 755 and print the number of files changed </s> find . -name "*.php" -exec chmod 755 {} \; -exec /bin/echo {} \; | wc -l
Find all files named 'Makefile' in the /usr/ports directory tree and count the number of lines in them matching regular expression '^MASTER_SITE.*CPAN' </s> find /usr/ports/ -name Makefile -exec grep '^MASTER_SITE.*CPAN' '{}' '+' | wc -l
Find all files/directories under $TARGET_DIR directory tree matching the posix extended regular expression \".*/$now.*\" (where $now is a variable) and save the output in file $FILE_LIST </s> find $TARGET_DIR -regextype posix-extended -regex \".*/$now.*\" -fprint $FILE_LIST
Print either "one" or "two" randomly three times </s> yes $'one\ntwo' | head -10 | nl | sort -R | cut -f2- | head -3
List all of the subdirectories in the current directory with no trailing slash. </s> ls -d */ | cut -f1 -d'/'
Find all *.ogg (case insensitive) files/directories under your home directory that are greater than 100MB in size </s> find $HOME -iname '*.ogg' -size +100M
find out what group a given user has </s> groups user
Print 'file' file, splitting lines into pieces with no more that 3 words in each one. </s> cat file | xargs -n3
Find all files under /path/to/base/dir and change their permission to 644 </s> chmod 644 $(find /path/to/base/dir -type f)
Creates temporary folder and save path to that in a TMPDIR variable. </s> TMPDIR=$(mktemp -d)
Count the number of unique file extensions in the current directory tree </s> find . -type f | sed -e 's/.*\.//' | sed -e 's/.*\///' | sort | uniq -c | sort -rn
Change permissions to 777 for all directories in the current directory tree </s> find . -type d -exec chmod 777 {} \;
Display total apparent size of a file </s> du -sb
Recursively change owner to "www-data" of "/var/www/.gnome2", "/var/www/.config", and "/var/www/.config/inkscape" </s> chown -R www-data /var/www/.gnome2 /var/www/.config /var/www/.config/inkscape
Delete all empty directories in the current directory tree </s> find -type d -empty -exec rmdir -vp --ignore-fail-on-non-empty {} +
Change ownership of "/data/db" to the current user </s> sudo chown `whoami` /data/db
Find files/directories in entire file system that were accessed in less than a day ago </s> find / -atime -1
Sort "some_data" by the first and second ";" delimited entries, outputing unique lines and stabilizing the sort </s> sort -k1,1 -k2,2 -t';' --stable --unique some_data
Locate all files in the current directory and below that have "testfile" in their names regardless of the case </s> find -iname "*TESTFILE*"
Remove "-" from the contents of "/proc/sys/kernel/random/uuid" and save output to variable "comment" </s> comment=$(cat /proc/sys/kernel/random/uuid | sed 's/\-//g')
Delete all 1US* (case insensitive) files under current directory </s> find . -iname "1US*" -exec rm {} \;
Remount "/media/Working/" with a umask of 000 </s> mount /media/Working/ -oremount,umask=000
Output two lines of "-tcp" </s> yes -- "-tcp" | head -n 2
Count the number of files named 'job.history' under '/data/SpoolIn' directory tree that match 'FAIL' in their contents </s> find /data/SpoolIn -name job.history | xargs grep -l FAIL | wc -l
Search the current directory and directories below for .sql files </s> find . -name \*.sql
find the type of all the regular/normal files in the current folder (plus takes bulk of files as input to the file command) </s> find . -type f -exec file {} \+;
search all mp3 files in the folder "/home/you" which have been modified yesterday (from the start of day 00:00 to 23:59) </s> find /home/you -iname "*.mp3" -daystart -type f -mtime 1
Find all files under /path and below writable by `group' and `other' </s> find /path -perm -g+w,o+w
show all the ".acc" files in the folder /home </s> find /home -type f -name '*.aac'
Print the path composed of the current working directory and the directory containing "$0" </s> echo `pwd`/`dirname $0`
Create a rsa key of 2048 bits with comment "michael" and store it in file "key". </s> ssh-keygen -b 2048 -t rsa -f key -C michael
Make a copy of file1 in dir1, dir2, and dir3. </s> echo dir1 dir2 dir3 | xargs -n 1 cp file1
recursively look for files ending in either .py or .py.server </s> find . -type f -regex ".*\.\(py\|py\.server\)"
Replace all occurrences of foo (case insensitive) with bar in all *.css (case insensitive) files under %s directory </s> find %s -iname *.css | xargs sed -i s/[Ff][Oo][Oo]/bar/g
display all the symbolic links in the current folder </s> find . -type l
Search folder /home/ABCD/ recursively for regular files </s> find /home/ABCD/ -type f -print
Make 999 folders one inside another where first 998 of them is named as "folderX" where X goes from 1 to 998 and the last folder named as "folder9991000" </s> mkdir -p folder$( seq -s "/folder" 999 )1000
find all the files  in the folder /opt which have been changed in the last 120 minutes </s> find /opt -cmin -120
Print full path of command "python2.7" </s> which python2.7
find a difference between website content of "http://tldp.org/LDP/abs/html/" and "http://www.redhat.com/mirrors/LDP/LDP/abs/html/" </s> diff <(curl -s http://tldp.org/LDP/abs/html/) <(curl -s http://www.redhat.com/mirrors/LDP/LDP/abs/html/)
Find all 400 permission files under /data directory </s> find /data -type f -perm 400
Search the current directory for files whose names start with "messages." ignoring SVN, GIT, and .anythingElseIwannaIgnore files </s> find -name 'messages.*' -exec grep -Iw uint {} + | grep -Ev '.svn|.git|.anythingElseIwannaIgnore'
Delete all lines matching "pattern to match" in "./infile" and make a backup with suffix ".bak" </s> sed -i.bak '/pattern to match/d' ./infile
Find all files and directories starting from the current directory </s> find .
Find all files under /path/to/base/dir and change their permission to 644 </s> find /path/to/base/dir -type f -exec chmod 644 {} +
find all js files which path neither ./dir1 nor ./dir2 </s> find . -name '*.js' -not \( -path "./dir1" -o -path "./dir2/*" \)
forcibly and verbosely create a symbolic link named "target" to file "source" </s> ln -sfvn source target
Find files under /tmp that are larger than 10KB and smaller than 20KB </s> find /tmp -size +10k -size -20k
Count the number of lines in all files in the xargstest/ directory tree that match pattern 'file??' </s> find xargstest/ -name 'file??' | sort | xargs wc -l
Decompress "path/to/test/file.gz" to standard output and save all lines matching "my regex" to files with a 1000000 line limit </s> gzip -dc path/to/test/file.gz | grep -P --regexp='my regex' | split -l1000000
find all the files in the folder /work which belong to the user "olivier" </s> find /work -user olivier -print
Find all the files which are modified in last 1 hour </s> find / -mmin -60
Save the first three octets of the host name's IP address to variable "subnet" </s> subnet=$(hostname -i | cut -d. -f1,2,3)
Report file system mounted at $path_in_question disk usage if canonical path $path_in_question is a mount point. </s> df $path_in_question | grep " $path_in_question$"
find all the links in somedirectory and print them in a single line (to avoid the problem of files having newline in their names) </s> find "somedir" -type l -print0
Find all files/directories with '.bar' extension in maximum 2 levels down the current directory </s> find . -name *.bar -maxdepth 2 -print
Print A record for domain 'domain.' from 'ns2.newnameserver' nameserver </s> dig @ns2.newnameserver domain. a
display all the directories in the folder /path/to/dest except tmp directory </s> find /path/to/dest -type d \( ! -name tmp \) -print
Find and delete all .zip files in the current directory tree </s> find . -depth -name '*.zip' -exec rm {} \;
Search for symlinks pointing to anywhere within /mnt/oldname/ </s> find / -type l -lname '/mnt/oldname*'
Remove all .tmp files in and below /tmp </s> find /tmp -name "*.tmp" -print0 | xargs -0 rm
display a long listing of all the normal/regular files in the current folder and do not search in the sub folders </s> find . -maxdepth 1 -type f -exec ls -l {} \; | less
Create symbolic links in the current directory for all files excluding "CONFIGFILE" located in "/your/project" </s> find /your/project -maxdepth 1 ! -name "CONFIGFILE" -exec ln -s \{\} ./ \;
Archive all files beginning with .env or .bash in current directory to user's home directory on host "app1", preserving timestamps and skipping files that are newer on "app1" </s> rsync -vaut ~/.env* ~/.bash* app1:
Compress "my_large_file" with gzip and split the result into files of size 1024 MiB with prefix "myfile_split.gz_" </s> gzip -c my_large_file | split -b 1024MiB - myfile_split.gz_
create a symbolic link with absolute path "/cygdrive/c/Users/Mic/mypics" to file "/cygdrive/c/Users/Mic/Desktop/PENDING - Pics/" </s> ln -sf '/cygdrive/c/Users/Mic/Desktop/PENDING - Pics/' /cygdrive/c/Users/Mic/mypics
List subdirectories in the current directory </s> find . -maxdepth 1 -type d -exec ls -ld "{}" \;
Search the current directory recursively for regular files last modified less than 2 days ago </s> find . type -f -mtime -2
Find all regular files in the current directory tree last modified between 1 and 3 days ago and list them using format '%Tm %p\n' </s> find ./ -daystart -mtime -3 -type f  ! -mtime -1  -printf '%Tm %p\n'
Print pathnames of all files in the current directory and below skipping directories named SCCS and files in them </s> find . -name SCCS -prune -o -print
Search three folders named foo, bar, and baz for all "*.rb" files </s> find foo bar baz -name "*.rb"
Counts all top-level files in a current folder. </s> ls -1 | wc -l
Print appended data in "file" that match "my_pattern" </s> tail -f file | grep --line-buffered my_pattern
Save the absolute path of "$path" to variable "full_path" </s> full_path=`readlink -fn -- $path`
Copy "fileName.txt" to all directories listed in "allFolders.txt" - names may not contain spaces. </s> cat allFolders.txt | xargs -n 1 cp fileName.txt
Print lines containing string TEXT from all log files in the current directory. </s> grep -e TEXT *.log | cut -d':' --complement -s -f1
Delete files in /var/tmp/stuff and below that have not been modified in over 90 days </s> find /var/tmp/stuff -mtime +90 -print0 | xargs -0 /bin/rm
Finds recursively all files having extension .c, .h in '/path/' that contain 'pattern', and prints matched strings with string number and file name. </s> grep --include=\*.{c,h} -rnw '/path/to/somewhere/' -e "pattern"
Print the list of all subdirectories of the current directory </s> find . -maxdepth 1 -mindepth 1 -type d
Find all files that have wrong permission </s> find / \( -perm -006 -o -perm -007 \) \( ! -type -l \) -ls
find all the files under '/usr/local' directory tree which have been modified exactly 24 hours ago </s> find /usr/local -mtime 1
Find all symlinks under /myfiles directory </s> find /myfiles -type l
Find directories in the /path directory tree whose names are 33 characters in length </s> find /path -type d -printf "%f\n" | awk 'length==33'
Simulate a full login </s> su -
Search for regular files of the user bluher in the file system </s> find / -type f -user bluher -exec ls -ls {}  \;
Copies all files under the current folder like "file.ext" with "FooBar" in the path to the root of the current folder, preserving mode, ownership and timestamp attributes. </s> find . -name "file.ext"| grep "FooBar" | xargs -i cp -p "{}" .
Find all files in the current directory tree whose path names match pattern './sr*sc' </s> find . -path './sr*sc'
Clean up all zombie processes by instantly killing their parent process with SIGKILL signal. </s> kill -9 $(ps -A -ostat,ppid | grep -e '[zZ]'| awk '{ print $2 }')
Locate all .txt files in and below the current directory </s> find . -name "*.txt"
Remove all regular files under '/var/log/remote' directory tree that have not been modified in the last 14 days where day count starts from today </s> find /var/log/remote/ -daystart -mtime +14 -type f -exec rm {} \;
To descend at most one levels of directories below the command line arguments pass the -maxdepth 1 option. This will avoid deleting nested directories: </s> find .  -maxdepth 1 -type d -iname ".[^.]*" -print0 | xargs -I {} -0 rm -rvf "{}"
Display the contents of "text" </s> cat text
Output all lines from file1 except those present in file2, assuming both files are sorted. </s> diff file2 file1 | grep '^>' | sed 's/^>\ //'
search for all the files in current folder which start with "file2015-0" and move them to another folder </s> find . -name "file2015-0*" -exec mv {} .. \;
Unzip file "$empty_variable" </s> gunzip $empty_variable
Print the common third whitespace separated fields in "file1" and "file2" </s> comm -12 <(awk '{print $3}' file1 | sort -u) <(awk '{print $3}' file2 | sort -u)
Save a space separated list of process ids of currently running jobs to variable 'bgxjobs' </s> bgxjobs=" $(jobs -pr | tr '\n' ' ')"
Prints last modified file in a current folder with modification time. </s> find . -type f | sed 's/.*/"&"/' | xargs ls -E | awk '{ print $6," ",$7 }' | sort | tail -1
Find all .txt files in the user's home directory and below. </s> find ~/ -name '*.txt'
find all the php files in the current folder </s> find . -name \*.php
Check whether current terminal is opened in a screen session. </s> pstree --show-parents -p $$ | head -n 1 | sed 's/\(.*\)+.*/\1/' | grep screen | wc -l
find all gzip files in a folder </s> find /home/foo -name "*.gz"
find a specfic video file in the current directory </s> find ./ -name "foo.mp4" -exec echo {} \;
display all the files in the file system which belong to the user with the id 1005 </s> find / -uid 1005
Copy "source" recursively to "destination" excluding "path1/to/exclude" and "path2/to/exclude" </s> rsync -av --exclude='path1/to/exclude' --exclude='path2/to/exclude' source destination
Create a local SSH tunnel from "localhost" port 16379 to "localhost" port 6379 using key "keyfile.rsa" and disables the interactive shell </s> ssh -i keyfile.rsa -T -N -L 16379:localhost:6379 someuser@somehost
Search "whatyousearchfor" in history and print 3 lines before and 4 lines after </s> history | grep -A 4 -B 3 whatyousearchfor
List all *.ogg files under your home directory along with their size </s> find $HOME -name '*.ogg' -type f -exec du -h '{}' \;
Find all files starting from the current directory which are smaller than 100MB </s> find . -size -100M
Silently read a single character into variable "REPLY" </s> read -n1 -s
The file "files_to_find.txt" contains a list of filenames, create each file or update its timestamp if it exists. </s> touch `cat files_to_find.txt`
Find all directories named $1 under $HOME directory tree and remove them </s> find $HOME -type d -name $1 -exec echo {} ';'  -exec rm -rf {} ';'
display all the html files in the current folder that have been modified in the last 7*24 hours </s> find . -mtime -7 -name "*.html" -print
Set the modification timestamp of file 'filename' to specified date/time. </s> touch -m --date="Wed Jun 12 14:00:00 IDT 2013" filename
remove all the "core" files in the current folder which have not been changed in the last 4 days. </s> find . -name core -ctime +4 -exec /bin/rm -f {} \;
display a long listing of all the regular/normal files in the current folder </s> find . -type f -ls
Search the /usr/local/doc directory tree for .texi files </s> find /usr/local/doc -name '*.texi'
change the permissions of all the normal files in a directory </s> find /path/to/dir/ -type f -print0 | xargs -0 chmod 644
Search the home directory tree for video files </s> find ~ -type f -name '*.mkv' -o -name '*.mp4' -o -name '*.wmv' -o -name '*.flv' -o -name '*.webm' -o -name '*.mov'
Expands `whoami` as current user name, and adds resulted path to the directory stack. </s> pushd /home/`whoami`/Pictures
Print the list of all files in the current directory except for SVN, CVS, GIT, and binary files </s> find . -not \( -name .svn -prune -o -name .git -prune -o -name CVS -prune \) -type f -print0 | xargs -0 file -n | grep -v binary | cut -d ":" -f1
Print a count of each unique line in "ip_addresses" </s> sort ip_addresses | uniq -c
Report all C language source code files under the current directory </s> find . -name \*.c -print
Find all directories under /directory-path and change their permission to 2755 </s> find /directory-path  -type d -exec sudo chmod 2775 {} +
display all the files in the current folder which have are bigger than 1KB </s> find . -size +1024 -print
Find all files/directories that contain 'packet' (case insensitive) in their names excluding directories that are bigger than 1500 bytes in size </s> find . -iregex ".*packet.*" ! -type d -size +1500c
Find all files larger than 20000k </s> find / -type f -size +20000k
Find all TXT files that belong to user root </s> find / -user root -iname "*.txt"
Find all regular files named 'whatever' under current directory tree excluding all paths that contain any hidden directory </s> find . \( ! -regex '.*/\..*' \) -type f -name "whatever"
Count the number of unique lines in sorted file "a.txt" compared to sorted file "b.txt" </s> comm -23 a.txt b.txt | wc -l
Find all files under current directory that are larger than 10KB in size </s> find . -type f -size +10k
Forcibly create symbolic links in target directory "~/staging" for all files located in directory "~/mirror" </s> ln --force --target-directory=~/staging ~/mirror/*
search for all the log files in the folder /apps which have not been modified in the last 60 days and which are present in the same file system as that of /apps and delete them </s> find /apps -xdev -name "*.log" -type f -mtime +60 | xargs rm
Create a symolic link in "/usr/local/" to "/Applications/Sublime\ Text.app/Contents/SharedSupport/bin/subl" </s> ln -s /Applications/Sublime\ Text.app/Contents/SharedSupport/bin/subl /usr/local/
display all the text files and hidden files in the home folder </s> find ~ -name "*.txt" — print -o -name ".*" — print
Remove all .tmp files in and below /tmp </s> find /tmp -name "*.tmp" | xargs rm
Search the current directory tree for files matching sed regular expression '.*myfile[0-9]\{1,2\}' </s> find . -regextype sed -regex '.*myfile[0-9]\{1,2\}'
search for the file foo in  the current folder and display a long listing of it in sorted order of modification date </s> find . -name foo | xargs ls -tl
Filter the contents of 'file' through sed commands written in 'commandfile', displaying the result. </s> sed -f commandfile file
Find files and directories in the /tmp/ tree that contain spaces in their names and replace those spaces with underscores </s> find /tmp/ -depth -name "* *" -execdir rename 's/ /_/g' "{}" \;
Search the current directory tree for files whose names begin with "my" and end with "p" followed by any character, ignoring path names containing "test" </s> find . -regex ".*/my.*p.$" -a -not -regex ".*test.*"
Delete all files/directories under current directory </s> find -delete
Find all files under $d directory and set read-write permission for owner and group and no permission for other for those files </s> find $d -type f -exec chmod ug=rw,o= '{}' \;
Delete all empty directories in the "test" directory tree </s> find test -depth -type d -empty -delete
List all files/directories under /data1/Marcel with their file information which are greater than 524288 bytes and were modified or accessed more than 1 year ago </s> find /data1/Marcel -size +1024  \( -mtime +365 -o -atime +365 \) -ls -exec file {} \;
Find all *shp* files/directories under current directory </s> find . -name '*shp*'
Find the largest 10 files (regular files) under current directory </s> find . -type f -print0 | xargs -0 du | sort -n | tail -10 | cut -f2 | xargs -I{} du -sh {}
display the count of number html files in the current folder </s> find . -name "*.html" -print | xargs -l -i wc {}
Find files whose pathnames end in "config" </s> find .  -path '*/*config'
Find all files/directories under current directory with null character as the delimiter </s> find . -print0
Display the last slash-separated part of path, in this case "example". </s> basename /usr/local/svn/repos/example
display all regular/normal files in the folder Symfony </s> find Symfony -type f
Set permissions for all regular files under /var/www to 755 </s> find /var/www -type f -print0 | xargs -0 chmod 644
Find all files/directoires that were modified more than 3 days ago under $dir directory tree </s> find $dir -mtime +3
Find all regular files starting from level 3 of directory tree ~/container and move them to the current directory's parent </s> find ~/container  -mindepth 3 -type f -exec mv {} .. \;
Find all files owned by group `root' in the current directory tree and change their user to `temp' </s> find . -group root -print | xargs chown temp
Find all files in  /mydir  and replace every occurrences of <string1> with <string2> in those files invoking sed as few times as possible </s> find /mydir -type f -exec sed -i 's/<string1>/<string2>/g' {} +
Find files and directories that are at least seven levels of nesting in the directory /usr/src excluding CVS directory </s> find /usr/src -name CVS -prune -o -depth +6 -print
Write "deb http://downloads-distro.mongodb.org/repo/ubuntu-upstart dist 10gen" to standard output and append to "/etc/apt/sources.list.d/10gen.list" as root </s> sudo echo "deb http://downloads-distro.mongodb.org/repo/ubuntu-upstart dist 10gen" | sudo tee -a /etc/apt/sources.list.d/10gen.list
display all the files in the home folder </s> find $HOME -print
Search the home directory tree for files matching pattern '*.txt' </s> find ~ -name *.txt
display all the tex files in the current folder </s> find . -name \*.tex
Count all the lines of all php files in current directory recursively </s> find -name '*.php' | xargs cat | wc -l
force remove all the c files in the current folder </s> find . -name "*.c" | xargs rm -rf
Send ping requests to hostname specified by variable "c" for 1 second. </s> ping -w 1 $c
Find all /home/folder1/*.txt files and create symlinks appending '_CUSTOM_TEXT.txt' in their names </s> find /home/folder1/*.txt -type f | awk -F '.txt' '{printf "ln -s %s %s_CUSTOM_TEXT.txt\n", $0, $1}' | sh
split file /usr/bin/firefox into pieces per 1000 lines </s> split -n 1000 /usr/bin/firefox
cope *.mp3 files to /tmp/MusicFiles </s> find . -type f -name "*.mp3" -exec cp {} /tmp/MusicFiles \;
Find all Makefile's in the current directory tree and look for line 235 in each of them </s> find . -name Makefile -print0 | xargs -0 grep -nH $ | grep :235:
Find files belonging to the given owner </s> find /path/to/search -user owner
Find all SUID files in entire file system </s> find / -perm +4000
Search the current directory tree for regular files changed on the 10th of September </s> find ./ -type f -ls |grep '10 Sep'
Find all *.jpg files under current directory and print only unique names </s> find . -name \*.jpg -exec basename {} \; | uniq -u
Find all files/directores under '/usr/local' directory tree that contain the word 'blast' in their names </s> find /usr/local -name "*blast*"
Recursively find strings in all files under current directory, that matching with comma-separated patterns list in file 'searches-txt' </s> cat searches.txt| xargs -I {} -d, -n 1 grep  -r {}
change the permissions of all the files ending with "fits" in the folder "/store/01" and save the output file names to a log file </s> find /store/01 -name "*.fits" -exec chmod -x+r {} \; -exec ls -l {} \; | tee ALL_FILES.LOG
Print the names and sizes of regular files residing in the "tmp" directory tree </s> find tmp -type f -printf "f %s %p\n" | awk '{sub(/^[^ ]+ +[^ ]/,sprintf("%s %10d",$1,$2))}1'
Remove all non-hidden files in the current directory tree </s> find -name "*" | xargs rm -f
search for "specified string" in all the php files in the current folder </s> find . -name “*.[php|PHP]” -print | xargs grep -HnT “specified string”
Find all directories under current directory </s> find . -type d
Make a new directory "new-dir" in every directory in the current directory tree </s> find . -type d | xargs -I "{x}" mkdir "{x}"/new-dir
Remount "/system" with read and write permission </s> mount -o rw,remount /system
Find every file under the directory /usr ending in ".stat". </s> find /usr -name *stat
find all the directories starting with the name "someNamePrefix" which have not been modified in the last 10 days and force delete them </s> find /somePath -type d -name ‘someNamePrefix*’ -mtime +10 -print | xargs rm -rf ;
Prints first found folder that contains 'ssh' file and has 'bin' in path. </s> dirname `find / -name ssh | grep bin | head -1`
Search the current directory recursively for files containing "needle text" </s> find . -type f -exec grep -Iq . {} \; -and -print0 | xargs -0 grep "needle text"
Print all lines from file 'report.txt' containing any-cased 'error' pattern </s> cat report.txt | grep -i error
Search all Python files in the current directory tree for string "import antigravity" </s> find . -name "*.py" | xargs grep 'import antigravity'
Find every JavaScript file in the wordpress directory </s> find wordpress -maxdepth 1 -name '*js'
List all regular files in the current directory tree </s> find . -type f -print0 | xargs -0 ls -l
Report available space on the file system containing /tmp in kilobytes. </s> df -k /tmp | tail -1 | awk '{print $4}'
Search directory trees foo and bar for .java files </s> find foo bar -name "*.java"
Recursively change the user and group of all files in "/var/lib/jenkins" to "root" </s> chown -R root:root /var/lib/jenkins
Print a sorted list of the extensions of the regular files from the current directory tree </s> find . -type f -name "*.*" | awk -F. '{print $NF}' | sort -u
find all jpg files in the current folder </s> find . -name "*.jpg"
Search the entire file system for .jpg files. </s> find / -name “*.jpg”
Recursively finds all files and prints all strings with 'text-to-find-here' from that files. </s> find / -type f | xargs grep 'text-to-find-here'
Find all files in the current directory and below with extension .php and replace "php" with "html" in their names </s> find ./ -type f -name "*.php"  | xargs -r rename "s/php/html/"
Archive "/media/10001/music/" on host "server" to local directory "/media/incoming/music/" and skip files that are newer in the destination, delete any files in the destination not in the source, and compress data during transmission </s> rsync -avzru --delete-excluded server:/media/10001/music/ /media/Incoming/music/
Remove regular files in the current directory tree </s> find . -type f -print0 | xargs -0 -n1 echo rm | sh -x
Archive "/source/backup" to "/destination" with compression during transfer </s> rsync -ravz /source/backup /destination
Find all regular files in /usr/bin modified less than within the last 10 days </s> find /usr/bin -type f -mtime -10
find regular  file named foo.txt under root / directory. </s> find / -name foo.txt -type f
Calculate the md5 sum of "logdir" and print only the hash </s> echo -n "logdir" | md5sum - | awk '{print $1}'
Calculate the md5 sum of "exampleString" </s> echo -n 'exampleString' | md5sum
Find PHP files containing 2 or more classes </s> find . -type f -name "*.php" -exec grep --with-filename -c "^class " {} \; | grep ":[2-99]" | sort -t ":" -k 2 -n -r
display all the files in the home folder which are smaller than 500 bytes </s> find $HOME -size -500b
Print information of the process running the current script as the current user </s> ps -ef | grep $0 | grep $(whoami)
Find all files named 'foo' under your home directory and list them with confirmation prompt </s> find ~ -type f -name 'foo*' -ok ls -l '{}' ';'
Remount "yaffs2" filesystem "/dev/block/mtdblk4" to "/system" as read only </s> mount -o ro,remount -t yaffs2 /dev/block/mtdblk4 /system
change the permission of all the regular files in the folder /home to 700 </s> find /home -type f -perm 0777 -print -exec chmod 700 {} \;
Find directories and regular files containing `blah' in their names modified less than 2 days ago, case insensitive </s> find . -iname '*blah*' \( -type d -o -type f \) -mtime -2
find & Substitute Only When the Line Matches with the Pattern Using sed </s> find . -type f -name "*.txt" -exec sed '/\-/s /\-.*//g'  {} \;
search for the word bananas in the all the regular/normal files in the entire file system </s> find / -type f -exec grep bananas {} \; -print
find all normal/regular files in current folder and display the total lines in them </s> find . -type f -exec wc -l {} +
Recursively removes all files like '*.r*' in current folder and removes folders with such files if they become empty. </s> find ./ -type f -name '*.r*' -delete -printf "%h\0" | xargs -0 rmdir
Find all .php files in all directory trees matching pattern `/srv/www/*/htdocs/system/application/' and search those files for string "debug (" </s> find /srv/www/*/htdocs/system/application/ -name "*.php" -exec grep -H "debug (" {} +
Find all files in maximum 2 levels down the current directory </s> find . -maxdepth 2  -type f
file1.txt and file2.txt both contain a name and a number on each line. For each name whose corresponding number does not match in both files, display the "Age of ... is different" message. </s> join file{1,2}.txt | awk '$2 != $3 { print "Age of " $1 " is different" }'
Delete all regular files named 'IMAGE1806.jpg' under current directory tree </s> find . -type f -name 'IMAGE1806.jpg' -delete
Search the current directory tree for all files matching regular expression ".*\.rb$" </s> find . -regex ".*\\.rb$"
Search for 'mystring' in all *.txt (case insensitive) files under current directory </s> find . -iname *.txt -exec egrep mystring \{\} \;
Replace spaces in directory names with underscores for all directories in the current directory tree </s> find -name "* *" -type d | rename 's/ /_/g'
Print the list of the subdirectories of the current directory </s> find . -mindepth 1 -maxdepth 1 -type d -printf "%P\n"
Sets shell options 'extglob' and 'nullglob'. </s> shopt -s nullglob extglob
Append the last modification time of file $arg as the seconds since epoch with a preceding space to the variable 'KEY' </s> KEY+=`date -r "$arg" +\ %s`
Get the total sizes of all files under current directory </s> find . -type f -printf '%p %s\n'  | awk '{sum+=$NF}END{print sum}'
Copy file linked to by "bar.pdf" to "bar.pdf" </s> cp --remove-destination `readlink bar.pdf` bar.pdf
find all the files in current directory of size greater than 10MB and less than 20 MB. </s> find . -size +10M -size -20M
replace "exp_to_find_for_replacement" with "exp_to_replace" for all the files in the current folder </s> find -name ‘*exp_to_find_in_folders*’ -exec rename “s/exp_to_find_for_replacement/exp_to_replace/” {} \;
Find all files/directories named file1 under current directory </s> find -name file1
find the file "httpd.log" in the folder /home/web-server/ </s> find /home/web-server/ -type f -name httpd.log
Search for "CONFIG_64BIT" in gzip compressed file "/proc/config.gz" </s> zcat /proc/config.gz | grep CONFIG_64BIT
all .jpg or .png images modified in the past week </s> find . -mtime -7 \( '*.jpg' -o -name '*.png' \)
Find all CSS files that do something with HTML ID #content </s> find . -name "*.css" -exec grep -l "#content" {} \;
Find files that were modified less than 7 days ago and archive them </s> find . -type f -mtime -7 | xargs tar -cvf `date '+%d%m%Y'_archive.tar`
Search for files/directories which are writable by either their owner or their group </s> find . -perm /220
Find all files under current directory and change their permission to 400 </s> find . -type f -exec chmod 400 {} \;
display all files in the current folder </s> find .
Find all files/directories under 'my key phrase' directory </s> find 'my key phrase'
Save only the digits in "$filename" to variable "number" </s> number=$(echo $filename | tr -cd '[[:digit:]]')
Make directories "3/foo", "3/bar", and "3/baz" </s> mkdir 3/foo 3/bar 3/baz
Recursively finds 'pattern' in files from current folder, and prints matched string with number only if matching whole word. </s> grep -rnw "pattern"
Find all files/directories named file1 in maximum 2 levels down the current directory </s> find -maxdepth 2 -name file1
find all files under the /etc directory and display any IP address patterns in them </s> find /etc -exec grep '[0-9][0-9]*[.][0-9][0-9]*[.][0-9][0-9]*[.][0-9][0-9]*' {} \;
Print a count of all unique entries in "ips.txt" with the most frequent results at the top </s> sort ips.txt | uniq -c | sort -bgr
Print each unique line that is duplicated in files "file1" and "file2" combined </s> sort file1 file2 | uniq -d
Search the current directory tree for files named "somename", case insensitive </s> find -iname 'somename'
Print the PIDs of the current user's instances of "firefox" </s> ps -u $(whoami) | grep firefox | awk '{printf $1}'
find all the xml files in current folder and which are present in the pattern list file "/tmp/a" </s> find . -name "*.xml" -exec grep -HFf /tmp/a {} \;
Allow all users to execute '$pathToShell"myShell.sh"' </s> chmod a+x $pathToShell"myShell.sh"
Find files newer than main.css in ~/src </s> find ~/src -newer main.css
Find all files in the current directory tree named 'FILES.EXT' </s> find . -name "FILES.EXT"
Removes all files from current folder but 5 newest ones, ignoring folders in a files list. </s> find . -maxdepth 1 -type f | xargs -x ls -t | awk 'NR>5' | xargs -L1 rm
Read a single character from standard input with prompt "Are you sure? " </s> read -p "Are you sure? " -n 1 -r
Find all directories under and below directory "folder_name", and change their permissions to 775 </s> find folder_name -type d -exec chmod 775 ‘{}’ \;
search for the directory "mysql" in the /etc folder </s> find /etc -name mysql -type d
check readline bindings for "\x61" </s> bind -p | grep $'"\x61"'
create directories mnt and point </s> mkdir mnt point
Search case insensitively for 'facebook', 'xing', 'linkedin', ''googleplus' in file 'access-log.txt', extract the matched part, sort them and print them by sorting them in asending order of the number of repeated lines </s> grep -ioh "facebook\|xing\|linkedin\|googleplus" access-log.txt | sort | uniq -c | sort -n
Compress all files under /source directory tree using gzip with best compression method </s> find /source -type f -print0 | xargs -0 -n 1 -P $CORES gzip -9
display all the files in the file system which do not belong to the user "wnj" and which are modified before the file "ttt" </s> find / \! \( -newer ttt -user wnj \) -print
Add a line number to every line in "long-file" </s> nl -ba long-file \
Lookup information for user "vivek" </s> finger vivek
Copy *.txt files from the dir/ directory tree along with their parent directories </s> find dir/ -name '*.txt' | xargs cp -a --target-directory=dir_txt/ --parents
Lists long format information about file '/bin/echo'. </s> ls -l /bin/echo
Delete all files under /path/to/input/ that match the case insensitive string literal 'spammer@spammy.com' in their contents </s> find /path/to/input/ -type f -exec grep -qiF spammer@spammy.com \{\} \; -delete
Recursively find the latest modified "zip" file in the current directory </s> find . -name "*zip" -type f | xargs ls -ltr | tail -1
find all the files which end with ".deb" and display their base name (strip the extension) </s> find . -name '*.deb' -exec basename {} \;
Print every three lines of "file" as a comma separated line </s> paste -sd',,\n' file
Set file permission to 664 and directory permission to 775 for all files and directories under htdocs </s> find htdocs -type f -exec chmod 664 {} + -o -type d -exec chmod 775 {} +
Find all regular files that reside in the current directory tree and were last modified more than 5 days ago </s> find . -type f -mtime +5
Adds %Pathname% to the dirs stack (Windows format). </s> pushd %Pathname%
Recursively change the ownership of all directories in the current directory excluding "foo" to "Camsoft" </s> ls -d * | grep -v foo | xargs -d "\n" chown -R Camsoft
Search the /path directory recursively for TXT files </s> find /path -type f -iname "*.txt"
Find all files named "file.ext" within the current folder and print the path where each one is located </s> find `pwd` -name "file.ext" -exec echo $(dirname {}) \;
Make directories and parents as needed to "${raw_folder}" and "${split_folder}" </s> mkdir -p ${raw_folder} ${split_folder}
Find the directories whose names contain "New Parts" at level 3 of the current directory tree and create symlinks to them in /cygdrive/c/Views </s> find -mindepth 3 -maxdepth 3 -type d -name "*New Parts*" -exec ln -s -t /cygdrive/c/Views {} \;
find all the files in the current folder with the name "test-a" and move them to the folder test-10. execdir runs the command in the directory where the file is found. </s> find ~ -type f -name test-a -execdir mv {} test-10 \;
Print command line of process with pid 17709 </s> cat /proc/17709/cmdline | xargs -0 echo
Search subdirectory `Linux' in the current directory for file `teste.tex' </s> find -path './Linux/*' -name teste.tex
Find all /path/to/check/* regular files without descending into any directory </s> find /path/to/check/* -maxdepth 0 -type f
Find files not matching the posix extended regex '.+\-[0-9]{2,4}x[0-9]{2,4}\.jpg' in their paths under Folder1 and copy them to Folder2 </s> find Folder1 -type f -regextype posix-extended \( ! -regex '.+\-[0-9]{2,4}x[0-9]{2,4}\.jpg' \) -print0 |  xargs -0 cp -p --target-directory=Folder2
Merge files 'text.txt' and 'codes.txt' by outputting any lines whose second field in the first matches the first field in the second. </s> join -1 2 -2 1 text.txt codes.txt
Find all the files on the system that have been modified within the last hour </s> find / -mmin -60
Find all files starting from the current directory that contain '.java' in their pathnames </s> find . -print | grep '\.java'
Print relative path of device of disk with UUID "b928a862-6b3c-45a8-82fe-8f1db2863be3" </s> readlink /dev/disk/by-uuid/b928a862-6b3c-45a8-82fe-8f1db2863be3
Report file systems disk usage using POSIX output format. </s> df -P
Remount "/home/evgeny" with the "suid" flag set </s> sudo mount -i -o remount,suid /home/evgeny
Look for any files that have not been modified in the last two days </s> find -mtime +2
display a long listing of all the files in the /var folder which are bigger than 10MB. print0 is used to handle the files which have new lines in their names </s> find /var -size +10000k -print0 | xargs -0 ls -lSh
search for regular files in the current folder which path is not  "./.*" and not "./*/.*" </s> find ./ -type f -name "*" ! -path "./.*" ! -path "./*/.*"
Save first one of space separated parts of each line in $LOCKFILE file to the 'CURRENT_PID_FROM_LOCKFILE' variable </s> CURRENT_PID_FROM_LOCKFILE=`cat $LOCKFILE | cut -f 1 -d " "`
find all files ending with "js.compiled" in current folder and rename them. </s> find . -name "*.js.compiled" -exec rename -v 's/\.compiled$//' {} +
Find all files accessed on the 29th of September, 2008, starting from the current directory </s> find . -type f -newerat 2008-09-29 ! -newerat 2008-09-30
Change owner of "my_test_expect.exp" to "el" </s> sudo chown el my_test_expect.exp
Find all *.txt files/directories under current directory </s> find -name '*.txt'
Find all files/directories under '/home/user/' directory tree whose status was changed exactly 10 minitues ago </s> find /home/user/ -cmin 10 -print
Print line number "${linenum}" in file "$filename" </s> cat $filename | sed "${linenum}p;d";
Remove trailing white spaces from all *.rb, *.html, *.js, *.coffee, *.css, *.scss, *.erb, *.yml, *.ru files under current directory </s> find . \( -name *.rb -or -name *.html -or -name *.js -or -name *.coffee -or -name *.css -or -name *.scss -or -name *.erb -or -name *.yml -or -name *.ru \) -print0 | xargs -0 sed -i '' -E "s/[[:space:]]*$//"
Find all files/directories named file in minimum 4 levels down the current directory </s> find -mindepth 4 -name file
generates a list of all files beneath the current directory whose filename DOES NOT end in .html, so it matches files like *.txt, *.jpg, and so on. </s> find . -type f -not -name "*.html"
If variable "c" is a syntactically correct cron job, erase user's cron jobs and add "c" as the only cron job for user. </s> echo $c | crontab
concatenates file1.txt, file2.txt, and file3.txt with the filenames printed at the beginning of file contents </s> head -n99999999 file1.txt file2.txt file3.txt
Recursively findsfiles with text pattern in current folder, ingnoring case differences, prefixes each matched line with number in file and suppresses error messages about nonexistent or unreadable files. </s> grep -insr "pattern" *
Finds IP address of 'en0' network interface. </s> ifconfig en0 | grep inet | grep -v inet6 | awk '{print $2}'
Find directory "your/dir" if it is empty </s> find your/dir -prune -empty
List all files under current directory with their paths and sizes </s> find . -type f |xargs ls -lS |head -20 | awk '{print $9, $5}'
Delete all the files found in the current directory tree whose names begin with "heapdump" </s> find . -name heapdump* -exec rm {} \ ;
Find all files whose names begin with 'Makefile' in the /usr/ports directory tree and count how many of them contain 'QTDIR' </s> find /usr/ports/ -name Makefile\* -exec grep -l QTDIR '{}' '+' | wc -l
Write "[some repository]" to standard output and append to "/etc/apt/sources.list" as root </s> echo "[some repository]" | sudo tee -a /etc/apt/sources.list
create a list of all files in all subdirectories </s> find . -type f -exec md5 {} \;
Enables shell option 'nullglob'. </s> shopt -s execfail
Compresses file 'example.log' keeping original file in place. </s> bzip2 -k example.log
change permission of all the files in the entire file system which have the permissions 777. </s> find / -type f -perm 0777 -print -exec chmod 644 {} \;
Recursively finds string 'class foo' in all *.c files from current folder. </s> grep "class foo" **/*.c
Search the path given as the $absolute_dir_path variable for regular files </s> find "$absolute_dir_path" -type f -print0
Merge each non-blank line of standard input into a single comma separated line </s> grep -v '^$' | paste -s -d"," -
Find "*.dat" files recursively in the current directory, print the lines starting on line 5 to the console and save to "concat.txt" </s> find . -type f \( -name "*.dat" \) -exec tail -n+5 -q "$file" {} + |tee concat.txt
Find files/directories under current directory that matches './projects/insanewebproject' in their paths </s> find -ipath './projects/insanewebproject'
Execute "cat /tmp/iostat.running" every 10 seconds </s> watch -n10 cat /tmp/iostat.running
Find all the files in file system which are accessed in last 1 hour </s> find / -amin -60
Print each line in "file1" whose first word does not exist as the first word of any line in "file2" </s> join -v 1 <(sort file1) <(sort file2)
Find all files larger than 20000k and print their names and sizes </s> find / -type f -size +20000k -exec ls -lh {} \; | awk '{ print $8 ": " $5 }'
Create an archive named newArch from the contents of ./test directory </s> find ./test -printf "././%f\n"| cpio -o -F newArch
Print file system disk space usage of the current directory's file system </s> df .
display all executable files in the folder /home </s> find /home -perm /a=x
Concatenate with a space every other line in "input.txt" </s> paste -s -d' \n' input.txt
copy a files from one folder to all the folder in the /raid which have an extension local_sd_customize. </s> find /raid -type d -name ".local_sd_customize" -ok cp /raid/04d/MCAD-apps/I_Custom/SD_custom/site_sd_customize/user_filer_project_dirs {} \;
Change permissions to 644 for all regular files under and below /path/to/someDirectory/ </s> find /path/to/someDirectory -type f -print0 | xargs -0 sudo chmod 644
search for all regular/normal files in the current folder and display the number of lines in the file </s> find . -type f -print0 | xargs -0L1 wc -l
Search for broken symlinks </s> find -L -type l
Force create a symbolic link as a file named "/usr/lib/jvm/default-java" to "$default_java_dir" with verbose output </s> sudo ln -sTfv "$default_java_dir" "/usr/lib/jvm/default-java"
search for all the files in current folder which start with "file2015-0" and move them to frst 400 fiiles  to another folder </s> find . -name "file2015-0*" | head -400 | xargs -I filename mv  filename
Run an awk program on every TXT file found in the current directory tree </s> find . -name '*txt' -print -exec awk 'BEGIN {nl=1 ;print FILENAME} $9 !="" {if (nl<11) { print $0 ; nl = nl + 1 }}' {}  \;
Search the /root directory recursively for files named "FindCommandExamples.txt" </s> find /root -name FindCommandExamples.txt
Search for files specifying the maximum depth of the search </s> find -maxdepth num -name query
Search the home directory tree for video files </s> find ~ -type f -regex '.*\.\(mkv\|mp4\|wmv\|flv\|webm\|mov\)'
find all the files in the folder ./machbook and change the owner of them to the user with id "184" </s> find ./machbook -exec chown 184 {} \;
Find all *.xml.bz2 files under current directory </s> find . -name \*.xml.bz2
Filters unique lines by matching against the first column of a .csv file </s> tac a.csv | sort -u -t, -r -k1,1 |tac
Find all files/directories under .. directory and copy them to ~/foo/bar </s> find .. -exec cp -t ~/foo/bar -- {} +
Search the home directory for filenames starting with "xx" except for "xxx" files </s> find ~ -name 'xx*' -and -not -name 'xxx'
Split "${fspec}" into 6 files with about equal number of lines each and use prefix "xyzzy." </s> split --number=l/6 ${fspec} xyzzy.
Count the number of files in the directory trees whose pathnames match pattern '/dev/sd*[a-z]' </s> find /dev/sd*[a-z] -printf . | wc -c
Recursively copy all directories in "/path/to/source" to "/path/to/dest/" preserving directory hierarchy </s> find /path/to/source -type d | cpio -pd /path/to/dest/
Find files/directories writable by group or others under the /path directory </s> find /path -perm /g+w,o+w
Find all SUID files . </s> find /  -perm /u=s
Search the files from the current directory tree for "foo" </s> find . -exec grep foo {} \;
Print the lines of file "strings" specified in file "index" </s> join <(sort index) <(nl strings | sort -b)
Print output of script 'trap.sh' </s> ~ $ . trap.sh | cat
Find all .txt files under the current directory and below </s> find -name \*.txt
search for the word "foo" in all the regular/normal files in the directory "/path/to/dir" </s> find /path/to/dir -type f | xargs grep -l "foo"
Locate all *.csv files under the current directory tree </s> find . -name "*.csv" -print
Print summary of new/missing files, and which files differ between folder1 and folder2. </s> diff -arq folder1 folder2
Dump "file" as ASCII characters </s> od -t c file
Recursively copy directory "/path/to/data/myappdata" to "user@host:/remote/path/to/data/myappdata" </s> rsync -rvv /path/to/data/myappdata user@host:/remote/path/to/data/myappdata
Mount "/path/to/device" on "/path/to/mount/location" as a vfat filesystem and a loop back device </s> mount /path/to/device /path/to/mount/location -o loop -t vfat
Find all directories under minimum 1 level down the current directory excluding  directories (along with their contents) that start with a . (dot) in their names </s> find . -mindepth 1 -name '.*' -prune -o \( -type d -print \)
change user and group of the file /usr/bin/aws to user amzadm and group root </s> chown amzadm.root  /usr/bin/aws
Show manual for the find command </s> man find
Find recursively all files in /path that end in "txt" and copy them to /tmp/ </s> find /path -type f -name "*txt" -printf "cp '%p' '/tmp/test_%f'\n" | bash
Print 'file' content, formatting output as 29-symbol wide column </s> cat file | fold -w29
Search /etc for files modified within the last 10 minutes </s> find /etc -type f -mmin -10
Search the current directory recursively for regular files with the read permission set for everybody </s> find -type f ! -perm -444
Creates 5-letter random file name and saves it in 'rand_str' variable. </s> rand_str="$(mktemp --dry-run XXXXX)"
find all the text files in the current folder and display the results pagewise </s> find . -name "*.txt" -print | less
Search the current directory tree for files without "test" in their path names </s> find . -not -regex ".*test.*"
Recursively change all permissions under "theDirectory/" to 777(read,write,execute for all users) </s> sudo chmod -R 777 theDirectory/
find for a word in all the regular files in the current directory </s> find . -type f -exec grep -li '/bin/ksh' {} \;
List files in the current directory tree using echo </s> find . -exec echo {} ;
Print the first 24 alphanumeric characters from "/dev/urandom", determining C locale for all categories </s> cat /dev/urandom | LC_ALL=C tr -dc 'a-zA-Z0-9' | fold -w 24 | head -n 1
Find all *.jpg files under current directory </s> find . -name *.jpg
Recursively change the owner and group of "/opt/antoniod/" to "antoniod" </s> chown -R antoniod:antoniod /opt/antoniod/
Move "/usr/bin/openssl" to directory "/root/" </s> mv /usr/bin/openssl /root/
Finds strings with 'TEXT' from *.log files and prints all but first field from any space-delimited string. </s> grep -e TEXT *.log | cut -d' ' --complement -s -f1
find all files  the current folder which have not been accessed in the last 7 days and which are bigger than 20KB </s> find . -atime +7 -size +20480 -print
Print list of all user names who are logged in </s> who | awk '{ print $1 }'
find files in home directory that accessed more than 100 days ago </s> find ~ -atime 100
find all the directories in the current folder excluding search in the sub directories and create these directories in another path </s> find . -maxdepth 1 -type d | xargs -I X mkdir '/new/directory/X'
Search the current directory tree for a regular file named "file_name" </s> find . -type f -name file_name
Find files matching `.ssh*' and append their anmes to file `ssh-stuff' </s> find / -name .ssh* -print | tee -a ssh-stuff
display all regular files in the folder image-folder </s> find image-folder/ -type f
display all normal/regular files in the folder "$ORIG_DIR" </s> find "$ORIG_DIR" -name "*" -type f
Gives longest '*.php' files with line count first, and excludes directories with "libs", "tmp", "tests" and  "vendor" in their paths. </s> find . -name '*.php' | xargs wc -l | sort -nr | egrep -v "libs|tmp|tests|vendor" | less
Find the largest 10 directories under current directory </s> find . -type d -print0 | xargs -0 du | sort -n | tail -10 | cut -f2 | xargs -I{} du -sh {}
Print bash environment variable array "fields" and its values </s> set | grep ^fields=\\\|^var=
Recursively finds strings with"text string to search” in files under 'directory-path', regarding provided options '[option]'. </s> grep [option] "text string to search” directory-path
Find files in the current directory tree that match pattern "*sub*" </s> find ./ -name "*sub*"
Print A record for domain 'domain.' from 8.8.8.8 nameserver </s> dig @8.8.8.8 domain. a
find all regex  ".*/[a-f0-9\-]\{36\}\.jpg" files </s> find . -regextype sed -regex ".*/[a-f0-9\-]\{36\}\.jpg"
change the owner and group of all the directories in the current folder and /home/admin/data/ to admin & admin </s> find . /home/admin/data/ -type d -exec chown admin.admin {} \;
Combine every two lines of standard input </s> paste -d "" - -
Print only the number of lines in file "$f" </s> wc -l $f | tr -s ' ' | cut -d ' ' -f 1
display all normal/regular files in current folder </s> find . -type f -print0
create directory /etc/cron.15sec </s> mkdir /etc/cron.15sec
Delete all files under and below the current directory </s> find -mindepth 1 -delete
search for the word "nutshell" or "Nutshell" in all the files in the folder book </s> find /book -print | xargs grep '[Nn] utshell'
Mount "ext4" filesystem "/dev/xvdf" on "/vol" </s> sudo mount /dev/xvdf /vol -t ext4
Find all files/directories under current directory and print them with newline as the delimiter </s> find -print | xargs -d'\n'
Search the current directory tree for files named 'Subscription.java' </s> find . -name 'Subscription.java'
List all files/directories under current directory with 'FooBar' in their paths ensuring white space safety </s> find . -print0 | grep --null 'FooBar' | xargs -0
List all files under current directory matching the regex '.*\.\(c\|h\|cpp\)' </s> find . -type f -regex '.*\.\(c\|h\|cpp\)' -exec ls {} \;
Save the md5 sum hash of "$my_iso_file" to variable "md5" </s> md5=$(md5sum "$my_iso_file" | cut -d ' ' -f 1)
search for all the files in current folder and display all the file names separated by space </s> find . | awk '{printf "%s ", $0}'
Find all .c, .h files in the current directory tree and search them for string "expr" </s> find . -name '*.[ch]' | xargs grep -E 'expr'
Find file `hosts' </s> find /etc -name hosts
Print $d if $d is empty </s> find "$d" -prune -empty
Remove all files with '.js' extension from the 'js' directory tree </s> find ./js/ -type f -name "*.js" | xargs rm -f
Creates temporary folder and saves path to it in 'other' variable. </s> other="$(mktemp --directory)"
Find all directories under /home/username/public_html/modules  and set their permission to 750 </s> find /home/username/public_html/modules -type d -exec chmod 750 {} +
search for the file centos in /usr folder ( case insenstive search ) </s> find /usr -iname centos
Forcefully delete all files in the current directory that begin with spam- </s> find . -name 'spam-*' | xargs rm
Print the number of regular files found in the current directory tree </s> find . -type f | wc -l
Search the entire file hierarchy for files named zsh that exist on ext3 file systems and print out detailed information about the file. </s> find / -fstype ext3 -name zsh -ls
remove all subdirectories named "CVS" under current dir </s> find . -type d -name CVS -exec rm -r {} \;
Recursively finds file some_file_name.xml file and prints strings with "PUT_YOUR_STRING_HERE" preceding each found string with file name. </s> find . -type f -name some_file_name.xml -exec grep -H PUT_YOUR_STRING_HERE {} \;
Find all files/directories under '/usr/share/doc' directory tree whose name start with 'README' </s> find /usr/share/doc -name README\*
Pipe 3 newlines to sshe-keygen, answering prompts automatically. </s> echo -e "\n\n\n" | ssh-keygen -t rsa
Set the 'pipefail' shell variable causing bash to return true only if all commands in a pipeline return true. </s> set -o pipefail
List all regular files under the current directory and below it </s> find . -type f | xargs ls -l
Search for files that were accessed less than 5 days ago. </s> find -atime -5
search for files which are writable by either their owner or their group </s> find . -perm /220
Find StringBuffer in all *.java files </s> find . -type f -name "*.java" -exec grep -l StringBuffer {} \;
create a symbolic link named "/usr/bin/my-editor" to file "/usr/share/my-ditor/my-editor-executable" </s> ln -s /usr/share/my-ditor/my-editor-executable /usr/bin/my-editor
Search for the regex "+\S\+" in file 'in.txt' and print the matches by replacing newlines with comma (',') </s> grep -o "+\S\+" in.txt | tr '\n' ','
gives the chars in line 5 and chars 5 to 8 of line 5, in tst.txt </s> head -5 tst.txt | tail -1 |cut -c 5-8
Mount "/tmp/loop.img" on "/mnt/image" as a loop back device </s> mount /tmp/loop.img /mnt/image -o loop
Find the passwd file under root and two levels down </s> find / -maxdepth 3 -name passwd
find all the files in the current folder which are bigger than 1MB </s> find . — size +1000k -print
Serach in current directory downwards all files which  have not been modified since last 7 days </s> find .  -mtime +7 -print
Search the home directory tree for files last modified less than 2 days ago or newer than file "filename" </s> find ~/ -mtime -2 -o newer filename
Search the ./bin directory recursively for files called "cp" </s> find ./bin -name “cp”
List directories in the current working directory and remove the trailing "/" </s> ls -d */|sed 's|[/]||g'
Calculate the md5 sum of the file "filename" and print only the hash </s> md5sum filename |cut -f 1 -d " "
search for all "tif" images in the entire file system </s> find / -name '*.tif ' –print
List all environment variables containing 'USER' in their name or value that would result in running a command with 'sudo env'. </s> sudo env |grep USER
Search the current directory tree for regular files owned by user "www" </s> find -type f -user www
Find all files/directories named 'Desktop' under current directory </s> find ./ -name Desktop
Find file size in bytes </s> du -b FILE
Append ".txt" to all filenames in the current directory tree </s> find -type f | xargs -I {} mv {} {}.txt
Find files on the system that are bigger than 20 megabytes </s> find / -type f -size +20M -exec ls -lh {} \; | awk '{ print $NF ": " $5 }'
Search in current directory downwards all files whose size is 10 bytes ( Characters ) . </s> find . -size 10c -print
change the permissions of all the regular/normal files in the current folder </s> sudo find . -type f -exec chmod 644 {} +
Read the raw input of "/dev/input/mice" as hexadecimal bytes with 3 bytes per line </s> cat /dev/input/mice | od -t x1 -w3
find all the directories in the current directory which dont have the execute permission. </s> find -type d ! -perm -111
Search for "whatever" in all files under /dir directory ensuring white space safety in filenames </s> find /dir -type f -print0 | xargs -0i cat {} | grep whatever
find list of all files with file permission , link , owner , group , reation time , size , file name </s> find . -exec ls -ld {} \;
Find all files/directories under current directory with 'FooBar' in their paths and copy them to ~/foo/bar </s> find . | grep "FooBar" | tr \\n \\0 | xargs -0 -I{} cp "{}" ~/foo/bar
Print and recursively remove the alphabetically last directory in the current directory </s> find -mindepth 1 -maxdepth 1 -type d | cut -c 3- | sort -k1n | tail -n 1 | xargs -r echo rm -r
Print unique lines of "a" and "b" </s> comm -3 a b
search for the folder .dummy and remove it from the folder "Test folder" </s> find "Test Folder" -type d -name .dummy -exec rm -rf \"{}\" \;
Find all .txt files in the /home/user1 directory tree and copy them to /home/backup </s> find /home/user1 -name '*.txt' | xargs cp -av --target-directory=/home/backup/ --parents
display long list of all the perl files in the current folder </s> find . -name "*.pl" -ls
Print the real path of "$F" where each symbolic link component must exist </s> echo "$(dirname $(readlink -e $F))/$(basename $F)"
Remove files whose names start with `Foo' </s> find . -type f -name "Foo*" -exec rm {} \;
Find all files/directories matching the regex pattern ".*\\.rb$" under current directory </s> find . -regex ".*\\.rb$"
Prints ten latest modified files within the current directory. </s> find . -type f -printf '%T@ %p\n' | sort -n -r | head -${numl} |  cut -f2- -d" " | sed -e 's,^\./,,' | xargs ls -U -l
List all files with their paths that have identical content. </s> find * -type f | xargs md5sum | sort | uniq -Dw32
Find all JPG files under the "$SOURCE" directory and below </s> find "$SOURCE" -type f -iname '*.jpg'
Find all files/directories with '.txt' extension that are less than 100 KB in size under '/home' directory tree </s> find /home -name "*.txt" -size -100k
Move all files in "/path/subfolder" to "/path" without clobbering any destination files </s> find /path/subfolder -maxdepth 1 -type f -name '*' -exec mv -n {} /path \;
Delete history entry at offset, defined in first argument of executed script </s> history -d "$1"
display a long list of all the directories which have files ending with ".todo" </s> find "$STORAGEFOLDER" -name .todo -printf '%h\n' | xargs ls -l
Find all files starting from the current directory which are owned by the user tommye </s> find . -user tommye
Search the system for the file “testfile.txt” ignoring the case </s> find / -iname "testfile.txt"
Search the current directory, except the subdirectory tree ".svn", for files whose name is "foo.cpp" </s> find . -name 'foo.cpp' '!' -path '.svn'
Print type of the file system containing path $dir. </s> df -T $dir | tail -1 | awk '{print $2;}'
Copy "src/prog.js" and "images/icon.jpg" to "/tmp/package" keeping relative path names </s> rsync -R src/prog.js images/icon.jpg /tmp/package
Search all files in the current directory tree whose names end in "1" for string "1" </s> find . -name "*1" -exec grep "1" {} +
Find all files under /path and below writable by `group' or `other' </s> find /path -perm /g+w,o+w
display all hidden files in the current folder </s> find . -type f -name ".*"
Locate all *.csv files under the current directory tree separating the file names with zeroes </s> find . -name "*.csv" -print0
Join lines of 'file': fields 1 and 2 of lines discarding adjascent lines ignoring first 3 fields, with fields 3 to end of line discarding adjascent lines ignoring 3 last fields. </s> paste <(uniq -f3 file | cut -f1,2) <(tac file | uniq -f3 | tac | cut -f3-)
Search in the current directory and all sub-directories except ./D and any further sub-directories also named D for the file named hi.dat </s> $ find . \( -name D -prune \) -o -name hi.dat
Output the last slash-separated component of specified path, in this case "data_report_PD_import_script_ABF1_6" </s> basename /EBF/DirectiveFiles/data_report_PD_import_script_ABF1_6
replace the word foo to bar in all the regular/normal files in the current folder (does not update the file) </s> find . -type f -exec sed -i 's/foo/bar/g' {} +
Search directory tree `MyApp.app' for directories whose name is 'Headers' and delete them in an optimized way </s> find -d MyApp.app -name Headers -type d -print0 | xargs -0 rm -rf
Find all directories under current directory and set read-write-execute permission for owner, read-execute permission for group and execute permission for other for those directories </s> find . -type d -exec chmod u=rwx,g=rx,o=x {} \;
Verbosely compresses all files on second and third depth level keeping original files in place. </s> bzip2 -kv */*
Make directory "tata" </s> mkdir tata
display long listing of all the regular hidden files in the folder Musica </s> find Música/* -type f -name ".*" -exec ls -l {} \;
find all configuration files in a folder </s> find /home/pat -iname "*.conf"
Creates temporary file with name formatted like '.script.XXXXXX' in '/tmp/' folder and saves path to it in 'script1' variable. </s> script1=`mktemp /tmp/.script.XXXXXX`;
Print the IP addresses for the current host name </s> hostname  -I | cut -f1 -d' '
Make directory "alpha_real" </s> mkdir alpha_real
Change owner of "folder" to "user_name" </s> chown user_name folder
Print absolute path of "YOUR_PATH" </s> readlink -f YOUR_PATH
Print newline, word and byte count for all .h, .c, .cpp, .php and .cc files under current directory tree and also show the total counts </s> wc `find . -name '*.[h|c|cpp|php|cc]'`
Number each line in "/etc/passwd" as right-justified zero padded to a width of 9 </s> nl -nrz -w9  /etc/passwd
Print the names and sizes of all regular files from the current directory tree </s> find . -type f -printf "%f %s\n"
Print lines in the sorted contents of "second.txt" that are not in the sorted contents of "first.txt" </s> comm -13 <(sort first.txt) <(sort second.txt)
display all the files in the current folder which start with either "fileA_" or "fileB_" </s> find . -name 'fileA_*' -o -name 'fileB_*'
Find files readable only by the group </s> find . -perm g=r -type f -exec ls -l {} \;
find all the directories in current folder which start with test </s> find . -type d -name "test*"
Search the current directory recursively for files last modified within the past 24 hours ignoring .swp files and paths ./es* and ./en* </s> find . -mtime 0 | grep -v '^\./en' | grep -v '^\./es' | grep -v .swp
Search the current directory tree for the files with extension "trc" and remove them if they are more than three days old </s> find . -name "*.trc" -ctime +3 -exec rm -f {} \;
Recursively change the owner and group of all files in the current directory to "apache" </s> ls | xargs chown -R apache:apache
Return the files that are newer than file `myfile' </s> find / -newer myfile
Dry run making directories in "/TARGET_FOLDER_ROOT/" for each ".mov" file in the current directory tree </s> find . -type f -iname \*.mov -printf '%h\n' | sort | uniq | xargs -n 1 -d '\n' -I '{}' echo mkdir -vp "/TARGET_FOLDER_ROOT/{}"
Find all files under and below /dir that were modified less than 60 minutes ago </s> find /dir -mmin -60
Search for all files with either "sitesearch" or "demo" in their path names </s> find . -ipath '*sitesearch*' -ipath '*demo*'
Put the absolute directory path to the current script to MY_DIR variable </s> MY_DIR=$(dirname $(readlink -f $0))
Lists all files in a current folder, separating names with comma. </s> ls -1 | paste -sd "," -
Count the number of "x" characters in "filename" </s> sed 's/[^x]//g' filename | tr -d '\012' | wc -c
Search for $GROUP at the beginning of each line in /etc/group and print the last colon (':') separated entry with comma replaced with newlines </s> grep ^$GROUP /etc/group | grep -o '[^:]*$' | tr ',' '\n'
Remove the regular files from the current directory tree that were last modified on November, 21 </s> find -type f -newermt "Nov 21" ! -newermt "Nov 22" -delete
Return the list of files named "filename" that are 50 megabytes or larger </s> find / -size +50M -iname "filename"
Show the list of files modified more than 31 days ago </s> find / -mtime +31 -print
Print sorted list of unique users logged in followed by a total count </s> who | awk '{ print $1; }' | sort -u | awk '{print $1; u++} END{ print "users: " u}'
Create a table from '111 22 3\n4 555 66\n' with columns separated by a single space </s> echo -en '111 22 3\n4 555 66\n' | column -t | sed 's/ \([0-9]\)/\1/g'
Find all files under current directory whose file type description contains "image", display only path to each file. </s> find . -type f -exec file {} \; | awk -F: '{if ($2 ~/image/) print $1}'
Print how many files are inside each directory under the current one </s> find */ | cut -d/ -f1 | uniq -c
display all the files in the current folder along with the modification time and display file names of the last 10 modified files </s> find . -type f -printf '%T@ %p\n' | sort -n | tail -10 | cut -f2- -d" "
Gets domain name from dig reverse lookup. </s> $dig -x 8.8.8.8 | grep  PTR | grep -o google.*
Show filename and filetype description of all PHP files in all directories contained in current directory whose name or filetype description includes "UTF" </s> file */*.php | grep UTF
Identify CMS version/releases accross all your Drupal websites </s> find /home/*/public_html/ -type f -iwholename "*/modules/system/system.info" -exec grep -H "version = \"" {} \;
display all the files in current folder which have been changed in the last 24 hours </s> find . -ctime -1 -print
Compress all files in directory "$PATH_TO_LOGS" that were last modified more than "$SOME_NUMBER_OF_DAYS" days ago </s> find $PATH_TO_LOGS -maxdepth 1 -mtime +$SOME_NUMBER_OF_DAYS -exec gzip -N {} \;
Print TXT record with server`s hostname from nameserver 'server' </s> dig @server hostname.bind ch txt
Find all sample* files/directories under current directory and print 'program {}-out {}' where {} will expand to file paths </s> find . -name "sample*" | xargs -i echo program {}-out {}
Search for 'Text To Find' in all regular files under current directory tree and show the matched files </s> find ./ -type f -exec grep -l "Text To Find" {} \;
Print the list of files in the current directory tree skipping SVN files </s> find . -type d -name .svn -prune -o -print
find all files that names are game </s> find / -name game
Search the current directory tree for PHP files changed less than 14 days ago </s> find . -name *.php -ctime -14
Force create a symbolc link named "/usr/local/bin/fpdf" to "/usr/local/bin/findpdftext" </s> sudo ln -s -f "/usr/local/bin/findpdftext" "/usr/local/bin/fpdf"
Search the current directory tree for regular files modified within the past 24 hours whose names do not end with ".DS_Store" </s> find . -mtime -1 ! -name '.DS_Store' -type f -exec basename {} \;
List root's regular files with permissions 4000 </s> find / -type f -user root -perm -4000 -exec ls -l {} \;
Recursively finds all '*.png' files older than 50 days in a current folder and removes them. </s> find . -name "*.png" -mtime +50 -exec rm {} \;
Print lines 10000 to 10010 from input "seq 1 100000" </s> seq 1 100000 | tail -n +10000 | head -n 10
Counts all lines in $i file. </s> cat $i | wc -l
Find all files/directories under ./var/log directory </s> find ./var/log
Enables shell option 'failglob'. </s> shopt -s failglob
Search the current directory for files whose names start with my </s> find . -name 'my*'
find al the tmp directories in the current directory and create a dump of it </s> find . -type d -name tmp -prune -o -print | cpio -dump /backup
Find all *.tex regular files under current directory </s> find . -type f -name "*.tex"
Prints "$NEWFILE" to the terminal and file '/etc/timezone' as a root user. </s> echo "$NEWFILE" | sudo tee /etc/apt/sources.list
Prints lines count in each *.c file of a current folder and total count. </s> wc -l *.c
Find all files/directories under current directory bypassing file hierarchies in lexicographical order </s> find -s
Find all files which  are accessed after modifying /etc/passwd files. </s> find -newer /etc/passwd
Request changing the passphrase of key file "private.key" </s> ssh-keygen -pf private.key
display all the files in the current folder which are in the path ending with the folder f </s> find .  -path '*f'
To match only hidden dot directories </s> find /nas01/backups/home/user/ -type d -name ".*" -print0 -exec ls -lrt {} \;
use find command to search for .png and .jpg files </s> find ./ -type f \( -iname \*.jpg -o -iname \*.png \)
find regular files in the "mail" folder under the user's home directory, displaying filenames and lines that contain the text "Linux" </s> find ~/mail -type f | xargs grep "Linux"
Search all files called "abc" that reside in the current directory tree for string "xyz" </s> find . -name "abc" -exec grep "xyz" {} \;
Find all *.cls files/directories under current directory and print '{if(length($0) > L) { LINE=$0; L = length($0)}} END {print LINE"L"L}' for each of them where $0 is expanded to the file/directory path </s> find . -iname "*.cls" -exec echo '{if(length($0) > L) { LINE=$0; L = length($0)}} END {print LINE"L"L}' {} \;
Display long listing of all the files/directories owned by the user 'me' under '/tmp' directory tree </s> find /tmp -user me -ls
search for the files "foo.txt" in the current folder </s> find . -name foo.txt
Gets IP address of 'eth0' network interface. </s> ifconfig eth0 | awk '/inet /{sub(/[^0-9]*/,""); print $1}'
find all class files or sh script files  in the current folder </s> find . -type f \( -name "*.class" -o -name "*.sh" \)
Print the type of the current shell </s> echo $(cat /proc/$$/cmdline)
Search directory foo for files containing "foo/bar" in their full names </s> find foo -path foo/bar -print
Remove all files under /home/user/Maildir/.SPAM/cur </s> find /home/user/Maildir/.SPAM/cur -type f | xargs rm
Counts lines in file fileName ignoring empty lines and lines with spaces only. </s> awk '!/^[[:space:]]*$/{++x} END{print x}' filename
display the html, javascript and text files in the current folder (print0 is used to preserve the filenames of all the files which have newlines in their names) </s> find . -type f \( -name "*.htm*" -o -name "*.js*" -o -name "*.txt" \) -print0 | xargs -0 -n1 echo
search for the word "nameserver" in all the configuration files of the /etc folder </s> find /etc/ -type f -name "*.conf" -print0 | xargs -I {} -0 grep "nameserver" "{}"
Count the number of regular files with 755 permission under current directory tree </s> find . -type f -perm 755 | wc -l
Convert *.au files to *.wav files using `sox' </s> find -type f -name '*.au' | awk '{printf "sox %s %s\n",$0,$0".wav" }' | bash
find all files in the current directory excluding those that end with .js or have the words .min or console in their name </s> find . -type f \( -name "*.js" ! -name "*-min*" ! -name "*console*" \)
Print source directory of bash script </s> dirname "$(readlink -f "$0")"
Prints calendar for a current month, replacing current data with asterisk. </s> cal -h|sed -r "s/\b$(date|cut -d' ' -f3)\b/*/"
Print lines that only unique ones in 'set1' and 'set2' files </s> cat <(grep -vxF -f set1 set2) <(grep -vxF -f set2 set1)
Search the entire system for SUID or SGID files </s> find / -path /proc -prune -o -type f -perm +6000 -ls
Send SIGKILL signal to processes ID 18581, 18582, and 18583, killing them instantly. </s> kill -9 18581 18582 18583
find all the files in the current folder which have a set uid set </s> find . -perm -4000 -print
Remove all files under current directory </s> find -exec rm '{}' +
Compares two listings 'ls' and 'ls *Music*', showing only strings that unique for first listing. </s> comm -23 <(ls) <(ls *Music*)
Find all xml files under current directory and archive them to .bz2 archives </s> find -name \*.xml -print0 | xargs -0 -n 1 -P 3 bzip2
find all  tools generated files  a.out , *.o and core dump files which not required to us these all junk files & delete from  current  directory . </s> find . \( -name a.out -o -name '*.' -o -name  'core' \) -exec rm {} \;
Find links to any file that happens to be named `foo.txt' </s> find / -lname foo.txt
Copy an entire file structure, creating empty files in the copy instead of copying the actual files. </s> find src/ -type d -exec mkdir -p dest/{} \; -o -type f -exec touch dest/{} \;
find all the files in the current directory which end with orig </s> find . -name '*.orig'  -exec echo {} \ ;
Recursively removes all files named '.svn' in a current folder, and prints messages on each action. </s> find . -name .svn -exec rm -v {} \;
search for a word in all the files in the current directory </s> find . -exec grep chrome {} \;
Enables shell option 'direxpand'. </s> shopt -s direxpand
find md5sums of files named "file*.txt" </s> md5sum file*.txt
find all the directories in the file system which begin with "man" </s> find / -type d -name 'man*' -print
Search the /myfiles directory tree for regular files with read and write permissions set for `others' </s> find /myfiles -type f -perm -o+rw
Sort all directories under current directory placing the file with least modification time at first </s> find -type d -printf '%T+ %p\n' | sort
Counts lines of /etc/fstab file. </s> cat /etc/fstab | wc -l
Find regular files in the current directory tree that have all executable bits set </s> find -L . -type f -perm -a=x
find all directories in the current folder and do not search in sub directories </s> find . -type d -maxdepth 1
Make directory "/data/db" </s> sudo mkdir /data/db
Search the current directory recursively for files last modified within the past 24 hours ignoring .swp files and paths ./es* and ./en* </s> find -mtime 0 -not \( -name '*.swp' -o -path './es*' -o -path './en*' \)
Recursively finds all *.txt files and prints strings with "text_pattern" ignoring text distincts. </s> find . -name "*.txt" | xargs grep -i "text_pattern"
display all directories in current folder and do not search in sub directories </s> find . -maxdepth 1 -mindepth 1 -type d
display all directories in the folder "$ORIG_DIR" </s> find "$ORIG_DIR" -name "*" -type d
find all the files ending with "clj" in the current folder and search for a pattern </s> find . -name *.clj | xargs grep -r resources
find all files in the current folder which are of size 0 bytes. </s> find . -type f -empty
Setup a local SSH tunnel from port 1234 to "remote2" port 22 via connection to "remote1" as "user1" on port 45678 </s> ssh -L 1234:remote2:22 -p 45678 user1@remote1
Find all files in /tmp whose names begin with the current user's name followed by "." </s> find /tmp -maxdepth 1 -name "$USER.*"
get the root access </s> sudo su -
Find all directories under path_to_dir directory </s> find path_to_dir -type d
find not case sensitive all directories that names are 'apt' and display details </s> find  / -type d -iname "apt" -ls
Remove all files with the .c extension in the current directory tree </s> find . -name "*.c" -print0 | xargs -0 rm -rf
Find all files of the user with UID=1000 </s> find -user 1000
List level 2 subdirectories of the current directory </s> find . -mindepth 2 -maxdepth 2 -type d -printf '%M %u %g %p\n'
Finds all files like "mylog*.log" newer than $2 and archives them with bzip2. </s> find . -type f -ctime -$2 -name "mylog*.log" | xargs bzip2
display all regular/normal files in a directory </s> find $directory -type f
Display human-readable file type description of utf8.txt </s> file utf8.txt
search for the regulars file starting with HSTD which have been modified yesterday from day start and copy them to /path/tonew/dir </s> find . -type f -iname ‘HSTD*’ -daystart -mtime 1 -exec cp {} /path/to new/dir/ \;
Locate all "copyright" files under and below /usr/share/doc </s> find /usr/share/doc -name "copyright"
Change the permission to 755 for all directories under current directory </s> find . -type d | xargs chmod -v 755
Search all the regular files in the current directory tree for "example" </s> find -type f -print0 | xargs -r0 grep -F 'example'
Search for files only that end with .php and look for the string $test inside those files </s> find . -name \*.php -type f -exec grep -Hn '$test' {} \+
Read a single character from standard input into variable "key" without backslash escapes and using an interactive shell with the prompt $'Are you sure (Y/n) : ' and default value $'Y' </s> read -rp $'Are you sure (Y/n) : ' -ei $'Y' key
find all files in the current folder which have been accessed in the last 30 minutes </s> find . -amin -30
Counts lines in each *.php file. </s> wc -l `find . -name "*.php"`
Find regular files whose names end in .JPG </s> find . -type f -name "*.JPG"
change the group to "new_group" and permissions to 770 for all the files in the current folder </s> find . -name "*" -exec chgrp -v new_group '{}' \; -exec chmod -v 770 '{}' \;
Delete all regular files with inode number 314167125 under current directory tree </s> find . -type f -inum 314167125 -delete
Recursively changes group ownership of the $PATH_TO_OUTPUT_FOLDER directory to $GROUP group. </s> chgrp -R $GROUP $PATH_TO_OUTPUT_FOLDER
Find files larger than 50k </s> find . -size +50k
Find all files under /somefolder matching the case insensitive regex '\(.*error.*\)\|\(^second.*\log$\)\|\(.*FFPC\.log$\)' in their paths </s> find /somefolder -type f | grep -i '\(.*error.*\)\|\(^second.*\log$\)\|\(.*FFPC\.log$\)'
Prints year-month-date format for given time </s> date -d "yesterday 13:00" '+%Y-%m-%d'
search for all the files which have not been modified in the last 6 months (180 days) in current folder and display the total disk usage of them in MB </s> find ~/tmp -type f -mtime 0 -exec du -ks {} \; | cut -f1 | awk '{total=total+$1}END{print total/1024}'
display a long list of all the jpg files in the home folder </s> find ~ -iname '*.jpg' -exec ls {} \;
Recursively removes all files with name like "*.war" in  /home/ubuntu/wars folder. </s> find /home/ubuntu/wars -type f -name "*.war" -exec rm {} \\;
List all *.txt files/directories under /etc </s> ls -l $(find /etc -name "*.txt" )
Saves invoked command 'check_script_call=$(history |tail -1|grep myscript.sh )' in variable 'check_script_call', preceeding by its number in history. </s> check_script_call=$(history |tail -1|grep myscript.sh )
create directory backup </s> mkdir backup
search for a cpp directory in current folder and display all its files </s> find . -type d -name "cpp" -exec find {} -type f \;
Print unique lines of sorted file "second.txt" compared to sorted file "first.txt" </s> comm -13 first.txt second.txt
List the largest file prefixed by its size in bytes of all files under the current directory </s> find . -type f -name '*.gz' -printf '%s %p\n'|sort -nr|head -n 1
Find all regular files whose names contain "@" in directory tree ~/$folder </s> find ~/$folder -name "*@*" -type f
Search user1's home directory tree for *.bin files </s> find /home/user1 -name \*.bin
run ksh shell as user apache </s> su apache -s /bin/ksh
Archive "./dir" to "user@host:/path" via ssh on port 2222 and display progress </s> rsync -rvz -e 'ssh -p 2222' --progress ./dir user@host:/path
Find all *.txt files under current directory that contains the regex 'pattern' and list them with their filenames and matches </s> find . -type f -name '*.txt' -exec egrep pattern {} /dev/null \;
List files larger than 10MB in the /var directory recursively </s> find /var/ -size +10M -exec ls -lh {} \;
Remove files cart4, cart5, cart6 in directory ~/junk </s> find ~/junk  -name 'cart[4-6]' -exec rm {}  \;
Delete files under $LOCATION that match $REQUIRED_FILES in their names and were modified more than 360 minutes ago </s> find $LOCATION -name $REQUIRED_FILES -type f -mmin +360 -delete
Print short DNS lookup for each domain name in a file 'list' </s> dig +short -f list
Output line number and lines 200000000 through 200000005 from the infinite input of "y" </s> yes | sed -n '200000000,${=;p};200000005q'
Disable wildcard expansion and name globbing </s> set -f
set a crontab to create or update the timestamp of "washere1" in the current directory every minute. </s> echo "* * * * * touch $(pwd)/washere1" | crontab
Invoke a trusted X11 forwarding SSH connection with server "192.168.0.14" on port 222 as user "phil" </s> ssh -v -Y phil@192.168.0.14 -p 222
Print only second from the end field from slash-separated string in file 'datafile' </s> cat datafile | rev | cut -d '/' -f 2 | rev
Unzip and merge all "small-*.gz" files into files of 2000000 lines </s> zcat small-*.gz | split -d -l2000000 -a 3 - large_
Search for aaa in all files under current directory and count the number of matches </s> find . -type f -exec grep -o aaa {} \; | wc -l
Report file system inodes usage in human readable format </s> df -ih
show all directories in the current folder excluding those that are present in the sub directories of media, images and backups </s> find . -type d \( -name media -o -name images -o -name backups \) -prune -o -print
Find all files/directories in entire file system less than 50 bytes </s> find / -size -50c
Find all files under current directory whose status was changed less than 3 days ago, sort them and show last 5 lines of output with only their paths </s> find . -type f -ctime -3 -printf "%C@ %p\n" | sort | tail -n 5 | sed 's/[^ ]* \(.*\)/\1/'
Search for lines that have zero or more whitespace characters before "http://" and number the uniquely sorted output </s> grep '^[[:space:]]*http://' | sort -u | nl
Recursively search for all files not ending in ".xml" under the current directory, append ".xml" to the end of each file name </s> find . -type f \! -name '*.xml' -print0 | xargs -0 rename 's/$/.xml/'
Search the /path/to/directory tree for regular files modified 61 days ago and then remove them </s> find /path/to/directory -type f -mtime 61 -exec rm -f {} \;
Write the current date and time followed by " 0" to the console and append to "log.csv" </s> echo $(date) "0" | tee -a log.csv
change the group of all the files in the folder /u/netinst/ to staff </s> find /u/netinst -print | xargs chgrp staff
delete all the backup files in current directory </s> find . -name "*.bak" -delete
Print "yes" 4 times followed by 1 "no" </s> yes yes | sed -e 5s/yes/no/ -e 5q
Print a unique list of characters from standard input showing backslash escapes for non-displayables </s> od -cvAnone -w1 | sort -bu
display the contents of all the files in the current folder which start with test (case insensitive search) </s> find . -iname '*test*' -exec cat {} \;
Search the files under and below /directory/containing/files for "pattern_to_search" </s> find /directory/containing/files -type f -exec grep -H 'pattern_to_search' {} +
Create compressed archive from "my_large_file_1" and "my_large_file_2" and split into files of size 1024 MiB with prefix "myfiles_split.tgz_" </s> tar cz my_large_file_1 my_large_file_2 | split -b 1024MiB - myfiles_split.tgz_
Saves byte size of all content of $1 folder in 'uiTotalSize' variable. </s> uiTotalSize=$(ls -l -R $1 | grep -v ^d | awk '{total+=$5;} END {print total;}')
Print current shell using process ID </s> ps  -ef | grep $$ | grep -v grep
Save the short host name appended with ".mysqldb" in variable "DBPREFIX" </s> DBPREFIX="$(hostname -s).mysqldb"
Find files and directories whose owner is daniel </s> find . -user daniel
search for perl files in the folder /users/tom </s> find /users/tom -name "*.pl"
Prints newline, word, and byte count for each *.py in a current folder. </s> wc *.py
Filter /path/to/logfile for any lines containing the specified date, paging interactively through the output. </s> grep 'Nov 12 2012' /path/to/logfile | less
SSH into "hostname" on port 22 as user "myName" </s> ssh -l myName -p 22 hostname
Write "Australia/Adelaide" to standard output and to "/etc/timezone" </s> echo "Australia/Adelaide" | sudo tee /etc/timezone
Join colon-separated information in 3 files LN.txt PH.txt and AD.txt in a cascade fashion: join LN.txt and PH.txt, then join the result with AD.txt </s> join -t':' <(sort LN.txt) <(sort PH.txt) | join -t':'  - <(sort AD.txt)
Print the compressed size, uncompressed size, compression ratio, and uncompressed filename of "file.zip" </s> gunzip -l file.zip
Find files owned by no group </s> find / -nogroup
Locate OGG files under the home directory larger than 100 megabytes </s> find $HOME -iname '*.ogg' -size +100M
find the file "httpd.log" in the entire file system </s> find / -type f -name httpd.log
Show the number of lines for each PHP file in the current directory tree </s> find . -type f -name "*.php" -exec wc -l {} +;
Go to directory specified by variable "somedir", but replacing leading ~ character by actual home directory. </s> cd $(echo $somedir | sed "s#^~#$HOME#")
Remove all *.log files from the current directory tree </s> find -name '*.log' -delete
Find all files/directories in entire file system for which owner has read/write/execute permissions, or the group has at least execute permission, or others have at least execute permission </s> find / -perm /711
find all the files in the current folder that have a single letter in their name which have been modified in the last 3 days but not today </s> find . -name \? -daystart -mtime +0 -mtime -3
Find all files in /dir1 and print only the filenames (not paths) </s> find /dir1 -type f -printf "%f\n"
Unzip and expand tar archive "compressFileName" </s> zcat compressFileName | tar xvf -
Find all files and directories under current directory </s> find .
Print the last 1000 lines of all files matching "/var/spool/cron/*" </s> tail -n 1000 /var/spool/cron/*
Find files/directories under current directory excluding the path ./src/emacs </s> find . -path ./src/emacs -prune -o -print
find all the regular files in the current directory which do not have a read permission </s> find -type f ! -perm -444
Prepend the reverse history number to the output of the history command with arguments "$@" </s> history "$@" | tac | nl | tac
Convert the contents of 'var1' variable to lowercase </s> var1=`echo $var1 | tr '[A-Z]' '[a-z]'`
Print "huzzah" if directory "/some/dir" is empty </s> find /some/dir/ -maxdepth 0 -empty -exec echo "huzzah" \;
display all the files in the file system excluding all the ".c" files </s> find / \! -name "*.c" -print
Print numbers from 1 to 10 with 2 values per line </s> seq 10 | sed 'N;s/\n/ /'
Search for 'foo' in all the java files under 'dir1', 'dir2' and 'dir3' directory tree and print only the names of the matched files </s> find dir1 dir2 dir3 -type f -name "*.java" -exec grep -il 'foo' {} \;
Locate all *.csv files under the current directory tree </s> find . -name "*.csv"
Find files with 777 permissions and change them to 755 </s> find / -type f -perm 0777 -print -exec chmod 755 {} \;
display all scala files in the directory "src/main" </s> find . -type f -regex ".*src/main.*\.scala$"
Unzip and extract "*\(userAgent=[^=]*\) [^ =][^ =]*=.*" from "input.gz" </s> zcat input.gz | sed -n 's/.*\(userAgent=[^=]*\) [^ =][^ =]*=.*/\1/p'
Search the current directory recursively for files last modified within the past 24 hours ignoring .swp files and paths ./es* and ./en* </s> find "$(pwd -P)" -mtime 0 -not \( -name '*.swp' -o -regex './es.*' -o -regex './en.*' \)
Display variable 'var' without leading and trailing whitespace. </s> echo $var | awk '{gsub(/^ +| +$/,"")}1'
Remove all files that were older than 3 days </s> find . -type f -mtime +3 –exec rm –f {} \;
display all the files in the current folder excluding the file states_to_csv.pl and those that are present in the directories whose name starts with ".git" </s> find . \! -path "./.git*" -a \! -name states_to_csv.pl
Change to folder where the oracle binary is. </s> cd $(dirname `which oracle`)
Search directory tree $DIR for *.txt files </s> find "$DIR" -name \*.txt
Calculate and show md5 sums for every files under current directory tree </s> find . | xargs md5sum
Copies all files like '*.txt' under the current directory to the './tmp/' directory. </s> find . -type f -name '*.txt' | sed 's/'"'"'/\'"'"'/g' | sed 's/.*/"&"/'  | xargs -I{} cp -v {} ./tmp/
removes the 4th-from to 6th-from last lines in file </s> tac filename | sed 4,6d | tac
Print common lines in "file1" and "file2" </s> comm -12 file1 file2
Find all broken symlinks under current directory </s> find . -xtype l
Move each of the 'm?' directories in $path_to_folders to another directory whose name is constituted by appending .mbox to each directory name and create a directory named Messages in this directory then move all *.emlx files into this directory </s> find "$path_to_folders" -name 'm?' -type d -exec mv {} {}.mbox \; -exec mkdir {}.mbox/Messages \; -exec sh -c "mv {}.mbox/*.emlx {}.mbox/Messages" \;
Find all regular files under current directory tree that contain 'some text' in their names excluding paths that contain dot files/directories </s> find . -not -path '*/\.*' -type f -name '*some text*'
Insert the current host name on line 15 of "test.html" </s> sed -i "15i `hostname`" test.html
Find all regular files in the "$dir" directory </s> find $dir -maxdepth 1 -type f
search for all the directories in the current directory and do not search in sub directories </s> find . -mindepth 1 -maxdepth 1 -type d
Compresses all files in a current folder (not recursively). </s> bzip2 *
List all files in the current directory tree that were last modified in March 2007 </s> find ! -newermt "apr 01 2007" -newermt "mar 01 2007" -ls
Extract any line in sorted file "A" that does not appear in "B", "C", or "D" </s> cat B C D | sort | comm -2 -3 A -
Print numbers from 1 to 30 with 0 padding to a width of 2 </s> seq -f "%02g" 30
Print symlink resolved script file name </s> echo $(basename $(readlink -nf $0))
Remove sess_* files that were modified more than 2 days ago </s> find sess_* -mtime +2 -exec rm {} \;
Counts total lines in PHP and JS files. </s> find . -name '*.js' -or -name '*.php' | xargs wc -l | grep 'total'  | awk '{ SUM += $1; print $1} END { print "Total text lines in PHP and JS",SUM }'
Search for case-insensitive "string" in "log.tar.gz" </s> zcat log.tar.gz | grep -a -i "string"
Read a line from standard input into variable "PASSWORD" </s> read PASSWORD
list in long format all files from / whose filename ends in "jbd", not descending into directories that are not readable while searching. </s> find / \! -readable -prune -o -name '*.jbd' -ls
Read a line from standard input into variable "a" without backslash escapes </s> read -r a
Find all *.ogg files on the system ignoring the case </s> find / -iname '*.ogg'
List path/filename of all PHP files under current directory whose file type description or path/name contains "CRLF" </s> find . -type f -iname "*.php"  -exec file "{}" + | grep CRLF
Search the ~ and `Music' directory trees for .mp3 files </s> find ~ Music -name '*.mp3'
Change permissions to 644 recursively for PHP files. </s> find . -type f -name '*.php' -exec chmod 644 {} \;
Print the list of files in the current directory tree excluding those whose paths contain "exclude3" or "exclude4" </s> find . | egrep -v "(exclude3|exclude4)" | sort
display all the configuration files in "/etc" folder along with their last access and modified timestamps </s> find /etc -name "*.conf" -printf "%f accessed %AF %Ar, modified %TF %Tr\n"
find all the file that have been modified in the last 3 days ( considers day starting not 24 hours ) </s> find ./ -daystart -mtime -3
find files ending with .jpg </s> find . -name '*.jpg' -print ./bar/foo.jpg
Get a list of all files in the /home directory tree and their coressponding inode numbers </s> find /home -type f -printf "%i@%p\n"
Convert "abc" to a string of hexadecimal bytes </s> echo abc | od -A n -v -t x1 | tr -d ' \n'
Delete all files in the current user's home directory and its sub-directories that have not been accessed for more than 100 days. </s> find ~ -atime +100 -delete
Print the number of 'processors' (both physical and virtual/hypethereading cores) less 1. </s> cat /proc/cpuinfo | awk '/^processor/{print $3}' | tail -1
Rename absolute path of symbolic link "dirln" to "dir2" </s> mv "$(readlink -f dirln)" dir2
Find all PHP files in the current directory recursively </s> find . -name \*.php -type f
Send 4 ping packets of size 2 to "www.google.com" on a Solaris machine </s> ping -s www.google.com 2 4
move all the html files from current folder to another folder and if a symbolic link is found copy the original referenced file and not the link </s> find . -follow -iname '*.htm' -print0 | xargs -i -0 mv '{}' ~/webhome
Search for the string 'git' in all the files under current directory tree without traversing into '.git' folder and excluding files that have 'git' in their names </s> find . -path ./.git -prune -o -not -name '*git*' -print |grep git
Set up a remote port forward from port 10022 on host "server" to port 22 on localhost </s> ssh -R 10022:localhost:22 device@server
Find and show all files on the system that are larger than 900 MB </s> find / -size +900M
search for the word "foo" in all the regular/normal files with the name "file-pattern" in the directory "/path/to/dir" </s> find /path/to/dir/ -type f -name "file-pattern" -print0 | xargs -I {} -0 grep -l "foo" "{}"
Returns exit code 1. </s> false
List files in the current directory tree which have permissions rwx for user and rw for group and others </s> find . -perm 766 -exec ls -l {} \;
Find all files with space in their names under current directory </s> find . -type f -name '* *'
Find all files that belongs to group 'root' under / directory and show a few lines of output from the beginning </s> find / -group root | head
Resolve symbolic link of file "/foo/bar/baz" </s> readlink -e /foo/bar/baz
display all directories in the folder Symfony </s> find Symfony -type d
Search the /usr/bin directory tree for regular files accessed more than 100 days ago </s> find /usr/bin -type f -atime +100
Execute `somecommand' on each file from the current directory tree with the environment variable f set to the filename </s> find . -exec env f={} somecommand \;
Find all the SGID files in the current directory tree </s> find . -perm /g+s
Save count of lines from file $file matching with pattern $filter and not matching with pattern $nfilter in variable 'totalLineCnt' </s> totalLineCnt=$(cat "$file" | grep "$filter" | grep -v "$nfilter" | wc -l | grep -o '^[0-9]\+');
force delete all the core files in the home folder </s> find $HOME -name core -exec rm -f {} \;
Find all directories under current directory and set read-write-execute permission for owner, read-execute permission for group and other for those directories </s> find . -type d -exec chmod u=rwx,g=rx,o=rx {} \;
display table of files with their name, owner, and size in bytes. </s> find . -printf 'Name: %f Owner: %u %s bytes\n'
search for php files  in current directory and search for a word in all these files </s> find -name '*.php' -exec grep -iq "fincken" {} \; -exec grep -iq "TODO" {} \; -print
A no-op on filename with sed </s> sed -i "s/\\\\\n//g" filename
Print crontabs of all users in system, skipping messages that some users don`t have crontab. </s> cat /etc/passwd | sed 's/^\([^:]*\):.*$/crontab -u \1 -l 2>\&1/' | sh | grep -v "no crontab for"
List all files under and below the directory given as variable $ARCH1 </s> find $ARCH1 -ls
Save the first line of "$j" into variable "k" in ksh </s> echo $j | read k
search for a word in all the php files in the current folder and display the matching lines. PLus at the end takes multilple files as input </s> find . -name \*.php -type f -exec grep -Hn '$test' {} \+
Make directory "temp" </s> mkdir temp
Display kernel name, release, and version. </s> uname -s -r -v
Search the current directory and all of its sub-directories for the file 'file1'. </s> find . -name file1 -print
Get A record for domain $domain </s> dig $domain
Replace all instances of "string" with "longer_string" in file "input.txt" and re-align </s> cat input.txt | sed 's/string/longer_string/g' | column -t
find files in /tmp directory that named are core and deletes them, single or double quotes, spaces or newlines are correctly handled </s> find /tmp -name core -type f -print0 | xargs -0 /bin/rm -f
Print file system disk space usage in posix and human readable format, format as a table </s> df -Ph | column -t
Find all the files/directories in the entire filesystem that do not belong to user 'wnj' and are not newer than the file/directory 'ttt' by modification time </s> find / \! \( -newer ttt -user wnj \) -print
Delete the 4th tab separated column from the output of "finger" </s> finger | awk -F"\t" -v 'OFS=\t' '{ $4=""; print $0}' | sed 's/\t\{2,\}/\t/'
Delete all files named 'sample' (case insensitive) under '/home/user/Series' directory tree with superuser privilege </s> sudo find /home/user/Series/ -iname sample -exec rm {} \;
Prefix each non-blank line in "filename" with a line number </s> nl filename
Print a line of 3 '%' characters </s> seq -s % 4|tr -d '[:digit:]'
Recursively copies 'include/gtest' to '/usr/include', preserving all attributes, and copying symlinks as symlinks, without following in source files. </s> sudo cp -a include/gtest /usr/include
Calculate the md5 sum of the sorted list of md5 sums of all ".py" files under "/path/to/dir/" </s> find /path/to/dir/ -type f -name *.py -exec md5sum {} + | awk '{print $1}' | sort | md5sum
long list al the files in the current directory which have all the permissions </s> find . -perm 777 -type f -exec ls -l {} \;
Find all regular files under current directory tree, prepend '#' at the beginning of the lines that contain 'abc' in those files and modify them in-place </s> find . -type f -exec sed -i ‘s/.*abc.*/#&/’ {} \;
search for the word "damian" in all the regular/normal files in the /etc folder and display only the matched file name </s> find /etc -type f | xargs grep -l -i "damian"
Hunting down files with at least one banana </s> find . -type f -print0| xargs -0 grep -c banana| grep -v ":0$"
Search decompressed "filename.gz" for case-insensitive "user-user" </s> zcat filename.gz | grep -i user-user
List all regular files residing in the current directory tree and containing string "/bin/ksh" </s> find . -type f -print | xargs grep -li 'bin/ksh'
Print the file sizes along with their paths for all *.txt (case insensitive) files/directories under current directory tree </s> find . -iname "*.txt" -exec du -b {} +
Split "file.tar.gz" into files of size 1024 MB </s> split -b 1024m file.tar.gz
Find all files named `file1' on the system </s> find / -name file1
delete all the files in the current folder which have been modified in the last 14*24 hours </s> find . -mtime -14 -print|xargs -i rm \;
Delimit standard input with ":" and display as a table </s> column -s: -t
Searches through the htdocs and cgi-bin directories for files that end with the extension .cgi. When these files are found, their permission is changed to mode 755 (rwxr-xr-x). </s> find htdocs cgi-bin -name "*.cgi" -type f -exec chmod 755 {} \;
Run commands "df -k;uname -a" on server "192.168.79.134" </s> echo "df -k;uname -a" | ssh 192.168.79.134
Compare files in "/tmp/dir1" and "/tmp/dir2", treating absent files as empty and all files as text </s> diff -Nar /tmp/dir1 /tmp/dir2/
Search the current directory tree for .log files containing the string "The SAS System" on the first line </s> find . -name '*.log'  -type f  -readable  ! -size 0 -exec sed -n '1{/The SAS System/q0};q1' {} \; -print
Print the names and sizes of regular files residing in the "tmp" directory tree </s> find tmp -type f -printf "%s %p\n" | awk '{sub(/^[^ ]+/,sprintf("f %10d",$1))}1'
Move all regular files under current directory to ./newdir </s> find ./ -type f -print | xargs    -l56 -I {} mv -f {} ./newdir
List all your files including everything in sub-directories </s> find ~
Find all files/directories named 'top' in the entire filesystem </s> find / -name top
Find all files with name "file.ext" under the current working directory tree and print each full path directory name </s> find `pwd` -name file.ext |xargs -l1 dirname
Recursively copies 'SRCFOLDER' to the 'DESTFOLDER/' </s> cp -R SRCFOLDER DESTFOLDER/
Recursively copy directory "/path/to/data/myappdata" to "user@host:/remote/path/to/data/newdirname" </s> rsync -rvv --recursive /path/to/data/myappdata user@host:/remote/path/to/data/newdirname
Copy all ".php" files in "projects/" directory tree to "copy/" preserving directory hierarchy </s> find projects/ -name '*.php' -print | cpio -pdm copy/
Find all HTML files starting with letter 'a' in the current directory and below ignoring the case </s> find . -iname a\*.html
Read 10 bytes from $0 and print them by replacing the set '\000-\377' with '#' </s> head -c 10 "$0" | tr '\000-\377' '#'
display all text files in current folder </s> find . -name ".txt"
delete all the normal files in the current folder and do not delete those in the subfolders </s> find . -maxdepth 1 -type f -delete
Find all regular files under current directory tree without descending into './dir1' (except './dir1/subdir1*' pattern) and './dir2' directories </s> find . \( -path './dir1/*' -and -not -path './dir1/subdir1*' -or -path './dir2' \) -prune -or -type f -print
Fix files to default permissions 644 </s> find . -type f -exec chmod 644 {} \;
display the version of find </s> find --version
find for a word in all the regular files in the current directory </s> find . -type f -print | xargs grep -li 'bin/ksh'
find a.out, *.o and core files under the current directory and sub-directories and delete them. </s> find . \( -name a.out -o -name '*.o' -o -name 'core' \) -exec rm {} \;
search for files in the current folder ending with ".au" </s> find -type f -name '*.au'
View history using "vim" in read only mode </s> history | vim -R -
display all the text files in the current folder except readme files </s> find . -type f -name "*.txt" ! -name README.txt -print
Replace all newlines with spaces in standard input </s> sed -z 's/\n/ /'g
find all the files in the file system which have been modified in the last 10 minutes </s> find / -mmin -10
delete all the trace files (".trc") which have not been been accessed in the last 30*24 hours </s> find /dirpath \( -name \*.trc -a -mtime +30 \) -exec rm {} \;
find all files in the folder /path/to/dir which have been modified between two dates </s> find /path/to/dir -newermt yyyy-mm-dd ! -newermt yyyy-mm-dd -ls
display all the files in the current folder which have been modified in one hour ago </s> find .  -newermt "1 hour ago"
Find all symbolic links under '/some/directory' driectory tree </s> find /some/directory -type l -print
display all the files on the current folder excluding those that are present in the folder "./src/emacs" </s> find . -path ./src/emacs -prune -o -print
find foo, Foo, FOo, FOO, etc., but only dirs </s> find . -iname foo -type d
find files in current folder using name patterns and sort the display the file names in the sorted order </s> find . -name "S1A*1S*SAFE" | awk -F/ '{print $NF"/"$0}' | sort -t_ -k 5,5 | cut -d/ -f 2-
simulate a full login of user builder </s> su -l builder
Perform case insensitive search for *.gif files/directories under downloads directory </s> find downloads  -iname "*.gif"
Search for "Stock" in all *.java files from the current directory tree </s> find . -name "*.java" | xargs grep "Stock"
Get only the latest version of the file 'filename' under current directory </s> find . -name 'filename' | xargs -r ls -tc | head -n1
Print the size for every *.ogg file found under the home directory </s> find $HOME -name '*.ogg' -type f -exec du -h '{}' \;
List executable files in the current directory, sort the list and then display the differences between the list and file .gitignore. </s> find . -perm /111 -type f | sed 's#^./##' | sort | diff -u .gitignore -
Find command will list of all files & directories from current directory , before listing echo command will display ' List of files & Directory ' </s> find . -exec echo ' List of files & Direcoty'   {} \;
Print 'This should print the filename twice if an implicit -print is applied: ' appended with file paths for all files named 'file' under current directory tree </s> find -name file -exec echo 'This should print the filename twice if an implicit -print is applied: ' {} +
Exclude directory from find . command </s> find . -path ./misc -prune -o -name '*.txt' -print
Change the owner of all files in the directory tree "dir_to_start" excluding directory "dir_to_exclude" to "owner" </s> find dir_to_start -name dir_to_exclude -prune -o -print0 | xargs -0 chown owner
find all jpg,png,jpeg,pdf,tif,tiff,bmp and other image formats using regular expressions excluding those ending with "_ocr.pdf" </s> find /somepath -type f -iregex ".*\.(pdf\|tif\|tiff\|png\|jpg\|jpeg\|bmp\|pcx\|dcx)" ! -name "*_ocr.pdf" -print0
Find all *gz files under asia and emea directory </s> find asia emea -type f -name "*gz"
Calculate the md5 sum of the contents of all files sorted in directory tree "/path" </s> find /path -type f | sort -u | xargs cat | md5sum
Set the exit code($?) to '0'. </s> true
Unzip "daily_backup.sql.gz" and search for lines matching "'x'|/x/" </s> zcat daily_backup.sql.gz| grep -E "'x'|/x/"
Eliminates partially duplicate lines by column, keeping the last occurrence </s> tac temp.txt | sort -k2,2 -r -u
Find all directories under current directory and set read-write-execute permission for owner and group and no permission for other for those directories </s> find . -type d -exec chmod ug=rwx,o= {} \;
Finds IP addresses of all network interfaces. </s> ifconfig | grep -v '127.0.0.1' | sed -n 's/.*inet addr:\([0-9.]\+\)\s.*/\1/p'
Print sed commands that would replace all occurrences of 'previousword' with 'newword' in all regular files with '.cpp' extension under '/myprojects' directory tree </s> find /myprojects -type f -name '*.cpp' -print0 |    xargs -0 echo sed -i 's/previousword/newword/g'
find in the entire file system for the files which have sticky bit. </s> find / -perm 0551
find the regular/normal file "myfile" in the folder /root </s> find /root/ -name myfile -type f
Append *.java files from the current directory tree to tar archive `myfile.tar' </s> find . -type f -name "*.java" | xargs tar rvf myfile.tar
Format the time string $timestamp according to the format string "%Y-%m-%d %H:%M:%S" and save the output to variable 'CDATE' </s> CDATE=$( date -d @"$timestamp" +"%Y-%m-%d %H:%M:%S" )
Find files/directories under current directory and print them as null terminated strings. </s> find -print0
Find all regular files in the current director and set their permissions to '644'. </s> find ./ -type f -exec chmod 644 {} \;
find all directories that names are 'apt' and display details </s> find  / -type d -name "apt" -ls
Merge data in file1 and file2 where second field is common in both files </s> join -j2 <(sort -k2 file1) <(sort -k2 file2)
View the contents of "file.txt" with line numbers in the pager "less" </s> cat -n file.txt | less
Remove all .txt files in and below the current directory </s> find . -name "*.txt" | xargs rm
Print a count of all unique lines in "ports.txt" sorted from most frequent to least frequent </s> sort ports.txt | uniq -c | sort -r
Count line numbers on files and record each count along with individual file name. </s> find /home/my_dir -name '*.txt' | xargs grep -c ^.*
Find all files called "INPUT.txt" in the current directory tree and remove lines starting with # in them, saving backup copies as INPUT.txt.bak </s> find . -type f -name INPUT.txt -print0 | xargs -0 sed -i.bak '/^#/d'
Find a directory named 'project.images' in the entire filesystem and show it in long listing format </s> find  / -type d -name "project.images" -ls
find all the files in the current directory which have been modified after a file </s> find . -newer file
Print the last space separated word from "a b c d e" </s> echo "a b c d e" | tr ' ' '\n' | tail -1
Search the current directory recursively for files containing "string" </s> find . -type f -exec grep -l 'string' {} \;
Report file systems disk usage in 1GB blocks. </s> df -BG
Print numbered list of all third-level files under the current directory </s> ls -d -1 $PWD/**/*/* | cat -n
find all regular/normal files in the current folder whose name has the word photo or picture and which have been modified in the last 30 minutes </s> find . \( -iname "*photo*" -or -name "*picture*" \) -and ! -type d -and -mmin -30
List all .jpg files in the home directory tree </s> find . -name "*.jpg" -print0 | xargs -0 ls
search for MP3 files in the current folder and subfolders except in dir1 subfolder. </s> find ! -path "dir1" -iname "*.mp3"
Print the most repeated line in "list2.txt" that exists in "list1.txt" prefixed by the number of occurrences </s> grep -Ff list1.txt list2.txt | sort | uniq -c | sort -n | tail -n1
Find all directories with permissions 777 under and below /var/www/html, and change their permissions to 755 </s> find /var/www/html -type d -perm 777 -print -exec chmod 755 {} \;
Find recursively all files changed within the last 5 minutes starting from directory b </s> find b -cmin -5
Find files/directories under '/dir' directory tree that are newer than 'yesterday.ref' file and older than 'today.ref' file by modification time </s> find /dir -newer yesterday.ref -a \! -newer today.ref -print
Find all files in the current directory tree with extension .html and replace all occurences of "php" with "html" inside them </s> find ./ -type f -name *".html" | xargs sed -i "s/php/html/g"
Extract data from HTML table in "mycode.html" </s> paste -d: <(grep '<th>' mycode.html | sed -e 's,</*th>,,g') <(grep '<td>' mycode.html | sed -e 's,</*td>,,g')
Archive the list of 1st level subdirectories in /fss/fin to /fss/fi/outfile.tar.gz </s> tar -czf /fss/fi/outfile.tar.gz `find /fss/fin -d 1 -type d -name "*" -print`
find all the files in the current directory and display them </s> find . -exec echo {} ;
Find all *.old files and move them to directory oldfiles </s> find . -name "*.old" -exec mv {} oldfiles \;
Change the owner of "process" to "root" </s> sudo chown root process
Copy all files in the current directory except those containing 'Music' to '/target_directory'. </s> cp `ls | grep -v Music` /target_directory
Numerically sort each line in file "bb" and output the result to console from greatest value to least value </s> sort -nr bb
find all files in the current folder that have a single letter in their name and have not been modified today </s> find . -name \? -mtime +0
Search for the files/directories that were modified more than an hour ago </s> find . -mtime +1
list all CSS files (and directories ending with “.css”) under the current directory </s> find . -name "*.css"
Copies files 'src/prog.js' and 'images/icon.jpg' with fully-defined path to '/tmp/package' directory. </s> cp --parents src/prog.js images/icon.jpg /tmp/package
display all the files  in the current folder which have colon in their name </s> find . -name "*:*"
Find all files/directories under /var/log directory </s> find /var/log
Look for `regexp' in binary files </s> find .  -type f -print|xargs file|grep -i text|cut -fl -d:    | xargs grep regexp
Remove all files and directories in the /home directory tree whose names are "Trash" </s> find /home -name Trash -exec rm {} \;
Print which files differ in "folder1" and "folder2" excluding "node_modules" recursively, output in two columns, and paginate the output </s> diff -rqyl folder1 folder2 --exclude=node_modules
list all the sqlite files in the current folder </s> find ./ -name "*.sqlite" -ls
update the permission of all the php files in current directory and save the output to a file </s> find . -name '*.php' -exec chmod 755 {} \; | tee logfile.txt
Split the output of "ls" into files of at most 500 lines each with prefix "outputXYZ." </s> ls | split -l 500 - outputXYZ.
Print reverse lookup for IP address 72.51.34.34 </s> dig -x 72.51.34.34
Find all the files called FindCommandExamples.txt of owner root </s> find / -user root -name FindCommandExamples.txt
Archive "/my/dir" on host "server" as user "user" to the current local directory excluding files ending in ".svn" </s> rsync -av --exclude '*.svn' user@server:/my/dir .
Connect to "$USER_AT_HOST" using connection sharing on "$SSHSOCKET" and request the master to exit </s> ssh -S "$SSHSOCKET" -O exit "$USER_AT_HOST"
Removes all empty folders under current path, aged between 'first' and 'last' timestamps. </s> find . -newer first -not -newer last -type d -print0 |  xargs -0 rmdir
Write "\n/usr/local/boost_1_54_0/stage/lib" to standard output and append to "/etc/ld.so.conf" </s> echo -e "\n/usr/local/boost_1_54_0/stage/lib" | sudo tee -a /etc/ld.so.conf
Remove Mac OS X Desktop Services Store files </s> find . -name ".DS_Store" -exec rm {} \;
Remove all directories called "test" from the current directory tree </s> find . -name test -type d -exec rm -r {} +
Prints day of first Tuesday in a month. </s> cal | awk 'NR>2{Sfields=7-NF; if (Sfields == 0 ) {printf "%02d\n",$3;exit}}'
find all files ending with "js.compiled" in current folder (print0 is used to handle files with newlines in their names) </s> find ./js/ -name "*.js.compiled" -print0
list files in /usr modified after the time which /tmp/stamp$$ modified </s> find /usr -newer /tmp/stamp$$
Print IP addresses of the host name </s> hostname -I | cut -d' ' -f1
Find all files/directories under current directory tree excluding hidden files/directories </s> find . -not -path '*/\.*'
Find all files/directories under current directory that were accessed less than 1 day ago </s> find . -atime -1 -print
Find all files and directories under current directory without crossing over to other partitions </s> find . -xdev -print0
Find directories modified within the last 7 days </s> find . -mtime -7 -type d
Calculate the md5 sum of "a" </s> echo "a" | md5sum
Search for 'Processed Files' in all $srch* (case insensitive) files under current directory run the sed script 'N;s/(.*)\n(.*)/\2 \1/' on the output </s> find . -iname "$srch*" -exec grep "Processed Files" {} \; -print| sed -r 'N;s/(.*)\n(.*)/\2 \1/'
Recursively compresses all files within $2 folder. </s> find $2 -type f -exec bzip2 {} \;
Execute 'echo -e "\033[31mHello World\033[0m"' every without color support 2 seconds </s> watch 'echo -e "\033[31mHello World\033[0m"'
Recursively change owner to "$1" and group to "httpd" of all files in the current directory </s> chown -R $1:httpd *
Prints directory where the executing script ($0) is located. </s> `dirname $0`
Find all *.txt, *.html files under /basedir that match the case insensitive pattern *company* in their names </s> find /basedir/ \( -iname '*company*' -and \( -iname '*.txt' -or -iname '*.html' \) \) -print0
find all the log files in the file system which are present in the current partition </s> find / -xdev -name "*.log"
Count files in the current path by modification month </s> find . -maxdepth 1 -type f -printf '%TY-%Tm\n' | sort | uniq -c
Find all regular *.css files </s> find . -type f -name "*.css"
set variable r to currently running kernel release, ie. 4.4.0-81-generic </s> r="$(uname -r)"
Print lines 10000 to 10010 from input "seq 1 100000" </s> seq 1 100000 | sed -n '10000,10010p'
Find all files in maximum 1 level down the current directory that were modified less than 1 day ago from today </s> find -maxdepth 1 -type f -daystart -mtime -1
Print short TXT record of domain o-o.myaddr.l.google.com from nameserver ns1.google.com </s> dig TXT +short o-o.myaddr.l.google.com @ns1.google.com
Gunzip all files matching "file*.gz" and answer "n" to any prompts </s> yes n | gunzip file*.gz
Count the number of regular files in the current directory that contain a vowel in their names </s> find . -maxdepth 1 -type f -iname '*[aeiouy]*' -printf ".\n" | wc -l
display all the files in the file system which belong to the group lighttpd </s> find / -group lighttpd -print
Replace all occurrences of word "foo" with "bar" in *.c and *.h files from the current directory tree </s> find -name '*.[ch]' -exec sed -i 's/\<foo\>/bar/g' {} +
List all files/directories under current directory using comma (,) as the delimiter for different fields in the output </s> find . -ls|awk 'BEGIN{OFS=","}$1=$1'
Print the line number of each matching "<phrase>" in "<filename>" </s> nl -b a "<filename>" | grep "<phrase>" | awk '{ print $1 }'
Generate the obsolete 29 character Spanish alphabet and number each character </s> echo -e {{a..c},ch,{d..l},ll,{m,n},ñ,{o..z}}"\n" | nl
Make directory and parents as needed to "$FINALPATH" </s> mkdir -p "$FINALPATH"
find md5sum of 401 </s> yosemite$ echo -n 401 | md5
Remove newline characters from "file.txt" </s> paste -sd "" file.txt
Find all regular files under /home/www and replace every occurrences of 'subdomainA.example.com' with 'subdomainB.example.com' in those files </s> find /home/www -type f -print0 | xargs -0 sed -i 's/subdomainA\.example\.com/subdomainB.example.com/g'
Find the top 25 files according to their size in the current directory and its subdirectories </s> find . -type f -exec ls -al {} \; | sort -nr -k5 | head -n 25
Prints groups list that current user belongs to. </s> groups                                        //take a look at the groups and see
Create new crontab set for user 'test' including $job and only jobs from current crontab of 'test' user that don`t contain $command </s> cat <(fgrep -i -v "$command" <(crontab -u test -l)) <(echo "$job") | crontab -u test -
Remove all files under $DIR that were accessed more than 5 days ago </s> find "$DIR" -type f -atime +5 -exec rm {} \;
Find all *.py files/directories under current directory </s> find . -name *.py
Copies file 'fileName.txt' to each of directories listed in the 'allFolders.txt' list. </s> cat allFolders.txt | xargs -n 1 cp fileName.txt
Search the current directory tree for files whose name is ".note", case insensitive </s> find . -iname '.note' | sort
Count the number of lines in "/dir/file.txt" </s> cat /dir/file.txt | wc -l
Extract files from archive 'archive.tar' </s> cat archive.tar | tar x
Recursively change the owner of all files in "/home/test" to "test" </s> sudo chown -R test /home/test
Change the group of all directories (except those with a '.') under current directory tree to a group with the same name as the directory name </s> find . -type d | sed -e 's/\.\///g' -e 's/\./avoid/g' | grep -v avoid | awk '{print $1"\t"$1}' | xargs chgrp
search for the file "filename" in the entire file system </s> find / -name filename
Find all .gif and .jpg files in the /var/www directory tree </s> find /var/www -name *.gif -o -name *.jpg
Find files/directories that have no owner or group under /path </s> find /path -nouser -or -nogroup
Gets IP address of 'en0' selected network interface. </s> ifconfig en0 | awk '/inet addr/ {gsub("addr:", "", $2); print $2}'
find the biggest files only (but not directories) </s> find . -type f -exec du -Sh {} + | sort -rh | head -n 15
Find all hidden regular files starting from the current directory </s> find . -type f -name ".*"
Find all files that belong to group root </s> find / -group root
Find files/directories under current directory and print them </s> find . -print0 | xargs    -0 echo
Find files that are orphaned </s> find -nouser
find directory which case-insensitive name is foo in current directory. </s> find . -iname foo -type d
Find all the files whose permissions are 777 </s> find . -type f -perm 0777 -print
Returns exit status 0. </s> foo=$(false)$(true)
Compress in parallel regular files in the current directory tree that were last modified more than 7 days ago </s> find . -type f  -mtime +7 | tee compressedP.list | xargs -I{} -P10 compress {} &
Save a comma separated list of all $MY_DIRECTORY/*/ directories to variable 'FOLDER' </s> FOLDERS=`ls -dm $MY_DIRECTORY/*/ | tr -d ' '`
delete all the text files starting with the name "oldStuff" in the file system </s> find / -name "oldStuff*.txt" -delete
Creates path as current folder path and folder that contains $0 file, and saves result in 'script_dir' variable. </s> set script_dir = `pwd`/`dirname $0`
Print all files/directories under ... directory by terminating their paths with a null character </s> find ... -print0
Archive showing progress all files in "/media/2TB\ Data/data/music/" to "/media/wd/network_sync/music/" excluding files matching "*.VOB", "*.avi", "*.mkv", "*.ts", "*.mpg", "*.iso", "*ar", "*.vob", "*.BUP", "*.cdi", "*.ISO", "*.shn", "*.MPG", "*.AVI", "*.DAT", "*.img", "*.nrg", "*.cdr", "*.bin", "*.MOV", "*.goutputs*", "*.flv", "*.mov", "*.m2ts", "*.cdg", "*.IFO", "*.asf", and "*.ite" </s> rsync -av --progress --exclude=*.VOB --exclude=*.avi --exclude=*.mkv --exclude=*.ts --exclude=*.mpg --exclude=*.iso --exclude=*ar --exclude=*.vob --exclude=*.BUP --exclude=*.cdi --exclude=*.ISO --exclude=*.shn --exclude=*.MPG --exclude=*.AVI --exclude=*.DAT --exclude=*.img --exclude=*.nrg --exclude=*.cdr --exclude=*.bin --exclude=*.MOV --exclude=*.goutputs* --exclude=*.flv --exclude=*.mov --exclude=*.m2ts --exclude=*.cdg --exclude=*.IFO --exclude=*.asf --exclude=*.ite /media/2TB\ Data/data/music/* /media/wd/network_sync/music/
Find all files with '.txt' (case insensitive) extension under $dir directory non-recursively and sort them numerically </s> find "$dir" -maxdepth 1 -type f -iname '*.txt' | sort -n
Create a symbolic link named "~/bin/subl" to "/Applications/Sublime Text.app/Contents/SharedSupport/bin/subl" </s> ln -s "/Applications/Sublime Text.app/Contents/SharedSupport/bin/subl" ~/bin/subl
Find all TXT files on the system and copy them to /tmp/txt </s> find / -iname '*.txt' | xargs --replace=@ cp @ /tmp/txt
List the full path of each directory in the current working directory </s> tree -dfi -L 1 "$(pwd)"
Find suspicious PHP files </s> find . -type f -name "*.php" -exec grep --with-filename "eval(\|exec(\|base64_decode(" {} \;
Print a top 20 histogram of characters used from standard input showing backslash escapes for non-displayables </s> od -cvAnone -w1 | sort -b | uniq -c | sort -rn | head -n 20
change the permissions of all the regular/normal files to 664 in the current folder </s> find . -type f -exec chmod 664 {} \;
For each line which has a common first field in file1.csv and file2.txt, output the first 4 fields of file1.csv - both files must be sorted first. </s> join -o 1.1,1.2,1.3,1.4 -t, file1.csv file2.txt
Delete all files/directories under current directory tree excluding '.gitignore' files/directories and files/directories matching the patterns '.git' or '.git/*' in their paths </s> find . ! -name '.gitignore' ! -path '.git' ! -path '.git/*' -exec rm -rf {} \;
Find all files under /path and calculate their md5sum </s> find /path -type f -print0 | xargs -0 md5sum
Print received input to the terminal </s> tee
find all the perl files in the current folder </s> find . -type f -name "*.pl"
Find "*prefs copy" files in the /mnt/zip directory tree and remove them with prompting </s> find /mnt/zip -name "*prefs copy" -print0 | xargs -p rm
find all files in the file system with the permissions 777 and having the word "filename" in their name. </s> find / -perm 777 -iname "filename"
List environment variables whose name matches ".*X.*" </s> set | awk -F "=" '{print $1}' | grep ".*X.*"
search for all the text files in the folder /foo and delete them </s> find /foo/ -name "*.txt" -exec rm -v {} \;
Recursively copy directories "A" and "D" to directory "/path/to/target/directory" on host "anotherhost", connecting as ssh user matching current user on local host, via default TCP port for ssh (22). </s> scp -r A D anotherhost:/path/to/target/directory
Delete interactively all the files/directories with inode number 782263 under current directory tree </s> find . -inum 782263 -exec rm -i {} \;
Find all sample*_1.txt files/directories under current directory </s> find . -name "sample*_1.txt"
Run command 'su whoami' on host 'remotehost' </s> echo "su whoami" |ssh remotehost
Recursively search current directory for all files with name ending with ".t1", change this to .t2 </s> find . -name "*.t1" -exec rename 's/\.t1$/.t2/' '{}' \;
Remount "/" with read and write permission </s> mount / -o remount,rw
Remove the "^M" characters from all *.ext files under /home directory </s> find /home -type f -name "*.ext" -exec sed -i -e "s/\x0D$//g" {} \;
show the disk use of all the regular/normal files in the current folder which are bigger than 50MB </s> find . -type f -size +50000k | xargs du -sh
Replace the occurrences of "HOGE" with "MOGA" once per each line of the files from the current directory tree, keeping a backup copy of every touched file </s> find . -type f -print0 | xargs -0 sed -i.bak -e "s/HOGE/MOGA/"
Print second section of space-separated data coming from stdin. </s> cut -d\  -f 2
change the ownership of all regular/normal files in the current directory after users confirmation </s> find . -type f -ok chown username {} \;
Removes all empty folders under current folder. </s> find . -type d -exec rmdir {}\;
Finds if environment variable like 'DUALCASE' exists in environment. </s> env | grep DUALCASE
Display a character dump of "oldfile" </s> od -c oldfile
List files under $CURR_DIR which were modified, accessed or whose status were changed $FTIME ago replacing the $CURR_DIR path string to './' </s> find ${CURR_DIR} -type f \( -ctime ${FTIME} -o -atime ${FTIME} -o -mtime ${FTIME} \) -printf "./%P\n"
find all directories with the name test in a directory </s> find /home/john -type d -name test -print
Create a compressed archive from "www" and split the contents into files of at most 1073741824 bytes and use prefix "www-backup.tar." </s> tar czf - www|split -b 1073741824 - www-backup.tar.
Display differences between /destination/dir/1 and /destination/dir/2 excluding files with names ending with extensions '.foo', '.bar' and '.baz' </s> diff -x '*.foo' -x '*.bar' -x '*.baz' /destination/dir/1 /destination/dir/2
Print standard input to standard output line by line, discarding any adjascent duplicate lines. </s> uniq
find all the files in the current folder which have been modified in the 10 minutes ago </s> find -mmin +15 -mmin -25
Find all files/directories with 777 permission under current directory tree </s> find . -perm 777 -print
Strips two last sections from the path $pathname, and prints basename of the rest part. </s> echo $(basename $(dirname $(dirname $pathname)))
Removes 'foo' file. </s> rm foo
Give all files in the /path/to/base/dir tree read privileges </s> find /path/to/base/dir -type f -print0 | xargs -0 chmod 644
Create a directory named 'alpha_real' in the current directory </s> mkdir alpha_real
Search the files from directory tree "dirname" for string "foo" </s> find dirname -exec grep foo {} +
Count the number of total files and folders under current directory tree </s> find . -print0 | tr -cd '\0' | wc -c
Recursively lists all files in a current folder in long format. </s> ls -ld $(find .)
Find files accessed at 23:59 </s> find . -atime -1 -print
Find all *.txt file and replace old word to new word with sed command </s> find  . -type f -name "*.txt" -exec sed 's/TZ/MALAWI/g' {} \;
Print the names and sizes of regular files residing in the "dir" directory tree </s> find dir -type f -printf "f %s %p\n"
Print lines 2960 to 2966 from the output of "history" </s> history | sed -n '2960,2966p'
Print every 3 characters of standard input as a line </s> fold -w3
force remove all the c files in the current folder, print0 is used to handle all files with new lines in their names or files with only spaces in their name </s> find . -name "*.c" -print0 | xargs -0 rm -rf
Find all the files whose name is tecmint.txt and contains both capital and small letters in /home directory </s> find /home -iname tecmint.txt
Print out the full path name of "mypathname" with dots resolved </s> readlink -ev mypathname
display all text files in the folder /tmp/1 excluding those which do not have spaces in their names </s> find /tmp/1 -iname '*.txt' -not -iname '[0-9A-Za-z]*.txt'
Split the first 100 lines of "datafile" into files with at most 1700 bytes each preserving lines </s> sed 100q datafile | split -C 1700 -
find all the files in the current folder that have been modified in the last 7 days </s> find -mtime -7 -daystart
Find all the files which are modified 50 days back </s> find / -mtime 50
search for pattern matched files in the current folder and subfolders exclude "excluded path" </s> find ./ -type f -name "pattern" ! -path "excluded path" ! -path "excluded path"
Find all files/directories under '/etc' directory tree that are greater than 5MB and print their sizes and names </s> find /etc -size +5M -exec ls -sh {} +
Find files/directories in entire file system that have been modified in the last minute </s> find / -mmin -1
Convert relative path "/x/y/../../a/b/z/../c/d" into absolute path with resolved symbolic links </s> readlink -f /x/y/../../a/b/z/../c/d
Recursively add ".jpg" to all files without an extension in the directory tree "/path" </s> find /path -type f -not -name "*.*" -exec mv "{}" "{}".jpg \;
Set the 'verbose' shell option causing bash to print shell input lines as they are read </s> set -o verbose
Display the current directory tree except files or directories starting with "3rd" </s> tree -I '3rd*'
Replace the "openssl" command executable with a symbolic link to "/usr/local/ssl/bin/openssl" </s> sudo ln -sf /usr/local/ssl/bin/openssl `which openssl`
Find all files named "something" in the current folder and below and run them through the ls -l command in a one batch. </s> find . -name something | xargs -0 ls
Remove all files under /myfiles that were accessed more than 30 days ago </s> find /myfiles -atime +30 -exec rm {} \;
find all the regular/normal files in the /path folder and delete them </s> find /path -type f -exec rm '{}' \;
Recursively copy "dir_b" to "dir_a" and delete any new files in "dir_a" </s> rsync -u -r --delete dir_b dir_a
find all the normal/regular files in the folder "pathfolder" which are 2 levels deep, excluding all hidden files and display the count </s> find pathfolder -mindepth 2 -maxdepth 2 -type f -not -path '*/\.*' | wc -l
search for all pdf files in the folder "/home/pdf" which have been accessed in the last 60*24 hours </s> find /home/you -iname "*.pdf" -atime -60 -type -f
find all files in the current folder which have not been accessed in the last 7 days or which are bigger than 20KB </s> find . -atime +7 -o -size +20480 -print
Move all lines starting with "Ca" to the beginning of the file </s> nl -n rz ca | awk -vOFS="\t" '/Ca/{$1="#"$2} {$1=$1}1' | sort -k1,1 | cut -f2-
display all the java, xml and action scripts (.as) files in a directory </s> find dir1 -type f -a \( -name "*.java" -o -name "*.as" -o -name "*.xml" \)
Find all Makefile's in the current directory tree </s> find -type f -name "Makefile"
list the files with a name ending with '.mp3' or '.jpg' and beginning with 'foo' </s> find . \( -name '*.mp3' -o -name '*.jpg' \) -name 'foo*' -print
Find all the SGID bit files whose permissions set to 644 in the file system </s> find / -perm 2644
search for the word "mysql" in all the files in the current containing the word "notes" in their name </s> find . -iname "*notes*" | xargs grep -i mysql
Look for *.jpg files </s> find . -name “*.jpg”
Adjust the timestamp of file $filename by subtracting 2 hours from it </s> touch -d "$(date -r "$filename") - 2 hours" "$filename"
List each unique case insensitive character in "file" prefixed by number of occurrences and sorted from most frequent to least frequent </s> grep -o . filename | tr '[:upper:]' '[:lower:]' | sort | uniq -c | sort -nr
Find all $2 files in $1 path and search for the regex expanded by $3 in those files </s> find $1 -name "$2" -exec grep -Hn "$3" {} \;
Remove all regular files with extensions php, css, ini, txt from directory tree /old/WordPress/ </s> find /old/WordPress/ -type f -regex ".*\.\(php\|css\|ini\|txt\)" -exec rm {} \;
Add the execute and read permission for all and the write permission for the user to the dir_data directory and all of its sub-directories. </s> find ~/dir_data -type d -exec chmod a+xr,u+w {} \;
prevents curl from returning error (23) Failed writing body when grepping for foo </s> curl "url" | tac | tac | grep -qs foo
Search the current directory tree for files containing "sh" in their names </s> find . -name "*sh*"
Print your/dir if it's empty </s> find your/dir -prune -empty
List all regular files in /var/www and below that have changed in the last 10 minutes </s> find /var/www -cmin -10 -type f -printf "%c %pn"
Search /some/directory for files that are owned by the user "joebob" </s> find /some/directory -user joebob -print
Copy "/Users/username/path/on/machine/" to "username@server.ip.address.here:/home/username/path/on/server/" and convert encoding from UTF-8-MAC to UTF-8 </s> rsync --iconv=UTF-8-MAC,UTF-8 /Users/username/path/on/machine/ 'username@server.ip.address.here:/home/username/path/on/server/'
Search for files "file1" or "file9" </s> find . -name file1 -or -name file9
Read a line from standard input into the first argument ("$1") using an interactive shell with prompt "> " </s> read -e -p '> ' $1
Archive "/path/to/application.ini" on host "source_host" to current directory. </s> rsync -avv source_host:path/to/application.ini ./application.ini
Create the directory '.npm-packages' in the user's home directory($HOME) </s> mkdir "${HOME}/.npm-packages"
Display the mount point of a device file "$path" </s> mount | grep "^$path" | awk '{print $3}'
find all files in the current folder which have not been changed in the last 48 hours </s> find ./ -daystart -ctime +2
Search the home directory tree for files last modified more than a year ago </s> find $HOME -mtime +365
change owner and group of the file script.sh to user root </s> chown root:root script.sh
List all files in the current directory tree that were last modified yesterday or later </s> find -newermt yesterday -ls
List all aliencoders.[0-9]+ files/directories under /home/jassi/ directory </s> find /home/jassi/ -name "aliencoders.[0-9]+" | xargs -r ls -lrt | awk '{print $9}'
Print the user name of the user running sudo </s> who -m | awk '{print $1}'
Find all files/directories under '/var/log' directory tree that bave been modified today (from the start of the day) </s> find /var/log -daystart -mtime 0
Search for files that are at least 100MB </s> find / -size +100M
Read a line from standard input into the variable "yn" with the prompt "Do you wish to install this program?" </s> read -p "Do you wish to install this program?" yn
Print A record for domain 'domain.' from 'some.other.ip.address' nameserver </s> dig @some.other.ip.address domain. a
Search the current directory tree for executable regular files </s> find . -executable -type f
Overwirte file '/path/to/your/file' with random content, showing progress while execution. </s> shred -v -n 1 /path/to/your/file #overwriting with random data
remove all the permissions for others to all the files in the current folder which have  read,write,execute access to users,group and others. </s> find * -perm 777 -exec chmod 770 {} \;
Find all empty regular files in the current directory and below </s> find . -type f -empty
search for all text files in the folder /home </s> find /home -name *.txt
find all files in the current folder that are modified exactly 1 minute ago </s> find -mmin 1 -print
print all lines after the last match of 'string match' </s> tac infile | sed '/string match/,$d' | tac
Exit the shell on the first error encountered </s> set -o errexit
display all the files in the current folder which have the permissions 777 and which have been modified in the last 24 hours. </s> find . -perm 777 -a -mtime 0 -a -print
find  files which  full path name is /tmp/foo/bar under foo directory and print </s> find foo -path /tmp/foo/bar -print
Prints day of first Tuesday in a month. </s> cal | awk 'NR==2 {for (i=1;i<=NF;i++) {sub(/ /,"",$i);a[$i]=i}} NR>2 {if ($a["Tu"]~/[0-9]/) {printf "%02d\n",$a["Tu"];exit}}' FIELDWIDTHS="3 3 3 3 3 3 3 3"
find all files under the /etc directory and display IP address patterns in them </s> find /etc -type f -exec cat '{}' \; | tr -c '.[:digit:]' '\n' \ | grep '^[^.][^.]*\.[^.][^.]*\.[^.][^.]*\.[^.][^.]*$'
Print unique lines in "file1" compared to "file2" in the order they appear </s> comm -23 <(sort file1) <(sort file2)|grep -f - file1
Mount partition with label "WHITE" on "/mnt/WHITE" </s> mount -L WHITE /mnt/WHITE
search for the regular/normal file "myfile" in the current folder excluding search in the paths of "work" and "home" sub directories </s> find .  \( -name work -o -name home \)  -prune -o -name myfile -type f -print
List content of 'myfile' in a subshell and returns output to parent shell </s> $(cat myfile)
list all js files under currect directory exculde the directory which path contain "/path/to/search/exclude_me" or name isexclude_me_too_anywhere </s> find /path/to/search                    \   -type d                               \     \( -path /path/to/search/exclude_me \        -o                               \        -name exclude_me_too_anywhere    \      \)                                 \     -prune                              \   -o                                    \   -type f -name '*\.js' -print
Searches the manual page names and descriptions </s> apropos
find all the jpg files in current folder and sort them </s> find . -type f|grep -i "\.jpg$" |sort
find all regular file and create jw-htmlfiles.tar </s> find . -type f -name "*html" | xargs tar cvf jw-htmlfiles.tar -
find the file "dateiname" in the current folder ( case insensitive search) </s> find -iname "Dateiname"
Find all regular files whose names contain "@" in directory tree ~/$folder </s> find ~/$folder -name "*@*" -type f -print0
search in the home folder for all the files with the name "monfichier" </s> find /home/ -name monfichier
Find all empty directories under /tmp </s> find /tmp -type d -empty
find all the files in the current directory which have been modified in the  last 6 days. </s> find . -atime +6
display all the files in the current directory and do not search in sub directories </s> find . -maxdepth 1 -print0
Replace all occurrences of 'previousword' with 'newword' in all regular files with '.cpp' extension under '/myprojects' directory tree and modify them in-place </s> find /myprojects -type f -name *.cpp -print0 | xargs -0 sed -i 's/previousword/newword/g'
Find files/directories that belong to user 'ian' under '/tmp' directory tree </s> find /tmp -user ian
kill group leader </s> kill `jobs -lp`
Search the /path/to/dir directory tree for .c files </s> find /path/to/dir -name \*.c
Find all empty files starting from the current directory and delete them </s> find . -type f -empty -print0 | xargs -0 /bin/rm
Execute "ps -C java -o pcpu,state,cputime,etimes" every second </s> watch -n 1 ps -C java -o pcpu,state,cputime,etimes
Search the current directory tree for files and directories whose names do not end in ".exe" and ".dll" </s> find . -name \*.exe -o -name \*.dll -o -print
List an empty environment (prints nothing) </s> env -i
Find .rmv files in the current directory recursively </s> find . -name *.rmv
Find all files named "file.ext" in the current directory tree and print the path names of the directories they are in </s> find `pwd` -name "file.ext" -exec echo $(dirname {}) \;
search for all perl files in the folder /nas/projects/mgmt/scripts/perl which have been modified yesterday </s> find /nas/projects/mgmt/scripts/perl -mtime 1 -daystart -iname "*.pl"
Generates a randomly sorted list of numbers from 1 to 10. </s> seq 1 10 | sort -R | tee /tmp/lst |cat <(cat /tmp/lst) <(echo '-------') \ <(tac)
Find all regular files under $d directory tree and change their permissions to 777 </s> find "$d/" -type f -print0 | xargs -0 chmod 777
Creates temporary file with name formatted like '.script.XXXXXX' in '/tmp/' folder and saves path to it in 'script2' variable. </s> script2=`mktemp /tmp/.script.XXXXXX`;
find all files in current folder which are bigger than 1MB </s> find ./ -size +1000k
Copies defined file to the target folder without overwriting existing files. </s> cp -n
Prints long listing of "$dir/$file" file. </s> ls -l -- "$dir/$file"
Ping hostname, grep for 192.168.11 and print the IP from the output </s> ping -c 1 hostname | grep 192.168.11 | grep 'bytes from' | awk '{print $4}' | sed 's/://g'
display all the text files in current folder </s> find . -name "*.txt" -printf "%f\n"
Print the absolute path of third-level files under the current directory tree and number the output </s> ls -d -1 $PWD/**/*/* | nl
lists txt or html files older than 5 days, null separated </s> find . \( -name '*.txt' -o -name '*.html' \) -mtime +5 -print0
Move all directories in the current directory tree that have been modified in the last day to "/path/to/target-dir" </s> find . -type d -mtime -0 -print0 | xargs -0 mv -t /path/to/target-dir
Print local SRV record of domain '_etcd-client._tcp.' </s> dig @"127.0.0.1"  _etcd-client._tcp. SRV
Displays calendar of a previous, current and next month for December of 2120 year. </s> cal -3 12 2120
Reversibly sorts content of the '${TMP}/${SCRIPT_NAME}.kb' file, comparing human readable numbers in file strings. </s> cat ${TMP}/${SCRIPT_NAME}.kb|sort -rh;
List files in "dir1" that are not in "dir2" </s> comm -23 <(ls dir1 |sort) <(ls dir2|sort)
Find all files/directories under current directory </s> find -print
find files which modification time is  7 days ago </s> find . -mtime -7
Split standard input into files of at most 1000 lines each </s> split
Find directories named 'work' under '/usr/ports/' directory tree and remove them </s> find /usr/ports/ -name work -type d -print -exec rm -rf {} \;
Find out all *.sh owned by user vivek </s> find / -user vivek -name "*.sh"
Filter contents of 'file' through awk commands written in script.awk, display the result. </s> awk -f script.awk file
Remove containing directories and suffix ".wiki" from specified path, output the result. </s> basename /home/jsmith/base.wiki .wiki
Find all files/directories matching the regex .*sql.* </s> find -regex .*sql.*
Find all fglrx-libGL* files under and below debian/fglrx/ </s> find debian/fglrx/ -name 'fglrx-libGL*'
make directory "/etc/cron.15sec" </s> mkdir /etc/cron.15sec
Allow all users to execute "myscript.sh" </s> chmod a+x myscript.sh
Find all the SGID bit files under current directory whose permissions set to 644 and show a few lines of output from the beginning </s> find . -perm 0644 | head
Remove all files with a txt extension under current directory </s> find . -type f -name "*.txt" -print|xargs rm
Count the number of .gz files in directory tree /home/user1/data1/2012/mainDir </s> find /home/user1/data1/2012/mainDir -name '*.gz' | wc -l
Find 10 most recently changed files in the current directory tree </s> find . -type f -printf "%C@ %p\n" | sort -rn | head -n 10
Find all .sh files in the current directory tree and remove them </s> find . -name "*.sh" -print0 | xargs -0 rm -rf
display all the html files in the current folder excluding search in the paths ./foo, ./bar. </s> find . -path "./foo" -prune -o -path "./bar" -prune -o -type f -name "*.html"
Split "input_file" into files of at most 100 lines each with prefix "output_file" </s> split -l 100 input_file output_file
find .bmp or .txt files </s> find /home/user/Desktop -name '*.bmp' -o -name '*.txt'
Find files with SGID (2000) and SUID(4000) permssions set in the file system </s> find /  \( -perm -2000 -o -perm -4000 \) -ls
Find all files under ${searchpath} that match the regex ${string1}.*${string2}.*${string3}  in their contents where ${string1} etc.. will be expanded </s> find "${searchpath}" -type f -print0 | xargs -0 grep -l -E "${string1}".*"${string2}".*"${string3}"
Rename $file file, preserving only part of name before '-' symbol, and appending '.pkg' suffix to the end </s> mv $file $(echo $file | rev | cut -f2- -d- | rev).pkg
find all the files in the folder /home which are exactly of size 10MB </s> find /home -size 10M
Create all directories in the path specified by variable $javaUsrLib as super user </s> sudo mkdir -p $javaUsrLib
display all the ".sh" files in the current folder </s> find -name *.sh
display the three smallest files by size in a folder. </s> find /etc/ -type f -exec ls -s {} + | sort -n | head -3
SSH in server 'server' as user 'user' with X11 forwarding disabled </s> ssh -x user@server
display all the directories in the folder /var and do not go beyond 2 levels during search </s> find /var -maxdepth 2 -type d;
Find all .core files on the system starting from / and delete them </s> find / -name "*.core" -print -exec rm {} \;
Save system information appended with the current date in 'filename' variable </s> filename="$(uname -a)$(date)"
Merge colon-separated information from file1 and file2 where second field of both files matches, sorting the result based on this field - for each line, output: first 3 fields of first file, followed by first 3 fields of second file. </s> join -o 1.1,1.2,1.3,2.1,2.2,2.3 -j2 <(sort -k2 file1) <(sort -k2 file2)
Find and delete all hard links in the /home directory to file1 </s> find /home -xdev -samefile file1 -print0 | xargs -0 rm
find all regex  '\./[a-f0-9\-]\{36\}\.jpg' files </s> find . -regex '\./[a-f0-9\-]\{36\}\.jpg'
Removes all top-level empty folders within the current folder. </s> ls | xargs rmdir
Finds all strings with parent folder of path '$path' in 'file', and saves result in 'x' variable. </s> x=$(grep "$(dirname "$path")" file)
display all directories in current folder </s> find . -type d -print0
List all *.jpg files/directories in entire file system </s> find / -name "*.jpg" -print
Find files under '/travelphotos' directory tree which are bigger than 200KB and do not have 2015 in their names </s> find /travelphotos -type f -size +200k -not -iname "*2015*"
Find all files/directories in entire file system that have  "write" bit set for either the owner, the group, or others </s> find / -perm /a+w
Find all directories under /path/to/base/dir and change their permission to 755 </s> chmod 755 $(find /path/to/base/dir -type d)
Disables shell option 'compat31'. </s> shopt -u compat31
Find recursively regular files in the directory given as the script's command line argument #1, skipping hidden files and directories </s> find "$1" -path "*/.*" -prune -o \( -type f -print0 \)
Find all files/directories under current directory with the null character as the delimiter </s> find -print0
find  files which full path name is /tmpfoo/bar under foo directory and print </s> find foo -path /tmp/foo/bar -print
List all defined bash functions </s> set | egrep '^[^[:space:]]+ [(][)][[:space:]]*$' | sed -r -e 's/ [(][)][[:space:]]*$//'
find all the files that have been modified in exactly 7*24 hours ago </s> find . -mtime 7
Remount "/dev/shm" with a maximum size of "40G" </s> mount -o remount,size=40G /dev/shm
Print the input "hello world" followed by a swap of the first two awk fields </s> echo hello world | tee  >(awk '{print $2, $1}')
Exclude directory from find . command </s> find build -not \( -path build/external -prune \) -name \*.js
Use "/var/log/wtmp" and print IPs and search for "^msw.*127.0.0.1" </s> who --ips /var/log/wtmp | grep '^msw.*127.0.0.1'
Move "file.txt" to docker container "$CONTAINER_ID" in path "/var/lib/docker/devicemapper/mnt/$CONTAINER_ID/rootfs/root/file.txt" </s> mv -f file.txt /var/lib/docker/devicemapper/mnt/$CONTAINER_ID/rootfs/root/file.txt
find all files that were modified between 90 to 100 days ago in home directory and delete then . </s> find /home -type f -mtime +90 -mtime -100  -exec rm  {} \;
Go to directory named "~" (not home directory) </s> cd `echo -n "~"`
Find all regular files in the the user's home/mail directory and search for the word "Linux". </s> find ~/mail -type f | xargs grep "Linux"
Print the terminal file of the users who are logged in with "admin" in their name </s> who |grep -i admin |cut -c10-20
Rename "file0001.txt" to "1.txt" </s> mv file0001.txt 1.txt
find all js files which path does not contain ./node_modules/* nor './vendor/*" </s> find -name '*.js' -not -path './node_modules/*' -not -path './vendor/*'
Print the date formatted with "%a %x %X" followed by the host name </s> echo `date +"%a %x %X"` `hostname`
Finds PIDs of all running processes, gets executable binary of each process, and prints containing folder of each binary. </s> ps -A -o pid | xargs -I pid readlink "/proc/pid/exe" | xargs -I file dirname "file"
display all the jars in the current folder </s> find . -iname '*.jar'
find all the files in the entire file system which have been modified in the last 120 hours </s> find / -mtime -5 -print
Print the list of all regular files from the current directory tree that contain "confirm", case insensitive </s> find . -type f -exec grep -il confirm {} \;
Recursively change the owner and group of all files in "public_html" to "owner" </s> chown -R owner:owner public_html
Prints process tree of a current process with id numbers and parent processes. </s> pstree -sp $$
Find all $2 files in $1 path and search for the regex expanded by $3 in those files excluding the files with /proc in their paths </s> find $1 -name "$2" | grep -v '/proc' | xargs grep -Hn "$3" {} \;
Perform a default Plesk configuration </s> find /var/www/vhosts/*/httpdocs -type f -iwholename “*/wp-includes/version.php” -exec grep -H “\$wp_version =” {} \;
Compresses with compression level 9 all files under the current folder but already compressed '*.bz2' files, performing in background. </s> find "$1" -type f | egrep -v '\.bz2' | xargs bzip2 -9 &
Find all files/directories with '.log' extension whose names start with 'app-', have been modified in the last 5 minutes and show the first one found </s> find /var/log/crashes -name app-\*\.log -mmin -5 -print | head -n 1
Remove all directories called "test" from the current directory tree </s> find . -name test -type d -exec rm -r {} \;
Print content of all files ending with '*.foo' in current directory recursively </s> find . -name '*.foo' -exec cat {} \;
Find all CDC* files under current directory that were accessed less than 1 day ago and delete the first and last lines from those files </s> find .  -type f -name "CDC*" -ctime -1 -exec sed -i'' -e '1d' -e '$d' '{}'  \;
Make all regular files in the current directory tree world-readable </s> find . -type f -print0 | xargs -0 chmod go+r
Archive all filepattern-*2009* files/directories under data/ into 2009.tar </s> find data/ -name 'filepattern-*2009*' -exec tar uf 2009.tar '{}' +
Print content of '1' file </s> $ cat 1
Find all SUID set files </s> find / -perm /u=s
create directory /cpuset </s> mkdir /cpuset
Find files matching pattern $2 in the $1 directory recursively and search them for text $3, where $1, $2, $3 are the command line arguments to the Bash script </s> find $1 -name "$2" | grep -v '/proc' | xargs grep -Hn "$3" {} \;
Find all leaf directories that include only one occurrence of "modules" </s> find -regex '.*/modules\(/.*\|$\)' \! -regex '.*/modules/.*/modules\(/.*\|$\)' -type d -links 2
Subtract all columns in "File2" from "File1" except the first </s> awk 'FNR==NR { for(i=2;i<=NF;i++) a[$1][i]=$i; next } { for(j=2;j<=NF;j++) $j-=a[$1][j] }1' File2 File1 | rev | column -t | rev
Save host name in variable "thisHOSTNAME" </s> thisHOSTNAME=`hostname`
find all the text files in the current folder starting with "somefiles-"  and prepend the first line </s> find . -name "somefiles-*-.txt" -type f -exec sed -i 'iText that gets prepended (dont remove the i)' -- '{}' \;
Search for all the directories in directories taken from the glob pattern '/path/to/folders/*' and add the extension ".mbox" to all and create directories named 'Messages' inside them </s> find /path/to/folders/* -type d -exec mv {} {}.mbox \; -exec mkdir {}.mbox/Messages \;
Measure the disk space taken up by all *.txt files in directory trees folder1 and folder2 </s> find folder1 folder2 -iname '*.txt' -print0 | du --files0-from - -c -s | tail -1
List the 10 largest files or directories and their sizes under (and including) "/var" </s> du -a /var | sort -n -r | head -n 10
Change permissions of all regular files from the current directory tree to 644 </s> find . -type f -exec chmod 644 {} +
Change permissions to 755 for all directories in the /path/to/dir directory tree </s> find /path/to/dir -type d -exec chmod 755 {} \;
Find files matching pattern $2 in the $1 directory recursively and search them for text $3, where $1, $2, $3 are the command line arguments to the Bash script </s> find $1 -path /proc -prune -o -name "$2" -print -exec grep -Hn "$3" {} \;
Gets MAC address of p2p0 network interface. </s> ifconfig p2p0 | grep -o -E '([[:xdigit:]]{1,2}:){5}[[:xdigit:]]{1,2}'
Find all files on the system that are larger than 600 MB </s> find / -size +600M -print
search for all the foo.txt files in the current folder and move them to another location </s> find . -name foo.txt -print0 | xargs -0  -I{} mv {} /some/new/location/{}
Find all files named 'new' under current directory tree and display their contents </s> find . -name new -print -exec cat {} \;
find all the files in the file system whcih have been modified in the last 1 day </s> find / -mtime -1
Find all files under current directory that were modified less than 1 day ago </s> find -mtime -1
Remove any file containing string "GUI" </s> find / -type f -print0 | xargs -0 grep -liwZ GUI | xargs -0 rm -f
Prints Kb size of all top-level files and folders in a current folder in descending order in human readable format. </s> du -ksh * | sort -n -r
List all broken symlinks excluding cyclic links under current directory </s> find . -type l -printf "%Y %p\n" | grep -w '^N'
display all directories which have not been accessed in the last 24*3 hours </s> find -type d -and -atime +3
delete all the regular files in the temp folder which have not been modified in the last 24 hours </s> find /tmp/ -type f -mtime +1 -print0 | xargs -0 -n1 rm
search for all the php files in the folder "/home/mywebsite" which have been changed in the last 30*24 hours </s> find /home/mywebsite -type f -name "*.php" -ctime -30
sort each file in the bills directory, leaving the output in that file name with .sorted appended </s> find bills -type f | xargs -I XX sort -o XX.sorted XX
Save the first word of the first difference in ".dir_list_2" compared to ".dir_list_1" into variable "extract_dir" </s> extract_dir=$(diff .dir_list_1 .dir_list_2 | grep '>' | head -1 | cut -d' ' -f2)
Archive showing progress "sourcefolder" to "/destinationfolder" excluding "thefoldertoexclude" </s> rsync -av --progress sourcefolder /destinationfolder --exclude thefoldertoexclude
display files ending with ".ext" in current folder excluding those that are present in the list list.txt </s> find -type f -name '*.ext' | grep -vFf list.txt
Set permissions of all files under "/opt/lampp/htdocs" to 644 </s> find /opt/lampp/htdocs -type f -exec chmod 644 {} \;
List all files in /var/www and below that have changed in the last 10 minutes </s> find /var/www -cmin -10 -printf "%c %pn"
Search the home directory tree for files modified less than a day ago </s> find $HOME -mtime -1
List all php files below current directory whose full pathname name does not include "libs", "tmp", "tests", or "vendor", sorted by number of lines, letting the user page interactively through the output. </s> find . -name '*.php' -print0 | xargs -0 wc -l | sort -nr | egrep -v "libs|tmp|tests|vendor" | less
Find all files under /home/feeds/data without descending into *def/incoming* and *456/incoming* paths </s> find /home/feeds/data -type f -not -path "*def/incoming*" -not -path "*456/incoming*"
display a long listing of the files in current folder which have been modified in the last 60 minutes </s> find . -mmin -60 |xargs ls -l
Counts lines in each *.php file. </s> wc -l `tree -if --noreport | grep -e'\.php$'`
Filters only directories from long file listing of the current directory </s> ls -l --color=always "$@" | egrep --color=never '^d|^[[:digit:]]+ d'
Print "Total generated: " followed by the number of unique lines in "$generated_ports" </s> echo "Total generated: $(echo "$generated_ports" | sort | uniq | wc -l)."
Send each byte in "/home/cscape/Desktop/table.sql" to awk </s> fold -1 /home/cscape/Desktop/table.sql  | awk '{print $0}'
display all the files in the current directory excluding those that are in the 'secret' directory </s> find . -name 'secret' -prune -o -print
Remove each unique item listed on standard input and do nothing if empty </s> sort | uniq -u | xargs -r rm
Copy *.mp3 files to /tmp/MusicFiles </s> find . -type f -name "*.mp3" -exec cp {} /tmp/MusicFiles \;
Enable history expansion in a script </s> set -H
List all .c and .h files in the current directory tree that contain "thing" </s> find . -name '*.[ch]' -print0 | xargs -r -0 grep -l thing
Display the contents of 'your_file' wrapping lines to maximum 80 characters, and waiting for user interaction after each page. </s> fold -80 your_file | more
display a long listing of all regular files  in current folder which have been modified in the last 60 minutes </s> find . -mmin -60 -type f -exec ls -l {} \;
Get a list of all hidden files from the current directory tree </s> find . -type f -name '.*'
show all the mp3 files in the folder /home </s> find /home -type f -name '*.mp3'
Find all files which  begin with 'a' or 'b' from current directory downwards and print them. </s> find . -name [ab]* -print
List all files and folders in the current working directory </s> ls `pwd`/*
Rename the *.so files in the current directory tree prepending their names with "lib" </s> find . -name "*.so" -printf "mv '%h/%f' '%h/lib%f'\n" | bash
Replace the leading spaces in the output of "history" with periods </s> history | sed 's/^ */&\n/; :a; s/ \(.*\n\)/.\1/; ta; s/\n//'
Silently read a line into variable "passwd" with prompt "Enter your password: " </s> read -s -p "Enter your password: " passwd
Search the current directory recursively for MOV files </s> find . -iname *.mov
Split "data.tsv" into files of at most 5000000 lines each with prefix "_tmp" </s> split -l5000000 data.tsv '_tmp';
Create a symbolic link in the current directory to "$file" </s> ln -s "$file"
Print file system disk space usage in 1 KiB blocks of the current directory's file system </s> df -k .
Find recursively all files whose names ends with "foo" </s> find . -name "*foo"
search for all the regular/normal files with the name "access.log" in the folder /var/www which are bigger than 100MB </s> find /var/www -type f -name «access.log*» -size +100M
Find all files/directories with '.c' or '.h' extension under current directory tree and search for the regex expanded by the variable $i and show the output by paging through one screenful at a time </s> find . -name '*.[ch]' -exec grep $i {} | less
Remove all files from the system whose path names contain "GUI" </s> find / -type f -print0 | xargs -0 grep -liwZ GUI | xargs -0 rm -f
Execute "script.awk" on "file" and format the output as a table </s> awk -f script.awk file{,} | column -t
list all CSS files under the current directory </s> find . -type f -name "*.css"
Source "lib/B" relative to the directory of the executing shell script, will fail if currently running script is not in PATH. </s> source "$( dirname "$( which "$0" )" )/lib/B"
Find any file that has "disc" somewhere in its name in the current directory and all of its sub-directories. </s> find . -name *disc*
Find all files/directories with '.what_to_find' extension under current directory tree and show the list by excluding paths that contain 'excludeddir1' and 'excludeddir2' </s> find . -name '*.what_to_find' | grep -v exludeddir1 | grep -v excludeddir2
Execute "ls -l" every 2 seconds </s> watch ls -l
List files named "accepted_hits.bam" in the current directory tree prefixing their names with "somecommand" </s> find `pwd` -name "accepted_hits.bam" | xargs -i echo somecommand {}
Set up a local SSH tunnel from port 80 to port 3000 </s> sudo ssh $USERNAME@localhost -L 80:localhost:3000 -N
Print full path of command "python" </s> which python
Reports count of characters in the value of ${FOO_NO_LEAD_SPACE} variable as follows: "length(FOO_NO_LEAD_SPACE)==<counted number of characters>" </s> echo -e "length(FOO_NO_LEAD_SPACE)==$(echo -ne "${FOO_NO_LEAD_SPACE}" | wc -m)"
find all the files in the home folder which have been modified in the last 7 days </s> find $HOME -mtime -7
Go to directory named "~" (not home directory) </s> cd "~"
Remove the last two components (directories) of $path </s> echo $path | rev | cut -d'/' -f4- | rev
Search the /path directory tree for files lacking the group writable bit </s> find /path ! -perm /g+w
display the list of all the text files present in the current directory excluding the search in certain paths. </s> find . -type f -name "*.txt" ! -path "./Movies/*" ! -path "./Downloads/*" ! -path "./Music/*" -ls
find regular files and directories that have been modified in the last seven days </s> find . -mtime -7 -type f
Find all the files that end with the extension “.java” in the current directoy tree </s> find . -name "*.java"
Print the list of files in the current directory tree skipping SVN files </s> find . -name .svn -a -type d -prune -o -print
Delete all hidden files/directories under $some_directory </s> find "$some_directory" -name '.*' ! -name '.' ! -name '..' -delete
download content from "http://example.com/textfile.txt" and output to "textfile.txt" </s> curl http://example.com/textfile.txt -o textfile.txt
Find all .txt files except README.txt </s> find . -type f -name "*.txt" ! -name README.txt -print
As root, edit the cron job list of user "apache" using the editor specified by EDITOR environment variable, or default /usr/bin/editor if this variable is not set. </s> sudo crontab -e -u apache
Recursively finds all 'STATUS.txt' files containing text 'OPEN' and prints containing folder of them. </s> fgrep --include='STATUS.txt' -rl 'OPEN' | xargs -L 1 dirname
See what files are executable by the file's owner and group </s> find -type f -perm -110
Print working directory separated by newlines instead of forward slashes </s> pwd | tr '/' '\n'
Find all files/directories under '/usr' directory tree that have not been modified in the last 356 days counting days from today </s> find /usr -mtime +356 -daystart
Search the xargstest/ directory recursively for files matching pattern 'file??' </s> find xargstest/ -name 'file??'
Remove all *.txt files in the home directory tree with confirmation </s> find $HOME/. -name *.txt -ok rm {} \;
Print the icmp sequence number and ping time of each request to "127.0.0.1" </s> ping -c 2 -n 127.0.0.1 | awk -F'[ =]' -v OFS='\t' 'NR>1 { print $6, $10 }'
Save $line line in history </s> history -s "$line"
Recursively move all files in "/path/to/srcdir" to "dest/" </s> find /path/to/srcdir -type f -print0 | xargs -0 -i% mv % dest/
Create directorie(s) 'some/path' as required in the current directory </s> mkdir -p ./some/path
Print a detailed list of all regular files from the current directory tree </s> find . -type f -ls
Keep the last 4 ASCII characters (bytes) of a string. </s> echo "0a.00.1 usb controller some text device 4dc9" | rev | cut -b1-4 | rev
Continuously answer "y" to any prompt from "mv ..." </s> yes | mv ...
find all the files in the current folder which have the name net or comm in them </s> find . -regex '.*\(net\|comm\).*'
Save the user name of the current user to variable "whoami" </s> whoami=$(whoami)
Display the contents of /var/log/syslog one page at a time, pausing for user interaction between each. </s> more /var/log/syslog
Silently read a single character from standard input into variable "REPLY" without backslash escapes, with a timeout of 5 seconds, and using the prompt $'Press any key or wait 5 seconds to continue...\n' </s> read -rsp $'Press any key or wait 5 seconds to continue...\n' -n 1 -t 5
Find all the files in file system which are accessed 50 days back </s> find / -atime 50
Find all broken symlinks under current directory </s> find -L . -type l
Change permissions of all directories from the current directory tree to 644 </s> find . -type d -exec chmod 755 {} +
Display the content of YourFile.txt, waiting for user input at each page. </s> cat YourFile.txt | more
Print all files/directories with their sizes under $WHATEVER directory tree </s> find $WHATEVER -printf "%s %p\n"
display all directories in vim folder do not search in sub directories </s> find .vim/ -maxdepth 1 -type d
List all environment variables whose name starts with PATH, showing the name and value of each one. </s> env | grep ^PATH
Search all files called "abc" that reside in the current directory tree for string "xyz" </s> find . -name abc | xargs grep xyz
Search the first 300 commands in history containing "scp" and ending in "important" </s> history 300 | grep scp | grep important$
Locate all files in the current directory and below that have "testfile" in their names </s> find -name "*testfile*"
Find files/directories under current directory without descending into it </s> find -maxdepth 0
Prints message info about filename and location of the current script </s> echo "The script you are running has basename `basename $0`, dirname `dirname $0`"
Search the directories matching pattern "/path/to/some/dir/*[0-9]" for level 1 subdirectories </s> find /path/to/some/dir/*[0-9] -type d -maxdepth 1
same as above example with -exec , in this example with -OK it should ask for confirmation before executing the rm command . that is called user intractive command </s> find . -name core -ok rm {} \;
Create a symbolic link named "wh" to "$wh" </s> ln -s "$wh" wh
delete all the files ending with "~" in current folder </s> find -name '*~' -delete
list regular files ending in .mbox </s> find . -type f -wholename \*.mbox
Find all empty directories in the current one and delete them </s> find . -type d -maxdepth 1 -empty -delete
Store content of uncompressed file "$file.fastq" in variable "reads" </s> reads=$(zcat $file.fastq)
Force create a symbolic link named "$*" to the canonical absolute path of "$1" </s> ln -sf "$(readlink -f "$1")" "$*"
Find all symbolic links containing 'javaplugin' in their names under '/usr' directory tree </s> find /usr/ -lname *javaplugin*
Find all 'test' directories in the current directory tree and remove them </s> find . -type d -name 'test' -exec rm -rf {} \;
Find all *foo files/directories under current directory </s> find . -name '*foo'
remove all text files from the current folder. Print0 is used to handle files whose names have only spaces or those files which have newlines in their names </s> find -name "*.txt" -print0 | xargs -0 rm
find all the zip files in the current folder </s> find . -type f -name '*.zip'
Print the file content of command "[whatever]" </s> cat `find [whatever]`
Force delete all the regular/normal files in the current folder and do not search in the sub folders </s> find . -maxdepth 1 -type f -exec rm -f {} \;
Remove all regular files in the current directory </s> find ./ -type f -exec rm -rf {} \;
Archive all directories in /path/to/directory/* (only command line arguments, no sub-directories) to files with .tar.gz extension </s> find /path/to/directory/* -maxdepth 0 -type d -printf "%P\n" -exec sudo tar -zcpvf {}.tar.gz {} \;
Print characters 2 through 4 of "abcdefg" </s> echo 'abcdefg'|tail -c +2|head -c 3
find all .bak files in or below the current directory and move them to ~/.old.files directory: </s> find . -name "*.sh" -print0 | xargs -0 -I {} mv {} ~/back.scripts
Change file permissions on all regular files within a directory </s> find /path/to/directory -type f -exec chmod 644 {} +
Print all the file/directory paths under current directory </s> find | xargs
List all files in the current directory tree that were last modified between "mar 03, 2010 09:00" and "mar 11, 2010" </s> find -newermt "mar 03, 2010 09:00" -not -newermt "mar 11, 2010" -ls
Ping all hosts in file "ips" twice </s> cat ips | xargs -n1 ping -c 2
Find all *.ogg files under the home directory ignoring the case </s> find $HOME -iname '*.ogg'
Find all .mp3 files with more then 10MB and delete them from root directory . </s> find /  -type f -name *.mp3 -size +10M -exec rm  {} \;
Search the current directory tree for regular files omitting directory `omit-directory' </s> find . -name omit-directory -prune -o -type f  -print
Numerically sort IPv4 addresses specified on standard input with presedence to first, second, third, then fourth octet </s> tr '.' ' ' | sort -nu -t ' ' -k 1 -k 2 -k 3 -k 4 | tr ' ' '.'
Brings down network interface eth0. </s> ifconfig eth0 down
Find all files/directories named modules under current directory </s> find . -name modules
Force create a hard link named '/home/user/Musik/youtube converted/aesthesys~ I Am Free, That Is Why I'"'"'m Lost..mp3' with target '/home/user/Musik/mix-2012-13/aesthesys~ I Am Free, That Is Why I'"'"'m Lost..mp3' </s> ln -f '/home/user/Musik/mix-2012-13/aesthesys~ I Am Free, That Is Why I'"'"'m Lost..mp3' '/home/user/Musik/youtube converted/aesthesys~ I Am Free, That Is Why I'"'"'m Lost..mp3'
search for the file test in the current folder </s> find . -name test
Find all Makefile's in the current directory tree and look for line 235 in each of them </s> find -type f -name "Makefile" -exec awk 'FNR==235 {print FILENAME; print}' {} +
Enables 'nullglob' shell option. </s> shopt -s nullglob
Send an audible ping to "10.100.3.104" </s> ping -a 10.100.3.104
Find all files/directories named 'foo.bar' in the entire filesystem </s> find / -name foo.bar -print
display all normal/regular files or directories in the folder "$ORIG_DIR" </s> find "$ORIG_DIR" -name "*" -type d -o -name "*" -type f
Recursively change the owner of all files in "~/tmp" to "$USER" </s> sudo chown -R $USER ~/tmp
Opens gawk info manual and goes to command-line options node. </s> info -O gawk
Change to parent directory and resolve any symlinks in the resulting path, making the physical path the current one. </s> cd -P ..
Gets list of IP addresses of all network interfaces. </s> ifconfig | awk -F"[ :]+" '/inet addr/ && !/127.0/ {print $4}'
find all the png files in current folder which are present in the pattern list file "search.txt" </s> find . -name '*.png' | grep -f <(sed s/^/[0-9]_[0-9]_[0-9]_/ search.txt)
Find all files and directories starting from the current directory and excluding hidden files and directories </s> find . \( ! -regex '.*/\..*' \) | sed 's/^..//'
display a long listing of all the files in the current folder which have been modified in the last 24 hours </s> find . -mtime -1 | xargs ls -ld
Returns exit code 1. </s> a=$(false)
display all the regular/normal files in the current folder excluding the files "bbb" and "yyy" </s> find . \( -name bbb -o -name yyy \) -prune -o -type f -print
Search the Movies folder in the user's home directory for files larger than 1024 megabytes in size. </s> find ~/Movies/ -size +1024M
find all files in current folder which are bigger than 270MB and less than 300MB </s> find . -size +270M -size -300M
Delete files in /var/tmp/stuff and below that have not been modified in over 90 days </s> find /var/tmp/stuff -mtime +90 -delete
Change every directory under "/var/www/html/" to have permissions 775 </s> sudo  find /var/www/html/ -type d -exec chmod 775 {} \;
Find regular files named 'findme.txt' under '/usr' and '/home' directory tree </s> find /usr /home -name findme.txt -type f -print
Search for occurrences of string "main(" in the .c files from the current directory tree </s> find . -name "*.c" -print | xargs grep "main("
find all regular/normal files in current folder which have been modified in the last 60 minutes </s> find -type f -mtime -60
Move server.log to 'logs' directory with new name as the current date formatted as "%Y%m%d%H%M" and with '.log' extension </s> mv server.log logs/$(date -d "today" +"%Y%m%d%H%M").log
Make directory "foo" and do not cause an error if it exists </s> mkdir -p foo
Search regular files from the /path/to/dir directory tree for lines that contain "_START" and are enclosed in lines "@GROUP" and "@END_GROUP" </s> find /path/to/dir -type f -exec sed '/@GROUP/,/@END_GROUP/!d' {} \; | grep '_START'
list files in /usr modified after February 1 of the current year </s> find /usr -newermt "Feb 1"
Sort all directory names matching folder_* and go to the last one. </s> cd $(find . -maxdepth 1 -type d -name "folder_*" | sort -t_ -k2 -n -r | head -1)
Gets IP addresses of all active network interfaces. </s> ifconfig | grep -oP "(?<=inet addr:).*?(?=  Bcast)"
Find all files that belongs to user Tecmint under /home directory </s> find /home -user tecmint
Prints what day it was 222 days ago </s> date --date="222 days ago" +"%d"
List all files and sub directories including hidden files in the current directory tree </s> tree -af
Measure the disk space taken up by all TXT files in the current directory tree </s> find . -iname "*.txt" -exec du -b {} + | awk '{total += $1} END {print total}'
find all the files in the home folder which have been modified today </s> find ~ -type f -mtime 0
Delete all empty files and directories in the "test" directory tree </s> find test -depth -empty -delete
Find *.html files in the current directory tree that were modified 7 days ago </s> find . -mtime 7 -name "*.html" -print
Run the file command on every regular file under current directory </s> find . -type f -exec file '{}' \;
Changes group ownership of /sys/class/gpio/export and /sys/class/gpio/unexport to 'gpio'. </s> sudo chgrp gpio /sys/class/gpio/export /sys/class/gpio/unexport
search for the files in the current folder which begin with the word "kt" followed by a digit </s> find . -name 'kt[0-9] '
Search for occurrences of string "main(" in the .c files from the current directory tree </s> find . -type f -name "*.c" -print -exec grep -s "main(" {} \;
move all the files in the current folder  to temp folder and search atleast in one subfolder </s> find . -mindepth 1 -print0|xargs -0 -I, mv , /tmp
Print unique lines of sorted file "a" compared with sorted file "b" </s> comm -23 a b
find all files in home folder which have been modified exactly 1 day before </s> find ~ -mtime 1 -daystart
Remove all directories found in directory tree $LOGDIR that were modified more than 5 days ago </s> find $LOGDIR -type d -mtime +5 -exec rm -f {} \;
find all the files in the current folder that end with the word bar </s> find -name *bar
use regex with find command </s> find . -regextype sed -regex ".*/[a-f0-9\-]\{36\}\.jpg"
find all txt files under the current folder except ./misc folder </s> find . -path ./misc -prune -o -name '*.txt' -print
Recursively change the owner of all files in "/usr/local/lib/node_modules" to the current user </s> sudo chown -R $USER /usr/local/lib/node_modules
List all files in maximum 2 levels down the current directory </s> find . -maxdepth 2  -type f -print0 | xargs -0 -n1 ls -l
Creates temporary folder and saves path to it in a 'tempd' variable. </s> tempd=`mktemp -d`
Find all directories in the current directory tree that were last modified more than 5 minutes ago but less than 60 minutes ago </s> find . -mmin -60 -mmin +5
Copy all files below the current directory whose names contain "foobar" (case-insensitive) to directory foo/bar/ in user's home directory. </s> find . -iname "*foobar*" -exec cp "{}" ~/foo/bar \;
Search for all files in the current directory recursively whose names contain "linkin", ignoring the case </s> find . -iname *linkin*
Expand bash array "myargs" as arguments to "mv" </s> mv "${myargs[@]}"
remove all the DS_Store files in the current directory </s> find . -name .DS_Store -exec rm {} \;
find all 'js' suffix files  exclue the path *exclude/this/dir*' under current dirctory </s> find . -name '*.js' -not -path '*exclude/this/dir*'
Prints path to folder that contains target of the symbolic link ../../../../etc/passwd. </s> $(dirname $(readlink -e ../../../../etc/passwd))
Look for files whose names begin with letters a-j </s> find  / -name "[a-j]*" -print
Create a compressed archive named 'my_directory.tar.gz' with files inside directory 'my_directory' without including the directory entry 'my_directory' itself </s> tar -czvf my_directory.tar.gz -C my_directory .
Print a list of unique users who are logged in </s> who | cut -d' ' -f1 | sort | uniq
find all the files in the current folder which are exactly 1234 bytes </s> find . -size 1234c
Find all files under $d directory (no sub-directories) that are executable by owner and print only their names </s> find $d -maxdepth 1 -perm -100 -type f | sed 's#.*/##'
Print the full path of command "gcc" </s> which gcc
display all the files in current directory with each file name displayed twice in the same row </s> find . | sed 's/.*/& &/'
Copies all files under current directory like '*FooBar*' to the '~/foo/bar' directory. </s> find -name '*FooBar*' -print0 | xargs -0 cp -t ~/foo/bar
Print nothing because B.txt is compared with itself. </s> comm -2 -3 <(sort -n B.txt) <(sort -n B.txt)
Print 2 lines of "123456789" </s> yes 123456789 | head -2
Find all files/directories under $1 which have at least execute permission for their owner and set execute permission for group for these files/directories </s> find $1 -perm -u+x -exec chmod g+x {} \;
Find all .txt files in the dir/ directory tree and copy them along with times, permissions, and ownership to dir_txt/ </s> find dir/ -name '*.txt' | xargs cp -a --target-directory=dir_txt/ --parents
Download "Louis Theroux's LA Stories" using rsync over ssh </s> rsync -ave ssh '"Louis Theroux"''"'"'"'"''"s LA Stories"'
Print numbers from 1 to 10 using up to 4 processes </s> seq 10 | xargs -P4 -I'{}' echo '{}'
Remove all *.doc files from the current directory tree </s> find . -name '*.doc' -exec rm "{}" \;
Print space separated list of numbers from "$start" to "$end" </s> echo `seq $start $end`
Compress the file 'file' with 'bzip2' and append all output to the file 'logfile' and stdout </s> bzip2 file | tee -a logfile
Find all files/directories named orm.properties under current directory </s> find . -name "orm.properties"
Delete all broken symbolic links under '/usr/ports/packages' directory tree </s> find -L /usr/ports/packages -type l -exec rm -- {}	+
Find all directories named postgis-2.0.0 under / directory </s> sudo find / -type d -name "postgis-2.0.0"
Dump "input_file" as a 2 byte hexadecimal, character, and octal value and view the contents in "less" </s> od -xcb input_file_name | less
Get the total sizes of all files under current directory </s> find . -type f -printf '%p %s\n' | awk '{ sum+=$2}; END { print sum}'
Find the string 'joomla' case insensitively in all the php and html files under current directory tree and display the matched lines along with the file names and line numbers </s> find . \( -name "*.php" -o -name "*.html" \) -print0 | xargs -0 grep -Hin "joomla"
delete what was typed in the command line and run "pwd" when button "\e[24~" </s> bind '"\e[24~":"\C-k \C-upwd\n"'
Print summary of new/missing files, and which files differ between folder1 and folder2, excluding those matching pattern "node_modules". </s> diff -rqyl folder1 folder2 --exclude=node_modules
Find all files/directories with '.tar.gz' extension under $DIR/tmp/daily/ directory tree, sort them numerically and show the last 3 of them </s> find $DIR/tmp/daily/ -name '*.tar.gz' | sort -n | tail -3
Find all files/directories under current /export/home/someone directory and upload them to ftp://somehost/tmp/ </s> find /export/home/someone -exec curl -u someone:password -vT {} ftp://somehost/tmp/
Find files/directories not changed in two weeks under /dev/shm </s> find /dev/shm /tmp -type f -ctime +14
Count all the lines of code in all php files in current directory recursively </s> find . -name "*.php" | xargs grep -v -c '^$' | awk 'BEGIN {FS=":"} { $cnt = $cnt + $2} END {print $cnt}'
Find all files/directories under $1 which have at least execute permission for their owner and set execute permission for group for these files/directories </s> find "$1" -perm -u+x -print0 | xargs chmod g+x
Recursively changes group ownership of everything within a current folder and having group 'X_GNAME' to 'Y_GNAME'. </s> find . -group X_GNAME -exec chgrp Y_GNAME {} +
Find all regular files in the current directory tree and search them for "example" </s> find -type f -print0 | xargs -r0 grep -F 'example'
count the total number of lines that are present in all the normal/regular files </s> find . -type f -exec wc -l {} \; | awk '{total += $1} END{print total}'
find all directories in the current directory </s> find . -type d
Display a long list of all the files/directories named ".todo" under $STORAGEFOLDER directory tree </s> find $STORAGEFOLDER -name .todo  -exec ls -l {} \;
Make directories to file "/full/path/to/file.txt" as needed </s> mkdir -p `dirname /full/path/to/file.txt`
Verbosely compresses all files on sixth and seventh depth level keeping original files in place. </s> bzip2 -kv */*/*/*/*/*/*
Remove duplicate lines in "file_name" and print the output on stdout </s> awk '{print(NR"\t"$0)}' file_name | sort -t$'\t' -k2,2 | uniq -u --skip-fields 1 | sort -k1,1 -t$'\t' | cut -f2 -d$'\t'
Write out the entire directory hierarchy from the current directory </s> find .
find all empty files in /tmp directory . </s> find /tmp -type f -empty
ssh into "ssh.myhost.net" as user "myusername" and run command "mkdir -p $2" </s> ssh myusername@ssh.myhost.net "mkdir -p $2"
Convert Unix `cal` output to latex table code. </s> cal | sed '1d;2{h;s/./ /g;x};/^\s*$/b;G;s/\n/ /;s/^...\(.\{15\}\).*/\1/;s/.../ &\t\&/g;s/\&$/\\\\/'
Find all 400 permission files under /data directory and print 'Modifying ' appended with file path for each of them </s> find /data -type f -perm 400 -exec echo Modifying {} \;
Recursively finds and compresses all files in a current folder. </s> find . -type f -exec bzip2 {} +
find all the files in the home folder that have not been modified in the last one year </s> find $HOME -mtime +365
Copy "/new/x/y/z/" over the network to "user@remote:/pre_existing/dir/" preserving the directory hierarchy </s> rsync -a --relative /new/x/y/z/ user@remote:/pre_existing/dir/
Read the history file and append the contents to the history list </s> history -r
List all files in /home/bozo/projects directory tree that were modified within the last day </s> find /home/bozo/projects -mtime -1
Find all *.plist files/directories under current directory </s> find ./ -name "*.plist"
list all *.txt files in the user's home directory. </s> find ~/ -name '*.txt'
Remove the passphrase from ~/.ssh/id_rsa. </s> ssh-keygen -f ~/.ssh/id_rsa -P ""
Find all files/directories named 'findcommandexamples.txt' (case insensitive) in the entire filesystem </s> find  / -iname findcommandexamples.txt
find all the files in the entire file system whose size is greater than 20MB </s> find / -type f -size +20000k
Interpret in the current shell all lines in config.sh which contain the word "marker" </s> source <( grep "marker" config.sh )
Delete all files under root whose status were changed more than 30 minutes ago </s> find root -type -f -cmin +30 -delete
display all regular/normal files in the current folder with the name dummy </s> find -type f -name dummy
Find all files and directories and count them </s> find ./ | wc -l
Find files with inode number 199053 </s> find / -inum 199053
Find all files/directories under directory '.cache/chromium/Default/Cache/' which are bigger than 100MB and which are atleast 1 level deep and delete them </s> find .cache/chromium/Default/Cache/ -mindepth 1 -size +100M -delete
Find regular files named core under /tmp and delete them </s> find /tmp -name core -type f -print | xargs /bin/rm -f
Find all directories in directory tree `httpdocs' </s> find httpdocs -type d
Delete empty lines from standard input </s> sed -n "s/^$//;t;p;"
Make directory "backup" </s> mkdir backup
delete all the empty in the current folder and all its sub directories </s> find . -depth -type d -empty -exec rmdir {} \;
Lists all files in a current folder, separating names with comma. </s> ls | xargs -I {} echo {}, | xargs echo
Exclude directory from find . command </s> find . -type d -name proc -prune -o -name '*.js'
Calculate the md5 sum of the contents of the sorted list of files "$FILES" </s> cat $(echo $FILES | sort) | md5sum
find all files under the current folder except dir1 dir2 dir3  folder </s> find . -type d \( -path dir1 -o -path dir2 -o -path dir3 \) -prune -o -print
Archive "/path/to/sfolder" to "name@remote.server:/path/to/remote/dfolder" compressing the data during transmission </s> rsync -avlzp /path/to/sfolder name@remote.server:/path/to/remote/dfolder
Print the contents of "Little_Commas.TXT" </s> cat Little_Commas.TXT
Format bash array "${arr}" in columns </s> echo " ${arr[@]/%/$'\n'}" | column
Find all files in the level 6 subdirecotries of /usr/src and below, ignoring CVS files </s> find /usr/src -name CVS -prune -o -mindepth +6 -print
delete all files that have the extension "bam" in current directory </s> find . -name "*.bam" | xargs rm
Print the list of .txt files under and below the current directory </s> find . -name '*.txt' -print0|xargs -0 -n 1 echo
Make DNS lookup for hostname stackoverflow.com </s> dig stackoverflow.com
search for the file "process.txt" in the current directory </s> find . -name "process.txt"
Get A record for domain $domain </s> dig -t A $domain
Remove junk files modified more than 31 days ago recursively </s> find /path/to/junk/files -type f -mtime +31 -exec rm -f {} \;
Show manual of the find command </s> man find
Compute the mean average of the word count of *.txt files smaller than 2000 words in the home directory </s> find ~/Journalism  -name '*.txt' -print0 | xargs -0 wc -w | awk '$1 < 2000 {v += $1; c++} END {print v/c}'
Print the last line of the alphabetically sorted lines in file "set" </s> tail -1 <(sort set)
Find all files in the current directory tree whose names end with the suffix ".keep.$1", where $1 is the first command line argument, and remove that suffix </s> find . -type f -name "*.keep.$1" -print0 | xargs -0 rename "s/\.keep\.$1$//"
search for the word hello in all the text files in the temp folder and delete them </s> find /tmp -type f -name ‘*.txt*’ | sed -e ‘s/.*/\”&\”/’ |xargs -n 1 grep -l hello|sed -e ‘s/.*/\”&\”/’|xargs -n 1 rm -f
list symbolic links under the directory "$directory" </s> find $directory -type l
Remove all .txt files in and below the current directory </s> find . -name "*.txt" -exec rm {} \;
Replace the first occurrence of "foo" with "bar" on every line in .txt files from the current directory tree </s> find . -type f -name '*.txt' | xargs --replace=FILE sed --in-place 's/foo/baz/' FILE
List .html files in the current directory tree that contain string "base\-maps" but do NOT contain string "base\-maps\-bot" </s> find . -name "*.html" -exec grep -lR 'base\-maps' {} \; | xargs grep -L 'base\-maps\-bot'
Prints name of temporary file but doesn`t create nothing. </s> mktemp -u
Follows symbolic link $BASH_SOURCE, and prints path to its target. </s> $(dirname $(readlink -f $BASH_SOURCE))
Wrap each line in "yourfile" to fit in 79 characters and right pad any lines shorter with spaces </s> fold -w79 yourfile | sed -e :a -e 's/^.\{0,78\}$/& /;ta'
Set the setup connection timeout to 3 seconds for connecting to "user@ip" via ssh </s> ssh -o ConnectTimeout=3 user@ip
Print the number of packets sent, received, and the percentage lost for each ping request to "google.com" </s> ping google.com | awk '{ sent=NR-1; received+=/^.*(time=.+ ms).*$/; loss=0; } { if (sent>0) loss=100-((received/sent)*100) } { printf "sent:%d received:%d loss:%d%%\n", sent, received, loss }'
Move all directories in the current directory tree that have been modified in the last day to "/path/to/target-dir" </s> find . -depth -type d -mtime 0 -exec mv -t /path/to/target-dir {} +
Find files/directories named 'document' in the entire filesystem and in the directory tree '/usr' even if it's in a different partition without traversing to other devices/partitions </s> find / /usr -xdev -name document -print
List current directory, waiting for user input at each page. </s> ls | more
Count all the mp3 files in the music user's home and subdirs. </s> find ~music -type f -iname *.mp3 | wc -l
Move all directories in the current directory that match "some-dir" to "x/" </s> find ./ -maxdepth 1 -name "some-dir" -type d -print0 | xargs -0r mv -t x/
Print summary of new/missing files, and which files differ between dir1 and dir2. </s> diff -q dir1 dir2
List the files in "archive.tar.gz" </s> gzip -l archive.tar.gz
Find all *.log files under path/ that do not contain "string that should not occur" </s> find path/ -name '*.log' -print0 | xargs -r0 grep -L "string that should not occur"
Split "t.txt" into files with at most 30000000 lines each and use a prefix "t" and numeric suffixes of length 2 </s> split --lines=30000000 --numeric-suffixes --suffix-length=2 t.txt t
Count the number of files named 'job.history' under '/data/SpoolIn' directory tree that match 'FAIL' in their contents </s> find /data/SpoolIn -name job.history -exec grep -l FAIL {} \+ | wc -l
search  in root ( / ) directory downwards all files which  have exactly 2 links. </s> find /  -links 2 -print
Run "./configure" with a new environment variable CC set to the full path of the command 'cc' </s> CC=$(which cc) ./configure
Display permissions, user, group, and full path for each file in the current directory tree </s> tree -p -u -g -f
find the path of a specfic video file in the current directory </s> find . -name foo.mp4 | sed 's|/[^/]*$||'
Save all directories under the current directory as a comma separated list in variable "FOLDERS" </s> FOLDERS=$(find $PWD -type d | paste -d, -s)
Search for files which have read and write permission for their owner and group, and which other users can read, without regard to the presence of any extra permission bits </s> find . -perm -664
Remove all subdirectories of the current directory, except for "bar", "foo", "a", and "b" </s> find . -maxdepth 1 -type d \( ! -name "bar" -a ! -name "foo" -a ! -name "a" -a ! -name "b" \) -delete
display all the files in the home folder which begin with "arrow" and end with "xbm" </s> find ~ -name 'arrow*.xbm'
Find all files in $dir directory without going into sub-directories </s> find "$dir" -maxdepth 1 -type f
replace a word in all the regular/normal files in the current folder(doesn't actually modify the original file just displays the replaced text) </s> find . -type f -print0 | xargs -0 sed -i 's/Application/whatever/g'
Lists file descriptors of a current process. </s> ls -l /proc/self/fd/
Forward port 12345 bound on 'localhost' to port 12345 on 'otherHost' as user 'otherUser' </s> ssh -f -N -L localhost:12345:otherHost:12345   otherUser@otherHost
Display differences between files "a.txt" and "b.txt" side-by-side and do not output common lines. </s> diff -a --suppress-common-lines -y a.txt b.txt
Make directories "Labs/lab4a/folder1", "Labs/lab4a/myfolder", and "Labs/lab4a/foofolder" </s> mkdir Labs/lab4a/{folder1,myfolder,foofolder}
Counts lines in each of *.php files in a current folder and subfolders ignoring 'tests*' folders and prints total count as well. </s> find . -name "*.php" -not -path "./tests*" | xargs wc -l
Measure the disk space taken up by all *.txt files in the current directory tree </s> find . -name "*.txt" -print0 |xargs -0 du -ch
Output all lines in 'file' comparing the first 12 characters and discarding any adjascent lines where these characters are duplicates. </s> uniq -w12 -c file
find all the files older than 30 days </s> find /tmp -mtime +30 -print
Recursively finds all files in root folder and prints all strings with 'text-to-find-here' from that files, ignoring binary files. </s> find / -type f -exec grep -l "text-to-find-here" {} \;
Write "foo" to the real path of the current command's standard input </s> echo foo | readlink /proc/self/fd/1
Count all the lines of all files with names ending with 'php' in current directory recursively </s> find -name '*php' | xargs cat | wc -l
Find all regular files named postgis-2.0.0 under current directory </s> find . -type f -name "postgis-2.0.0"
Archive "/source" and all files under "folder/" to "/dstfolder/" on host "remoteserver" as user "user" without copying files that already exist </s> rsync -avz --ignore-existing /source folder/* user@remoteserver:/dstfolder/
Save the system load average for the past 1 minute of the currently logged in user to variable 'proc_load_average' </s> proc_load_average=$(w | head -1 | cut -d" " -f12 | cut -d"," -f1-2 | tr ',' '.')
Print a sorted list of unique directory paths in entire file system that match the pattern '<name_pattern>' in their names </s> find / -name '<name_pattern>' -type d | sort | uniq
Find all .svn directories under current directory and delete them </s> find . -type d -name ".svn" -print | xargs    rm -rf
search for all the regular/normal mp3 files in the file system and move them to the folder /mnt/mp3 </s> find / -iname "*.mp3" -type f -exec /bin/mv {} /mnt/mp3 \;
Archive "/home/abc/*" to "/mnt/windowsabc" with human readable output </s> rsync -avh /home/abc/* /mnt/windowsabc
Replace all matches with the regex expanded by $P_FROM with the text expanded by $P_TO in all regular files under current directory not going into subdirectories and modify the files in-place </s> find . -type f -maxdepth 1 -exec sed -i "s/$P_FROM/$P_TO/g" {} \;
Change permission to 000 of all directories named '.texturedata' under '/path/to/look/in/' directory tree </s> find /path/to/look/in/ -type d -name '.texturedata' -prune -print0 | xargs -0 chmod 000
Find all files/directories that start with 'readme' (case insensitive) in their names under '/usr/share/doc' directory tree </s> find /usr/share/doc -name '[Rr][Ee][Aa][Dd][Mm][Ee]*'
force remove all the text files that have not been modified in the last 89 days </s> find .  -name "*.txt" -type f -daystart -mtime +89 | xargs rm -f
Replace all newlines from standard input except the last with spaces </s> sed -e ':a' -e 'N' -e '$!ba' -e 's/\n/ /g'
Save first IP address of domain 'google.com' in 'address' variable </s> address=$(dig +short google.com | grep -E '^[0-9.]+$' | head -n 1)
Remove all regular files under $DIR directory tree that were accessed more than 5 days ago </s> find "$DIR" -type f -atime +5 -exec rm {} \;
Prints out all the logged-in users along with their group information. </s> groups $(who | cut -d' ' -f 1)
Search the regular files of the current directory tree for string "whatever" </s> find . -type f | xargs -L 100 grep whatever
Mount partition with label "WHITE" on "/mnt/WHITE" with read and write permission </s> mount -L WHITE /mnt/WHITE -o rw
Find all files whose owner is `user1' </s> find / -user user1
Find all files/directories under '/usr/share/data' directory tree that match the posix extended regex ".*/20140624.*" in their paths and save the list to '/home/user/txt-files/data-as-of-20140624.txt' </s> find /usr/share/data -regextype posix-extended -regex ".*/20140624.*" -fprint /home/user/txt-files/data-as-of-20140624.txt
Search the /usr/ directory tree for files newer than file /tmp/stamp </s> find /usr -newer /tmp/stamp
Find recursively regular files in the current directory tree </s> find . -type f -print
show the list of all the files in the current folder which have been modified within the 24 hours </s> find . -mtime 0 -print
Read a line from standard input into variable "ENTERED_PASSWORD" without echoing the input </s> read -s ENTERED_PASSWORD
Find all the files under /etc directory which are larger than 100k </s> find /etc -size +100k
Print first field from semicolon-seprated line $string. </s> echo $string | cut -d';' -f1
Print which files differ in "dir1" and "dir2" recursively </s> diff -qr dir1 dir2
Find all 100MB files in file system and delete them using rm command </s> find / -size +100M -exec rm -rf {} \;
Find all the Sticky Bit files whose permission are 551 </s> find / -perm 0551
Recursively finds all '*.pdf' files in a current folder and removes them without prompting. </s> find . -name '*.pdf' -exec rm -f {} \;
Print info about thread number of process with pid 1 </s> cat /proc/1/sched  | head -n 1
Write output of "ls -lR /" to standard output and to "output.file" </s> ls -lR / | tee output.file
Find all regular files in the current directory tree last modified between 1 and 3 days ago and list them using find's -ls option </s> find ./ -daystart -mtime -3 -type f  ! -mtime -1 -exec ls -ld {} \;
Search the current directory for all regular files executable by 'user', 'group', and 'others' </s> find . -maxdepth 1 -type f -perm -ugo=x
Remount "/system" as read only </s> mount -o remount,ro /system
Find all file in current directory with have .c extenstion & have 777 permission . delete then </s> find . -name "*.c" -a  -perm -777 | xargs rm -rf
Make directory "aaa/bbb" </s> mkdir aaa/bbb
Find all test1.h files under current directory </s> sudo find . -name test1.h
List all files in /home/bozo/projects directory tree that were modified exactly one day ago </s> find /home/bozo/projects -mtime 1
Search for all files with same inode NUM </s> find . -inum NUM
Save the canonical filename of "$BASH_SOURCE" in variable "me" </s> me=$(readlink --canonicalize --no-newline $BASH_SOURCE)
Search for 'birthday' (case insensitive) in all regular files under ~/Documents directory tree and show only the filenames </s> find ~/Documents -type f -print0 | xargs -0 grep -il birthday
Find any files in the current directory and its sub-directories that were last accessed more than 7 days or are larger than 20480 blocks in size. </s> find . -atime +7 -o -size +20480 -print
remove all the core files in the home folder </s> find /home -name core -exec rm {} \;
copy all the log files in the current folder which have not been accessed in the last 30*24 hours to the folder old </s> find . -type f -mtime +30 -name "*.log" -exec cp {} old \;
find all the xml files in the current folder which are present in the pattern text file </s> find . -name "*.xml" -exec grep -HFf <(find . -name "*.txt" -printf "%f\n") {} \;
Find all files/directories under /usr/tom which matches the extended regex '*.pl| *.pm'  in their names </s> find /usr/tom | egrep '*.pl| *.pm'
Change all file permissions to 664 and all directory permissions to 775 in directory tree "htdocs" </s> find htdocs -type f -exec chmod 664 {} + -o -type d -exec chmod 775 {} +
Find files owned by nonexistent groups </s> find / -nogroup -print
Print login name and full name of all users currently logged in and delete instances of "of group.*" </s> finger -l | awk '/^Login/' | sed 's/of group.*//g'
Print unique list of who is logged in and the time of login formatted in columns </s> who -su | sort | uniq | column
Do not mark variables and function which are modified or created for export to the environment of subsequent commands </s> set +a
display all the files in the current folder which have been modified in the last 24 hours </s> find . -mtime -1 -print
find all the files in the folder /usr/bin which have been modified in the last 10 days </s> find /usr/bin -type f -mtime -10
list complete path name to process associated with pid "$1" </s> find /proc/$1/exe -printf '%l\n'
Find in the current direcoty whose suffix is .tmp , find will not serach recursively limit of find is 2 subdirectory . </s> find .  -maxdepth 2 -name '*.tmp'
Pass a wildcard to scp by escaping it: copy all files with names starting with "files" in directory "/location" on host "server" to current directory on local machine, displaying debug info and preserving timestamps and permissions on copied files. </s> scp -vp me@server:/location/files\*
Search *.txt files under and below /directory/containing/files for "pattern_to_search" </s> find /directory/containing/files -type f -name "*.txt" -exec grep -H 'pattern_to_search' {} +
delete all files in $DIR that have not been accessed in at least 5 days </s> find "$DIR" -type f -atime +5 -exec rm {} \;
Look for *log files in directories at most three levels down the directory tree </s> find / -maxdepth 3  -name "*log"
recursively change owner of the directory ~/.npm to the current user </s> sudo chown -R $(whoami) ~/.npm
Saves number of lines of current directory listing in 'n_max' variable. </s> n_max=`ls . | wc -l`
Find all files/directories that contain the string literal '$VERSION' in their names under current directory tree </s> find . -name '*$VERSION*'
Find all files under current directory and print only the filenames (not paths) </s> find . -type f -printf "%f\n"
List ".java" files that have the same contents </s> md5sum *.java | sort | uniq -d -w32
Displays a tree of all process alongside their command line arguments. </s> pstree -a
Reread user's .profile configuration file. </s> source ~/.profile
Connect via ssh to "your.server.example.com" and recursively copy directory "/path/to/foo" on this host to direcotry "/home/user/Desktop" on local host, using "blowfish" cipher algorithm. </s> scp -c blowfish -r user@your.server.example.com:/path/to/foo /home/user/Desktop/
modify the permissions of all the folders in a directory </s> find /path/to/dir -type d -exec chmod 755 {} \;
Find all Executable files </s> find / -perm /a=x
Search for 'string-to-find' in all files under current directory tree and show the matched lines with their filenames </s> find . -exec grep -H string-to-find {} \;
Print the last file extension from standard input </s> sed 's/^/./' | rev | cut -d. -f1  | rev
display ten files in the current directory </s> find | head
Find files with a question mark in their names </s> find . -name \*\\?\*
display all files  expect directories in the current folder </s> find . ! — type d -print
Find files with name `aaa.txt' under the current directory </s> find . -name aaa.txt
find all the normal/regular files in the current folder which have been modified in the last day and display a long listing of them </s> find . -type f -mtime -1 -daystart -exec ls -l {} \;
Find all aliencoders.[0-9]+ files under /home/jassi/ directory </s> find /home/jassi/ -type f -name "aliencoders.[0-9]+"
search for the word "slrn" in all the files in the folder $HOME/html/andrews-corner </s> find $HOME/html/andrews-corner -exec grep -q 'slrn' '{}' \; -print
Creates temporary file in a TMPDIR folder with name like tmp.XXXXXXXXXX. </s> mktemp
display all directories in the entire file system </s> find / -type d -print
Find all files/directories named 'foo' in the entire filesystem </s> find / -name foo
Execute "ls -l" every 2 seconds and highlight the differences in runs </s> watch -d ls -l
Add "new." to the beginning of the name of "original.filename", renaming it to "new.original.filename". </s> rename 's/(.*)$/new.$1/' original.filename
search all the files in the current folder excluding those that are present in the folder test and using regex </s> find . -name test -prune -regex ".*/my.*p.$"
display all the text files from the current folder and skip searching in skipdir1 and skipdir2 folders </s> find . \( -name skipdir1 -prune , -name skipdir2 -prune -o -name "*.txt" \) -print
Print base name of the file name without all extensions. </s> basename "$FILE" | cut -d'.' -f-1
Search for 'String' case insensitively in all files under current directory tree and show the matched lines with their filenames </s> find . -name * -print0  | xargs -0 grep -iH "String"
print all files in the file system excluding those ending with ".c" </s> find / \! -name "*.c" -print
find all the files ending with ".foo" in the folder /usr </s> find /usr -name '*.foo' -print
find all the files in the current folder which do not have the read permission </s> find . -type f ! -perm -444
Replace all spaces with underscores in directory paths under current directory. </s> find -name "* *" -type d | rename 's/ /_/g'
Print numbers from 1 to 5 without separating spaces and without a newline </s> seq 5 | awk '{printf "%s", $0}'
Search directory tree $DIR for *.txt files </s> find $DIR -name "*.txt" -print
find all the normal/regular files in current folder and search for a pattern </s> find . -type f -print0 | xargs -0 grep pattern
Unzip and extract "*\(userAgent=[^=]*\) [^ =]\+=.*" from "input.gz" </s> zcat input.gz | sed -n 's/.*\(userAgent=[^=]*\) [^ =]\+=.*/\1/p'
delete all the trace files (".trc") from the folder $DBA/$ORACLE_SID/bdump/ which have not been accessed in the last 7*24 hours </s> find $DBA/$ORACLE_SID/bdump/*.trc -mtime +7 -exec rm {} \;
find all file name in curent directory ,  -exec will file all file output  awk used here for print only file name . </s> find .  -type f  -exec ls -lrt {} \; |awk -F' ' '{print $9}'
display all the files in the current folder excluding the directory aa </s> find . -type d ! -name aa
compare each C header file in or below the current directory with the file /tmp/master </s> find . -name '*.h' -execdir diff -u '{}' /tmp/master ';'
Remount "extX" filesystem "/dev/hdaX" on "/" without writing in "/etc/mtab" </s> mount -n -o remount -t extX /dev/hdaX /
Locate files with user permissions rwx owned by my_user </s> find . -user my_user -perm -u+rwx
Recursively changes group ownership of everything within a current directory to 'repogroup'. </s> chgrp -R repogroup .
Find all loadable modules for current kernel, whose name includes "perf" </s> find /lib/modules/`uname -r` -regex .*perf.*
Print name of the block device containing the file system containing $path. </s> df -P "$path" | awk 'BEGIN {FS="[ ]*[0-9]+%?[ ]+"}; NR==2 {print $1}'
find all the files in the current directory and sub-directories, that were edited within the last 1 hour and execute the list command with long listing format </s> find -mmin -60 -exec ls -l {} \;
find the type of all the regular/normal files in the current folder </s> find . -type f | xargs file
find all files in the file system having the name "filename" </s> find / -iname "filename"
Find all regular files with '.r' and '.c' in their names under current directory tree </s> find ./ -type f \( -name '*.r*' -o -name '*.c*' \) -print
Compress all files in the "$FILE" directory tree that were last modified 30 days ago </s> find $FILE -type f -mtime 30 -exec gzip {} \;
Find recursively the latest modified .zip file in the current directory </s> find . -name "*zip" -type f | xargs ls -ltr | tail -1
Remove all files whose names begin with "no-such-thing" in the /home/peter directory tree </s> find /home/peter -name no-such-thing* |xargs rm
Unzip "file.gz", list the unique first comma separated field prefixed by the number of occurrences, sort from least frequent to most frequent </s> zcat file.gz | cut -f1 -d, | sort | uniq -c | sort -n
Archive all files (not directories) in "folder1" to "copy_of_folder1" specifying to include files info.txt and data.zip </s> rsync -a -f"+ info.txt" -f"+ data.zip" -f'-! */' folder1/ copy_of_folder1/
display a list of all the normal/regular files in the file system ,excluding the folder proc which have the suid or sgid bit set </s> find / -path /proc -prune -o -type f -perm +6000 -ls
Find all directories under dir whose names are 33 characters long </s> find dir -name '?????????????????????????????????'
Create a symbolic link to "$file" named "/tmp/allfiles" </s> ln $file /tmp/allfiles
Remove all spaces from standard input </s> tr -d ' '
Print each line in "file", "file2", and "file3" and replace any tabs with spaces </s> paste file file2 file3 | sed 's/\t/ /'
Find all files under current directory and show their file information </s> find . -type f | xargs file
Find with combine multiple search criterias , in this command serach  files that begin with abc in there name and dont have .py extension . </s> find . -type f -name 'abc*' ! -name '*.py'
Display compter's hostname </s> echo `uname -a | awk '{print $2}'`
List first 20 files under current directory </s> find . -type f |xargs ls -lS |head -20
Print list of file systems currently mounted. </s> df -h |  awk '{print $1}'
search for al cpp files in current folder and replace all expect the parent directory name of these files and display it them sorted order </s> find . -name '*.cpp' | sed -e 's/\/[^/]*$//' | sort | uniq
Find all *.txt files/directories under current directory </s> find . -name "*.txt"
Number each line in "foobar" as right-justified zero padded to a width of 9 </s> nl -nrz -w9 foobar
Display a count of regular files in each directory at the current level. </s> find -P . -type f | rev | cut -d/ -f2- | rev | cut -d/ -f1-2 | cut -d/ -f2- | sort | uniq -c
Counts lines of myfile.txt file. </s> cat myfile.txt | wc -l
List the last entry of the numerically sorted list of all files and folders under "/foldername" </s> find /foldername | sort -n | tail -1
Print "deb-src http://ppa.launchpad.net/webupd8team/java/ubuntu precise main" and append to file "/etc/apt/sources.list" </s> echo "deb-src http://ppa.launchpad.net/webupd8team/java/ubuntu precise main" | tee -a /etc/apt/sources.list
Find all files in current directory excluding hidden files, archive them and put the output into variable  full_backup_dir </s> full_backup_dir="$(find . -depth \( -wholename \./\.\* \) -prune -o -print | cpio -oav)"
Find all the files in the current directory recursively whose permissions are 644 and show the first 10 of them </s> find . -perm 0644 | head
find al the files that are modified exactly 2 days ago </s> find -daystart -mtime 2
find all the files in the home folder which are less than 42 Bytes </s> find / -size 42
Repeat "image.png" 10 times on a single line </s> echo $(yes image.png | head -n10)
Output all lines in BigFile.csv whose secondn comma-separated second field matches first field of a line in LittleFile.csv. </s> join -1 2 -2 1 -t, BigFile.csv LittleFile.csv
Find all *.log files under path/ </s> find path/ -name "*.log"
Find all directories under /fss/fin </s> find /fss/fin -type d
Search the current directory and all subdirectories for files that have 777 permissions and the permissions to 755 </s> find . -type f -perm 777 -exec chmod 755 {} \;
delete all the log files which have not been modified in the last 5 days after user confirmation </s> find . — name "*.LOG" — mtime +5 -ok rm {} \;
Find all files/directories under /path/to/dir/* paths and print the timestamp in YmdHMS format along with their paths and object of symlinks </s> find /path/to/dir/* -printf "%TY%Tm%Td%TH%TM%TS|%p|%l\n"
search for soft links in current folder and display those links which are not pointed to files in current folder </s> find . -type l -exec readlink -f '{}' \; | grep -v "^`readlink -f ${PWD}`"
display all files in current folder in sorted order of depth </s> find folder1/ -type f -printf "%d\t%p\n" | sort -n | sed -e "s|[0-9]*\t||"
Print content of all files ending with '*.foo' under the current directory </s> cat $(find . -name '*.foo')
Force create a symbolic link named "id_rsa" to "$keyname" </s> ln -sf $keyname     id_rsa
Search the current directory tree for files AAA and BBB </s> find . \( -name AAA -o -name BBB \) -print
Append the current date in '%Y%m%d_%H%M' format with the basename of $0 and save it to variable 'LOGNAME' </s> LOGNAME="`basename "$0"`_`date "+%Y%m%d_%H%M"`"
Display a long listing of all regular files with 0777 permission under current directory tree </s> find . -perm 0777 -type f -exec ls -l {} \;
Creates temporary file in TMPDIR folder or /tmp/ if TMPDIR is not defined, named by template ${tempname}.XXXXXX, and saves path to new file in  a TMPPS_PREFIX variable. </s> TMPPS_PREFIX=$(mktemp "${TMPDIR:-/tmp/}${tempname}.XXXXXX")
Remove the files or directories 'bin/node', 'bin/node-waf', 'include/node', 'lib/node', 'lib/pkgconfig/nodejs.pc' and 'share/man/man1/node' with superuser privilege </s> sudo rm -rf bin/node bin/node-waf include/node lib/node lib/pkgconfig/nodejs.pc share/man/man1/node
Print each line in "f1" and "f2" separated by a space and "f3" separated by a tab </s> paste <(paste -d" " f1 f2) f3
List environment variables whose name contains "X" </s> set | cut -d= -f1 | grep X
use find -exec with multiple commands </s> find . -name "*.txt" -exec echo {} \; -exec grep banana {} \;
Print the sorted and unique parent directory paths appended with : of all the files that are executable by owner under ~/code directory without descending into hidden directories </s> find ~/code -name '.*' -prune -o -type f -a -perm /u+x -printf ':%h\n' | sort | uniq | tr -d '\n'
find  files which full path name is /tmpfoo/bar under /tmp/foo directory and print </s> find /tmp/foo -path /tmp/foo/bar -print /tmp/foo/bar
Find files in the current directory tree whose names are of the form "cxx_data.txt" where xx is a number from 40 to 70 </s> find . -regextype posix-egrep -regex "./c(([4-6][0-9])|70)_data.txt"
Create a copy of index.html in all directories in current directory, pausing for confirmation before overwriting any existing files - names may not contain spaces - names may not contain spaces. </s> find . -mindepth 1 -maxdepth 1 -type d| xargs -n 1 cp -i index.html
Return 0 if at least one "abc" file in the current directory tree contains text "xyz" </s> find . -name 'abc' -type f -exec grep -q xyz {} +
Find all files/directories  under  /eserver6 directory and follow symlinks if needed </s> find /eserver6 -L
Measure the disk space taken up by all *.txt files in directory tree /home/d </s> find /home/d -type f -name "*.txt" -printf "%s\n" | awk '{s+=$0}END{print "total: "s" bytes"}'
Set variable "architecture" to machine architecture, ie. x86_64 </s> architecture="$(uname -m)"
Get domain name with 'google' from address $IP </s> dig -x $IP | grep PTR | cut -d ' ' -f 2 | grep google | cut -f 5
Deletes empty folder 'nonsense_dir'. </s> rmdir nonsense_dir
Find all *.java files under current directory and replace every occurrences of 'subdomainA.example.com' with 'subdomainB.example.com' in those files </s> find /home/www -name "*.java" -type f -print0 | xargs -0 sed -i 's/subdomainA\.example\.com/subdomainB.example.com/g'
Print all files containing "word1" and "word2" in the current directory tree </s> comm -12 <(grep -rl word1 . | sort) <(grep -rl word2 . | sort)
list all the directories in the folder httpdocs </s> find httpdocs -type d
Print the ping time number only of a single request to "8.8.8.8" </s> ping -c 1 8.8.8.8 |  awk 'FNR == 2 { print $(NF-1) }' | cut -d'=' -f2
Find all files matching shell pattern "foo/bar" in the foo directory tree </s> find foo -path foo/bar -print
display long listing of all the text files in the current folder (plus at the end executes quickly by sending bulk data as input to the command in exec) </s> find . -name "*.txt" -exec ls -la {} +
Sort tab separated file "file" using a version sort for field 6 and a numeric sort for field 7 </s> sort -t$'\t' -k6V -k7n file
run ls command on files found </s> find . -name "*.pl" -exec ls -ld {} \;
change the group of all directories in the current folder </s> find . -type d -exec chgrp usergroup {} \;
Reverse the space separated words in "aaaa eeee bbbb ffff cccc" </s> echo "aaaa eeee bbbb ffff cccc"|tr ' ' '\n'|tac|tr '\n' ' '
Change the group of "myfile" to "friends" </s> chown :friends myfile
display all shell scripts in current folder </s> find . -name "*.sh"
Prints running process that has id 'pid' with command line arguments. </s> pstree -a pid
Run 'join' on file1 and file2, using a literal tab character as field separator. </s> join -t $'\t' file1 file2
search for a word in all the php files in the current folder and display the matching lines </s> find . -name \*.php -type f -exec grep -Hn '$test' {} \;
Find files in entire file system with at least 644 permissions </s> find / -perm -u+rw,g+r,o+r
Split "file.txt" into files of at most 1 MiB in size with a numeric suffix and prefix "file" </s> split -b 1M -d  file.txt file
Print the second space separated fields from standard input </s> tr -s ' ' | cut -d ' ' -f 2
display all files in the current folder ($@ contains the variables passed as argument to the function) </s> find . -iname "*$@*" -or -iname ".*$@*"
search for a word in all the shell scripts in the current folder and display the matched files. </s> find . -type f -name "*.sh" -exec grep -l landoflinux {} \;
Search the current directory tree for regular files whose names end in ".shtml" or ".css" </s> find . -type f \( -name "*.shtml" -or -name "*.css" \)
Silently and recursively change the ownership of all files in the current directory to "www-data" </s> sudo chown -Rf www-data *
Recursively copy /path/to/foo on host "your.server.example.com" to local directory "/home/user/Desktop", connecting as ssh username "user". </s> scp -r user@your.server.example.com:/path/to/foo /home/user/Desktop/
Find CSS files omitting results containing "CVS" </s> find . \! -path "*CVS*" -type f -name "*.css"
Find all files excluding files ending with 'gz', 'tmp' and 'xftp' in their names in the current directory tree and compress them with gzip not preserving timestamp and original name </s> find . -type f ! \( -name "*gz" -o -name "*tmp" -o -name "*xftp" \) -exec gzip -n '{}' \;
Set shell option 'histverify'. </s> shopt -s histverify
force delete all the directories the folder "test folder" </s> find 'Test Folder' -type d -print0 | xargs -0 rm -rf
Search for all the files in man pages and return the manual page for grep </s> find /usr/share/man/ -regex .*/grep*
Print numbers from 1 to 10 with 2 values per line </s> seq 10 | paste -sd" \n" -
Find all symbolic links under the current folder and below </s> find –L –xtype l
Search the files from the current directory tree for "foo" </s> find . -exec grep -l foo {} +
Find all directories under /home/me/target_dir_1 </s> find /home/me/target_dir_1 -type d
Change permissions of "mksdcard" to 755 </s> sudo chmod 755 mksdcard
Calculate the md5sum of each ".py" file under "/path/to/dir/", sort the output, and calculate the md5sum of that </s> find /path/to/dir/ -type f -name "*.py" -exec md5sum {} + | awk '{print $1}' | sort | md5sum
find files in the current directory and sub-directories, that changed within last hour </s> find . -cmin -60
Get a detailed listing of all symbolic links in /usr/bin starting with "z" </s> find /usr/bin  -type l  -name "z*" -exec ls  -l {} \;
find all the files in the current folder which end with "ext1" or "ext2" or "ext3" </s> find -E . -regex ".*ext1|.*ext2|.*ext3"
Forcibly create symlink named as '/cygdrive/c/Users/Mic/mypics' to the directory '/cygdrive/c/Users/Mic/Desktop/PENDING - Pics/' </s> ln -sf '/cygdrive/c/Users/Mic/Desktop/PENDING - Pics/' '/cygdrive/c/Users/Mic/mypics'
Recursively change the owner group of "/var/www" of to "www-data" </s> sudo chown -R www-data:www-data /var/www
Find all files in directory tree "dirname" </s> find dirname -exec echo found {} \;
Fix permissions for a group of files with given extension </s> find /usr/local -name "*.html" -type f -exec chmod 644 {} \;
Count number of occurences of "123" in the string "123 123 123" (ie. 3) </s> echo "123 123 123" | grep -o 123 | wc -l
Join lines in file "aa" with lines in file "bb" if the lines share a common first word </s> join <(sort aa) <(sort bb)
create directory log into home directory </s> mkdir ~/log
create a gzip of all the files in the current folder excluding the already gzipped files </s> gzip `find . \! -name '*.gz' -print`
Copy recursively "tata/" to "tata2/" and remove read, write, and execute permission for other </s> rsync -avz --chmod=o-rwx -p tata/ tata2/
Search the current directory tree for symlinks pointing at other symlinks </s> find . -type l -xtype l
Find files named 'core' in or below the directory /tmp and delete them </s> find /tmp -name core -type f -print0 | xargs -0 /bin/rm -f
search for the word "redeem reward" in all the regular/normal files in the current folder </s> find . -type f -exec grep -i “redeem reward” {} \; -print
display all the files in the current folder excluding those that are present in the folder "secret" </s> find . \( -name 'secret' -a -prune \) -o -print
find all the directories in the current folder which have been modified in 24 hours and move them to the folder  /path/to/target-dir </s> find . -type d -mtime -0 -print0 | xargs -0 mv -t /path/to/target-dir
Find all regular files in the current directory tree and count them </s> find -type f | wc -l
remove all the files in the folder "myfiiles" which have not been accessed in the last 30*24 hours </s> find /myfiles -atime +30 -exec rm {} ;
Delete all matches to the regex '^.*iframe bla bla bla.*$' in all the php files under current directory tree and modify the files in-place </s> find ./ -type f -name \*.php -exec sed -i ’s/^.*iframe bla bla bla.*$//g’ {} \;
replaces the second to last line of file </s> tac file | sed '2 s/,$//' | tac
find all the undo files in the current folder and display the toal lines, words, characters </s> find ./ -name *.undo | xargs wc
Set the system date to Sat May 11 06:00:00 IDT 2013 </s> sudo date --set="Sat May 11 06:00:00 IDT 2013"
Get the number of "use" statements in all PHP files, ordered </s> find . -type f -name "*.php" -exec grep --with-filename -c "^use " {} \; | sort -t ":" -k 2 -n -r
Open a ssh connection to user@host with X11 forwarding to run GUI programs </s> ssh user@host -X
Recursively change the owner to "user" and group to "www-data" of "yourprojectfoldername" </s> chown -R user:www-data yourprojectfoldername
search for the directory "config" in the current folder and change directory to the first instance of the search </s> cd $(find . -name config -type d | sed 1q)
Set environment variables using assignments are listed in '.env' file and run 'rails' command with defined environment </s> env $(cat .env | xargs) rails
change the owner and group of all the files in the folder  /usr/lpp/FINANCIALS </s> find /usr/lpp/FINANCIALS -print | xargs chown roger.staff
Find all hidden files starting from the directory given as variable $FOLDER </s> find $FOLDER -name ".*"
Find all empty directories under a certain path </s> find /tmp -type d -empty
Make directory "aaa" </s> mkdir aaa
Make directories "~/foo/bar/baz", "~/foo/bar/bif", and "~/foo/boo/bang" as needed </s> mkdir -p ~/foo/bar/baz ~/foo/bar/bif ~/foo/boo/bang
Create a symbolic link named "~/bin/subl" to "/Applications/Sublime Text 2.app/Contents/SharedSupport/bin/subl" </s> ln -s "/Applications/Sublime Text 2.app/Contents/SharedSupport/bin/subl" ~/bin/subl
Change permissions of all regular files in the ~/dir_data directory tree in accordance with mode `a-x,u+w' </s> find ~/dir_data -type f -exec chmod a-x,u+w {} \;
Add executable permission to "rr.sh" </s> chmod +x rr.sh
Find the total size of *.jpg files within the directory tree ./photos/john_doe </s> find ./photos/john_doe -type f -name '*.jpg' -exec du -ch {} + | grep total$
Delete all .svn files/directories under current directory </s> find . -name .svn | xargs rm -fr
Find all files/directories under current directory that match the case insensitive regex ./\(RT\|ED\).* and show several lines of output from the beginning </s> find . -iregex './\(RT\|ED\).*' | head
List all *fink* files/directories under current directory </s> find . -name "*fink*" |xargs ls -l
Find all files/directories with user id 120 under current directory tree </s> find . -uid 120 -print
Search the current directory for HTML files whose names begin with "a" </s> find . -maxdepth 1 -name a\*.html
Find files in the current directory excluding CVS, SVN, GIT repository files and all binary files. </s> find . -not \( -name .svn -prune -o -name .git -prune -o -name CVS -prune \) -type f -print0 | xargs -0 file -n | grep -v binary | cut -d ":" -f1
Find all *.rb (regular) files under current directory and count their line numbers </s> find . -name "*.rb" -type f -exec wc -l \{\} \;
Find all directories under ~/code and replace all newlines with : in the output then remove the last : </s> find ~/code -type d | tr '\n' ':' | sed 's/:$//'
Find all files with '.jpg' extension in the current directory ignoring sub-directories and archive them to a file named jpeg.tgz </s> find . -maxdepth 1 -iname "*.jpg" | xargs tar -czvf jpeg.tgz
find all ".flac" files in current folder starting with "cmn-" </s> find . -name 'cmn-*.flac'
search for all the .o files in the current directory which have permisssions 664 and print them. </s> find . -name *.o -perm 664 -print
Replace "foo" with "bar" in all files in the current directory tree except hidden ones </s> find . -type f -not -name “.*” -print | xargs sed -i ‘s/foo/bar/g’
Search the files from the current directory tree for "foo" </s> find . -exec grep -l foo {} \;
Find all files/directories that are newer than 'backup.tar.gz' by modification time </s> find . -newer  backup.tar.gz
find all the files in the folder Musica and display them in a single line null separated </s> find Música/* | egrep -Z \/\\. | xargs -0 echo
Find files in the current directory tree whose names are of the form "cxx_data.txt" where xx is a number from 30 to 70 </s> find . -regextype posix-egrep -regex '.\*c([3-6][0-9]|70).\*'
Split "/tmp/files" into files of at most 1000 lines each </s> split /tmp/files
Delete characters in columns 36 through 40 from the output of "finger" </s> finger |  cut --complement -c36-40
Print the files in the current directory as a list of comma separated values </s> ls -1 | tr '\n' ','
Display a binary file as a sequence of hex codes </s> od -t x1 file|cut -c8-
Remove all directories called "test" from the /path/to/dir directory tree </s> find /path/to/dir -name "test" -type d -exec rm -rf {} \;
Find a directory named 'project.images' case insensitively in the entire filesystem and show it in long listing format </s> find  / -type d -iname "project.images" -ls
List all regular files under current directory (not white space sage) </s> find . -type f -print | xargs -n 1
Search the current directory tree for files containing "bash" in their names </s> find . -name "*bash*" | xargs
Print amount of space available on the file system containg path to the current working directory human-readable. </s> df -Ph $PWD | tail -1 | awk '{ print $3}'
Search the current directory tree for files whose name is ".note", case insensitive </s> find . -iname '.note'
search for text files in the folders /home/hobbes/ /home/calvin/ </s> find /home/hobbes/ /home/calvin/ -name “*.txt”
Perform a white space safe search for all files/directories under current directory </s> find . -print0 | xargs -0
Find all instances of first column with unique rest of line, and output a count for each first column that found in unique lines. </s> sort file | uniq | cut -f1 -d' ' | uniq -c | rev
Copy directory hierarchy from the current working directory to "/path/to/backup/" </s> find . -type d -exec mkdir -p -- /path/to/backup/{} \;
Find all directories in maximum 2 levels down the /tmp/test directory </s> find /tmp/test/ -maxdepth 2 -mindepth 1 -type d
Ping all hosts in file "ips" twice </s> cat ips | xargs -i% ping -c 2 %
Replace "_" with newlines in "Testing\r_Tested" and display the named characters </s> echo -e "Testing\r_Tested" | awk -v RS="_" '{ print $0; }' | od -a
Print a list of JPG files residing in the current directory tree </s> find . -name “*.jpg”
Change permissions to 644 for all regular files in and below the current directory </s> find . -type f -print | sed -e 's/^/"/' -e 's/$/"/' | xargs chmod 644
Find all files/directories that are owned by user 'dave' under current user's home directory tree </s> find ~ -user dave -print
Unpack all *.gz archives in the current directory tree </s> find . -name '*.gz' -print0 | xargs -0 gunzip
Display the output of "ls" for an 80 character wide display </s> ls | column -c 80
Delete all ".DS_Store" files/directories under test directory </s> find test -name ".DS_Store" -delete
Display file.txt with lines numbered, and page interactively through the result. </s> cat -n file.txt | less
Search the CSS files found in the current directory tree for string "foo" </s> find . -name \*.css -print0 | xargs -0 grep -nH foo
find all the mp3 files in the home folder which have been modified today </s> find ~ -type f -mtime 0 -iname '*.mp3'
Make directory "/etc/cron.minute" </s> mkdir /etc/cron.minute
Print file type of command "gcc" </s> file -L `which gcc`
Gets state of shell option 'dotglob' and saves it in 'rest_cmd' variable. </s> rest_cmd=$(shopt -p dotglob)
find all the files in the current directory and sub-directories whose status was changed after /etc/fstab was modified </s> find -cnewer /etc/fstab
Search *.x files from the current directory tree for string "fred" </s> find . -name ‘*.x’ -print0 | xargs -0 grep fred
Find all directories under /home/username/tmp and set their permission to 770 </s> find /home/username/tmp -type d -exec chmod 770 {} +
Recursively archive "test/a/" to "test/dest" excluding "test/a/b/c/d" </s> rsync -nvraL test/a/ test/dest --exclude=/b/c/d
Make directory "/tmp/new" </s> mkdir /tmp/new
find all the cpp files in current folder </s> find -name "*.cpp"
Enables shell option 'progcomp'. </s> shopt -s progcomp
Generate a random 32 ASCII character password from /dev/urandom and save it to variable 'pass' </s> pass=$(LC_CTYPE=C < /dev/urandom tr -cd [:graph:] | tr -d '\n' | fold -w 32 | head -n 1)
Make directory "testExpress" </s> mkdir testExpress
find all the files which have been accessed after modifying the file /etc/hosts </s> find -anewer /etc/hosts
Find all files in the home directory tree that are owned by another user and change their ownership to the current user </s> find ~ ! -user $USER -exec sudo chown ${USER}:"{}" \;
The  command runs all the directories (-type d) found in the $LOGDIR directory wherein a file's data has been modified within the last 24 hours (-mtime +0) and compresses them (compress -r {}) to save disk space. </s> find $LOGDIR -type d -mtime +0 -exec compress -r {} \;
Find directories in /proc and show only those that doesn't match the regex '/proc/[0-9]*($|/)' </s> find /proc -type d | egrep -v '/proc/[0-9]*($|/)' | less
search for a word in all files in a directory </s> find /directory/containing/files -type f -print0 | xargs -0 grep "test to search"
Find all files in /home/kos and below whose names end in ".tmp" </s> find /home/kos -name *.tmp -print
Counts all business days in a current month. </s> cal -h | cut -c 4-17 | tail -n +3  | wc -w
Reports count of characters in the value of ${FOO_NO_WHITESPACE} variable as follows: "length(FOO_NO_WHITESPACE)==<counted number of characters>" </s> echo -e "length(FOO_NO_WHITESPACE)==$(echo -ne "${FOO_NO_WHITESPACE}" | wc -m)"
Create a tar file containing all the files in ~/Library folder that contain spaces in their names </s> find ~/Library -name '* *' -print0 | xargs -0 tar rf blah.tar
Lists all directories in the current folder. </s> ls -d ./*/
List all *.png files/directories under /home/kibab directory </s> find /home/kibab -name '*.png' -exec echo '{}' ';'
Search current directory for any directory named "config" and go to first match found. </s> cd "$(find . -name config -type d | sed 1q)"
find files having the extension "bam" in current directory </s> find . -name "*.bam"
Find files in the /travelphotos that are greater than 200k in size but do not have "2015" anywhere in the file name </s> find /travelphotos -type f -size +200k -not -iname "*2015*"
Find deb packages in the current directory recursively </s> find . -type f -and -iname "*.deb"
Search for $SEARCH in all regular files under $DIR directory tree and display the number of bytes of the matched output </s> find $DIR -type f -exec grep $SEARCH /dev/null {} \; | wc --bytes
Delete all empty directories under root </s> find root -type -d -empty -delete
Find a more recent version of httpd.conf file than /etc/apache-perl/httpd.conf in entire file system </s> find / -name httpd.conf -newer /etc/apache-perl/httpd.conf
Find all directories under ~/code excluding hidden directories and their subdirectories and replace all newlines with : in the output then remove the last : </s> find ~/code -type d | sed '/\/\\./d' | tr '\n' ':' | sed 's/:$//'
Hash hostnames in user's known hosts file. </s> ssh-keygen -Hf ~/.ssh/known_hosts
display all regular/normal files in the current folder which are not accessed in the last 7*24 hours </s> find . -type f -atime +7
Remove "\n" from "test1\ntest2\ntest3" and search for "test1.*test3" </s> echo -e "test1\ntest2\ntest3" |tr -d '\n' |grep "test1.*test3"
Join comma-separated information in 4 files </s> join -t, <(sort test.1) <(sort test.2) | join -t, - <(sort test.3) | join -t, - <(sort test.4)
Replace "foo" with "bar" in all files in the current directory tree </s> find . | xargs sed -i ‘s/foo/bar/g’
Strips last section from the path $pathname, and prints basename of the rest part. </s> echo $(basename $(dirname $pathname))
remove all the core files in the current directory </s> /bin/find -name "core" — exec rm {} \;
Format the contents of "[file]" in a neat table </s> column -t [file]
Prints folder path where $mystring file is located. </s> echo dirname: $(dirname $mystring)
Find all symbolic links under '/proc/$pid/fd' directory tree with name pattern '$save_path/sess_\*' and update their timestamps </s> find "/proc/$pid/fd" -ignore_readdir_race -lname "$save_path/sess_\*" -exec touch -c {}
search all files in the current folder which match the regular expression </s> find . -regex ".*/my.*p.$" -a -not -regex ".*test.*"
Search for the regex expaned by the variable $SEARCH in all regular files under $DIR directory tree </s> find "$DIR" -type f -exec grep "$SEARCH" {} \;
Write to standard error a trace for each command after it expands the command and before it executes it </s> set -x
Print the list of files and directories of the /etc directory </s> find /etc/. ! -name /etc/.
find all the files with the name september ( case insensitive ) </s> find -iname september
Remove all files that end with 'prefs copy' in their names under '/mnt/zip' directory tree </s> find /mnt/zip -name "*prefs copy" -print | xargs rm
Create a symbolic link named ".profile" to "git-stuff/home/profile" without dereferencing ".profile" </s> ln -sn git-stuff/home/profile .profile
Set the environment variable "DISPLAY" to the system host name followed by ":0 skype" </s> env DISPLAY=`hostname`:0 skype
List all *.bak files in the current directory tree </s> find  . -name '*.bak' -ls
Find all files in "/home/" which contain "string1", "string2" or the host name in its filename </s> find /home/ -type f -regextype posix-extended -regex ".*(string1|string2|$(hostname)).*"
Find all the files on the system that have been changed within the last hour </s> find / -cmin -60
Remove all files under /home/user/Maildir/.SPAM/cur </s> find /home/user/Maildir/.SPAM/cur -type f -exec rm '{}' +
Search the current directory recursively for regular files, skipping hidden files in the current directory </s> find * -type f -print
change the ownership of all the files in the file system from edwarda to earnestc </s> find / -user edwarda -exec chown earnestc "{}" \;
Get domain name from dig reverse lookup. </s> $dig -x 8.8.8.8 | grep  PTR | grep -o google.*
List non-hidden regular files in the current directory tree that were last modified more than 500 days ago </s> find . -type f -not -name '.*' -mtime +500 -exec ls {} \;
Find all files/directories named 'file' and print them with null character as the delimiter instead of newline </s> find -name file -print0
Display users who are currently logged in </s> finger | sed 's/^\([^ ]*\) *\([^ ]*\) *pts[^A-Z]*\([^(]*\).*/\2\t(\1)\t\3/'
exclude vendor and app/cache dir, and search name which suffixed with php </s> find . -name *.php -or -path "./vendor" -prune -or -path "./app/cache" -prune
Find files in $DIR_TO_CLEAN that are older than $DAYS_TO_SAVE days and print them with null character appended to their paths </s> find "${DIR_TO_CLEAN?}" -type f -mtime +${DAYS_TO_SAVE?} -print0
Find all files in the /myfiles directory tree following symbolic links </s> find -L /myfiles
Find all files/directories in entire file system that have  "write" bit set for either the owner, the group, or others </s> find / -perm /222
Infinitely write "1" with line numbers to the console and "/tmp/to" </s> yes 1 | nl | tee /tmp/to
Prints calendar of $month, $year, and redirects all output to the awk script 'cal.awk', with predefined variable 'day=$day'. </s> cal $month $year | awk -v day=$day -f cal.awk
Find '*prefs copy' files under /mnt/zip and delete them with confirmation prompt ensuring white space safety </s> find /mnt/zip -name "*prefs copy" -print0 | xargs    -0 -p /bin/rm
Find and remove all .core files </s> find / -name "*.core" -print -exec rm {} \;
Find all files/directories named 'vimrc' in the entire filesystem </s> find / -name vimrc
Show all previously typed shell commands, waiting for user interaction after each page of output. </s> history | more
Find all files that belong to user root </s> find / -user root
Search for files greater than 20MB under your home directory (/home/user) </s> find ~ -size +20M
Find all 'test' directories in the current directory tree </s> find -type d -a -name test
find all the files in the current folder whose name starts with 2 alphabets and ends with 2 digits. </s> find . — name "[a‑z][a‑z][0—9][0—9].txt" — print
Search the src/ directory recursively for .c and .h files </s> find src/ -name '*.[ch]'
Save absolute path of the script filename in variable "MY_PATH" </s> MY_PATH=$(readlink -f "$0")
Pushes to the dirs stack directory path of the current script, or current directory path if executed from bash shell. </s> pushd $(dirname $0)
Find all files in the current directory and its sub-directories that have been modified sometime in the last 24 hours. </s> find . -mtime -1 -prin
Remove trailing white spaces from all files under current directory ignoring directories wtih *.git* (case insensitive) in their paths and keep backups of the originals </s> find . -type f -not -iwholename '*.git*' -print0  | xargs -0 sed -i .bak -E "s/[[:space:]]*$//"
delete all the empty directories in the current folder </s> find . -type d -empty -exec rmdir {} \;
Recursively removes all files and folders named '.svn' in a current folder. </s> find . -name .svn -exec rm -rf {} +
move files accessed more than one day ago to directory TMP </s> find . -atime +1 -type f -exec mv {} TMP \; # mv files older then 1 day to dir TMP
Recursively copy everything in /source/path whose name doesn't begin with a period, to /destination/path, without overwriting existing files, and outputting a line for each file copied or skipped. </s> cp -Rvn /source/path/* /destination/path/
Move each of the 'm?' directories in current directory to another directory whose name is constituted by appending .mbox to each directory name and create a directory named Messages in this directory then move all *.emlx files into this directory </s> find . -name 'm?' -type d -exec mv '{}' '{}.mbox' ';' -exec mkdir '{}.mbox/Messages' ';' -exec sh -c 'mv {}.mbox/*.emlx {}.mbox/Messages' ';'
Remove all files containing 'sample' (case insensitive) in their names under '/home/user/Series' directory tree </s> /usr/bin/find /home/user/Series/ -iname "*sample*" -exec rm {} \;
copy the file header.shtml to each directory under dir1, dir2, dir3, or dir4 </s> find dir1 dir2 dir3 dir4 -type d -exec cp header.shtml {} \;
Find files recursively with extension "ext" </s> find . -name "*.ext"
Find files/directories that does not have write permssion for group </s> find /path ! -perm /g+w
Recursively change owner and group to "tomcat7" of "webapps", "temp", "logs", "work", and "conf" </s> chown -R tomcat7:tomcat7 webapps temp logs work conf
Make regular files from debian/fglrx-amdcccle/usr/lib/fglrx/bin/ executable for all </s> find debian/fglrx-amdcccle/usr/lib/fglrx/bin/ -type f | xargs chmod a+x
Print info about all mounted file systems </s> df
Copy all files in current directory that do not match */exlude-path/* in their paths to /destination/ preserving directory structure </s> find . -type f -not -path '*/exlude-path/*' -exec cp --parents '{}' '/destination/' \;
Search for 'ireg' in all PHP files under 'project' directory tree and show only the files that match </s> find project -name '*.php' -type f -print0 | xargs -0 grep -l ireg
delete all the log files in the current folder </s> find -name '*.log' -delete
Pushes directory path that saved in $line variable to the dirs stack, expanding symbol '~', if present, as home folder path. </s> pushd "${line/#\~/$HOME}";
Find all *conf* files recursively under current directory </s> find . -name *conf*
Login to "$HOST" and create file "$FILE_PATH" if it does not exist </s> ssh -q $HOST "[[ ! -f $FILE_PATH ]] && touch $FILE_PATH"
Cuts off last part from the path $dir, and deletes resulted folder if empty. </s> rmdir "$(dirname $dir)"
Search the current directory tree for symbolic links to files matching pattern '*test*' </s> find . -lname '*test*'
find all the hidden files in the temp folder </s> find /tmp -type f -name ".*"
display long listing of all the symbolic links in the current folder </s> find . -type l -exec ls -l {} \;
Search directory tree /srv/${x} for regular files accessed at least 10080 minutes ago, and remove those files </s> find /srv/${x} -mindepth 1 -type f -not -amin -10080 -exec rm {} \;
Print all files in the current directory as a comma separated list </s> ls -1 | paste -sd "," -
copy all the mp3 files from current folder to another folder </s> find . -name '*.mp3' -exec cp -a {} /path/to/copy/stuff/to \;
display all regular/normal files in current folder </s> find . -type f
change owner of the file file.sh to user root </s> $sudo chown root file.sh
Find all executable files under {} and reverse sort them </s> find {} -type f -depth 1 -perm +0111 | sort -r
List all *.txt files/directories under current directory </s> find . -name *.txt -exec ls {} \;
Remove duplicate phrases and keep the original order of lines in "$infile" </s> nl -w 8 "$infile" | sort -k2 -u | sort -n | cut -f2
find CSS files, omitting results containing "CVS" </s> find . \! -path "*CVS*" -type f -name "*.css"
Counts all non-blank lines in the $i file. </s> sed '/^\s*$/d' $i | wc -l ## skip blank lines
Find all *.mov (case insensitive) files under current directory and list their paths with their names </s> find . -iname "*.mov" -printf "%p %f\n"
Search the current directory recursively for regular files last accessed more than 2 days ago </s> find . type -f -atime +2
find all the pdf files in the current directory and display only the directory name in which the pdf file is present </s> find . -type f -name '*.pdf' |sed 's#\(.*\)/.*#\1#' |sort -u
Print unique lines of sorted file "a" and "b" and remove leading tabs </s> comm -3 a b | sed 's/^\t//'
Show all files that have not been accessed in the $HOME directory for 30 days or more </s> find $HOME -atime +30
Find all regular files starting from the current directory </s> find . -type f
display all the files in the home folder which end with ".xbm" </s> find ~ -name '*.xbm'
Find all regular files or symlinks in the entire file system </s> find / -mount -depth \( -type f -o -type l \) -print
Copy all files with '.png' (case insensitive) extension under '/home/mine' directory tree to '/home/mine/pngcoppies/' directory with new names constructed by prepending 'copy' in their names </s> find  /home/mine -iname "*.png" -printf "%P\n " | xargs  -I % -n1 cp %  /home/mine/pngcoppies/copy%
Search the system for the file 'myfile' ignoring permission denied errors </s> find . -name myfile |& grep -v 'Permission denied'
Remove trailing white spaces from all files under current directory ignoring .git and .svn directories </s> find . -not \( -name .svn -prune -o -name .git -prune \) -type f -exec sed -i "s/[[:space:]]*$//g" "{}" \;
Search for files that are at least 1.1GB </s> find / -size +1.1G
File 'mydatafile' has a number on each line, display the sum of these numbers rounded to lowest integer. </s> awk '{s+=$1} END {printf "%.0f", s}' mydatafile
change the group of all the files which belong to the user edwarda to pubs </s> find / -user edwarda -exec chgrp pubs "{}" \;
Get the sizes (and total size) of all files under dir1 directory </s> find dir1 ! -type d |xargs wc -c
Move all files excluding hidden files in "/path/subfolder/" to "/path/" </s> mv /path/subfolder/* /path/
Set trace prompt to print seconds.nanoseconds </s> PS4='+ $(date "+%s.%N")\011 '
list all files under the current directory called cookies.txt </s> find -name cookies.txt
Search for line number 111 in file "active_record.rb" </s> nl -ba  -nln  active_record.rb  | grep '^111 '
Locate all passwd files on the system </s> find / -name passwd
display the count of regular/normal files in the current folder do not search in sub directories </s> find . -maxdepth 1 -type f |wc -l
Finds recursion-related options of a 'grep' utility. </s> grep --help |grep recursive
List in detail all *.txt files in the current directory tree, omitting paths ./Movies/*, ./Downloads/*, and ./Music/* </s> find . -type f -name "*.txt" ! -path "./Movies/*" ! -path "./Downloads/*" ! -path "./Music/*" -ls
Go to /tmp directory. </s> cd /tmp
find all the empty in the current folder do not search in sub directories </s> find . -maxdepth 1 -type d -empty
find all the links in the current folder and following it to the pointed path </s> find -L /target -type l
Recursively change the owner and group of "/var/antoniod-data/" to "antoniod" </s> chown -R antoniod:antoniod /var/antoniod-data/
Remove all files and directories in the current directory by answering with "y" to all prompts </s> yes | /bin/rm -i *
Replace the first occurrence of "string1" on each line with "string2" in all regular files in the current directory tree </s> find ./ -type f -exec sed -i 's/string1/string2/' {} \;
Print common lines of files "file1", "file2", "file3", and "file4" </s> comm -12 <(comm -12 <(comm -12 <(sort file1) <(sort file2)) <(sort file3)) <(sort file4)
display all files in the current folder which end with extension "myfile" followed by one digit or two digits </s> find . -regextype sed -regex '.*myfile[0-9]\{1,2\}'
List all files matching regular expression '*foo*' in a human-readable form </s> find . -name '*foo*' -exec ls -lah {} \;
create directory saxon_docs </s> mkdir saxon_docs
Delete and count files in $DIR_TO_CLEAN that are older than $DAYS_TO_SAVE days </s> find "$DIR_TO_CLEAN" -type -f -mtime "+$DAYS_TO_SAVE" -exec rm {} \; -printf '.' | wc -c
Find all directories recursively starting from / and count them </s> find / -type d | wc -l
Prints top-ten list of most used utilities from history. </s> history | awk '{ print $2 }' | sort | uniq -c |sort -rn | head
Find all files under /path and below writable by `group' and `other' </s> find /path -perm -go+w
Change all cron jobs running "anm.sh" to be run every 10 minutes instead of 5 minutes. </s> crontab -l | sed '/anm\.sh/s#\/5#\/10#' | crontab -
Search for 'invalidTemplateName' in all regular files in directories/files taken from the glob pattern './online_admin/*/UTF-8/*' and show the matched lines with the filenames </s> find ./online_admin/*/UTF-8/* -type f -exec grep -H "invalidTemplateName" {} \;
Change the owner of all ".txt" files in directory tree "/mydir" to "root" </s> find /mydir -type f -name "*.txt" -execdir chown root {} ';'
Delete all regular files named 'FindCommandExamples.txt' under current directory tree </s> find . -type f -name "FindCommandExamples.txt" -exec rm -f {} \;
Print NS record for domain 'domain.' from 8.8.8.8 nameserver </s> dig @8.8.8.8 domain. ns
search  in root  ( / ) directory downwards all files which have less than 2 links. </s> find / -links -2 -print
find the file "myfile.txt" in the folder /home/user/myusername/ </s> find /home/user/myusername/ -name myfile.txt -print
display the list of all the files in the current directory which have been accssed in the last 500 days exluding hidden files </s> find . -type f \( ! -iname ".*" \) -mtime +500 -exec ls {} \;
Print the list of all files under the current directory and below </s> find .
Find the "param1" string in regular files under and below /var </s> find /var -type f  | xargs grep "param1"
Delete all HTML files under tree ~/mydir </s> find ~/mydir -iname '*.htm' -exec rm {} \;
find all the normal/regular files in /etc/sysconfig which have been accesses in the last 30 minutes </s> find /etc/sysconfig -amin -30 -type f
Remove the regular files from the current directory tree that are newer than /tmp/date.start but not newer than /tmp/date.end </s> find ./ -type f -newer /tmp/date.start ! -newer /tmp/date.end -exec rm {} \;
List the full path of each directory under the current working directory </s> tree -dfi "$(pwd)"
kill a number of background jobs </s> jobs -p | tail -n [number of jobs] | xargs kill
Find all strings matching pattern "^${KEY}${DELIMITER}" in $FILE file and print rest of string after $DELIMITER </s> cat "$FILE" | grep "^${KEY}${DELIMITER}" | cut -f2- -d"$DELIMITER"
Compress and display the gzip compression ratio of every file on the system that is greater than 100000 bytes and ends in ".log" </s> sudo find / -xdev -type f -size +100000 -name "*.log" -exec gzip -v {} \;
Sort the lines of the file 'temp.txt' and change it in-place </s> sort temp.txt -otemp.txt
delete all files in the home directory which ahve the name core in them </s> find ~/ -name 'core*' -exec rm {} \;
Check if content of all top-level *.txt files in the current directory contain only unique lines </s> cat *.txt | sort | sort -u -c
Delete all files with ' .o' extension in the entire filesystem </s> find project / src / -name "* .o" -exec rm -f {} \;
display all the files in the file system which belong to no group </s> find / -nogroup staff -print
find all files  that names are 'apt' and display detailed list </s> find  / -name "apt" -ls
Report available space on the file system containing /tmp in kilobytes. </s> df -k /tmp | tail -1 | tr -s ' ' | cut -d' ' -f4
Display differences between /destination/dir/1 and /destination/dir/2 excluding XML files. </s> diff /destination/dir/1 /destination/dir/2 -r -x *.xml
Execute 'echo -e "\tHello World"' every 2 seconds </s> watch 'echo -e "\tHello World"'
find all files in the home folder which have been modified between 72 and 96 hours before </s> find ~ -mtime 2 -mtime -4 -daystart
Find files in the current directory tree whose names match regular expression "^.*~$\|^.*#$" </s> find -regex "^.*~$\|^.*#$"
display all the ".mov" files in the current folder </s> find . -name "*.mov"
Saves exit statuses of piped commands in a system variable PIPESTATUS='([0]="0" [1]="1" [2]="0")' </s> true | false | true
Move *wp-admin/index.php files under /var/www/  to ./index_disabled </s> find /var/www/ -path '*wp-admin/index.php' -exec mv {} $(dirname {})/index_disabled
Display a long listing of all the regular files owned by the user 'bluher' in the entire filesystem </s> find / -type f -user bluher -exec ls -ls {}  \;
Creates temporary folder in TMPDIR (if defined) or in '/tmp/', and stores path to created folder in 'dir' variable. </s> dir=$(mktemp -d)
Changes group ownership of 'myprog' to 'groupb'. </s> chgrp groupb myprog
Find files/directories in entire file system with at least 644 permission </s> find / -perm -644
Find all the files in entire file system  which are accessed 50 days back </s> find / -atime 50
Replace all occurrences of edx (case insensitive) with gurukul in all *.css (case insensitive) files under ./cms/djangoapps/contentstore/views directory </s> find ./cms/djangoapps/contentstore/views -iname *.css | xargs sed -i s/[Ee][Dd][Xx]/gurukul/g
For each line in 'file', print "result = " followed by the line backwards. </s> awk '{print "result =",$0}' <(rev file)
Print the first line of every file matching pattern 'file?B' in the xargstest/ directory tree </s> find xargstest/ -name 'file?B' | sort | xargs head -n1
Find all files under current directory </s> find -type f
Save the latest modification time (in format "%T@ %t" of any file under "./$dir" to variable "timestamp" </s> timestamp=$(find ./$dir -type f -printf "%T@ %t\\n" | sort -nr -k 1,2 | head -n 1)
find all the files in the file system which have been modified in the last 60 minutes </s> find / -mmin -60
Delete all .svn subdirectories under current directory </s> rm -rf `find . -type d -name ".svn"`
Find all files with 644 permission and change the permission to 664 </s> find . -type f -perm 644 -exec chmod 664 {} \;
Find all files residing in /home/dm/Video or below that were last changed at least 10 days ago </s> find /home/dm/Video -mtime +10
Output two lines of "-tcp" </s> yes -- -tcp | head -n 2
List subdirectories in the current directory </s> find . -maxdepth 1 -type d -print0 | xargs -0 ls -d
Recursively changes group ownership of everything within a current folder to 'admin'. </s> chgrp -R admin *
search for a word in all the php files in the current folder and display the matching lines. </s> find . -name \*.php -type f -print0 | xargs -0 -n1 grep -Hn '$test'
Change all directories under "./storage/" to owner "apache" and group "laravel" </s> sudo find ./storage/ -type d -exec chown apache:laravel {} \;
Rename uppercase file or folder name $1 to lower case name </s> mv $1 `echo $1 | tr '[:upper:]' '[:lower:]'`
List all directories in maximum 1 level down the current directory </s> find . -maxdepth 1 -type d -exec ls -dlrt {} \;
Print "new.txt" with line numbers prepended and line 2 or any line containing "2" deleted </s> cat new.txt  | nl | sed  "/2/d"
Find *.c and *.h files under the current directory tree skipping hidden directories and files </s> find . \( -path '*/.*' -prune -o ! -name '.*' \) -a -name '*.[ch]'
find all files in the home folder which are modified in the last 2 days. </s> find ~ -type f -mtime -2
Show system information: kernel name, hostname, kernel release and version, machine architecture, processor type, hardware platform, and operating system type. </s> uname -a
find the file "httpd.log" in the folder /home/web-server/ ( case insensitive search ) </s> find /home/web-server/ -type f -iname httpd.log
find all the files in the current folder which have been accessed in the last 24 hours </s> find . -type f -atime 1
find all the png files in the current folder which begin with the word image </s> find . -name "image*.png"
Copy the entire "/lib" and "/usr" directory including symlinks from "pi@192.168.1.PI" to "$HOME/raspberrypi/rootfs" and delete files after the transfer </s> rsync -rl --delete-after --safe-links pi@192.168.1.PI:/{lib,usr} $HOME/raspberrypi/rootfs
Change permission to 000 of all directories named '.texturedata' under '/path/to/look/in/' directory tree </s> find /path/to/look/in/ -type d -name '.texturedata' -exec chmod 000 {} \; -prune
find all files in current folder which are bigger than 1 MB and move them to another folder after user confirmation </s> find . -size +1M -ok mv {} files \+
search for the file "process.txt" in the entire file system </s> find / -name "process.txt"
Find all files under current directory with their size and paths, reverse sort them numerically, then print the 2nd field (with space as the delimiter) of the first 4 entries </s> find -type f -printf "%s %p\n" | sort -nr | head -n 4 | cut -d ' ' -f 2
Find all *.java files under current directory containing the string 'String' </s> find . -name "*.java" -exec grep "String" {} \;
Find files that have a modification time of a day ago </s> find / -mtime 1
Print file size and user name with color support for each file in the current directory tree </s> tree -Csu
Find all the files whose name is tecmint.txt in the current directory </s> find . -name tecmint.txt
display all directories in current folder excluding those that are present in .git folder </s> find . -iregex '.*/.git/.*' -prune -o -type d -name 'CVS'
Find .rmv files in the ./root directory recursively and copy them to directory /copy/to/here </s> find root -name '*.rmv' -type f -exec cp --parents "{}" /copy/to/here \;
display all the "C" files in the current folder </s> find . -name "*.c"
Find all files/directories named Root under current directory and copy them to newRoot </s> find . -name Root | xargs cp newRoot
Delete all files under current directory tree with '.$1' extension where $1 expands as the first positional parameter </s> find . -name "*.$1" -exec rm {} \;
Find all .sh files in or below the current directory and move them to folder ~/back.scripts </s> find . -name "*.sh" -print0 | xargs -0 -I {} mv {} ~/back.scripts
create archive "backup.tar.gz" from /path/to/catalog </s> tar czfP backup.tar.gz /path/to/catalog
Find regular files under / that contain "stringtofind" </s> find / -maxdepth 1 -xdev -type f  -exec grep -li stringtofind '{}' \;
Search for "1234567890" in every gzip file modified between 8:00 and 9:00 on 2014-04-30 </s> find . -newermt '2014-04-30 08:00:00' -not -newermt '2014-04-30 09:00:00' |xargs gunzip -c | grep 1234567890
Page through the contents of file 'file_name', positioning the view at the first occurrence of regular expression 'regex'. </s> less -p regex file_name
find all text files in the current directory and display them page wise </s> find . -name "*.txt" -print
Print string "123" once with '1' replaced by 'a' and second time replaced by 'b' </s> echo 123 | tee >(tr 1 a)  | tr 1 b
Force create a symbolic link without dereferencing named "$SYMLINK_PATH" to "$lastModified" </s> ln -nsf $lastModified $SYMLINK_PATH
Search the current directory tree for *bash* files </s> find . -name "*bash*"
Find all files/directories under whatever and ... directory and copy them to /var/tmp </s> find whatever ... | xargs -d "\n" cp -t /var/tmp
find all files that are readable or writable by their owner </s> find . -perm +600 -print
Display the named characters in "Test\rTesting\r\nTester\rTested" </s> echo -e "Test\rTesting\r\nTester\rTested" | awk '{ print $0; }' | od -a
Find all files in the current directory tree whose names are ".DS_STORE" and delete them </s> find . -name ".DS_STORE" -delete
Read a line from standard input with prompt "Are you alright? (y/n) " and save the response to variable "RESP" </s> read -p "Are you alright? (y/n) " RESP
Lists the pids of all processes that have process '1782' as their parent. </s> pstree -p 1782 | sed 's/-/\n/g' | sed -n -e 's/.*(\([0-9]\+\)).*/\1/p'
search all jpg images in current folder and rename them </s> find . -type f -name "*.jpg" -print0 | xargs -0 rename "s/Image_200x200_(\d{3})/img/"
Find all files/directories with space in their names under current directory </s> find . -name '* *'
Print content of /etc/passwd and /etc/group files </s> cat /etc/passwd /etc/group
find all the file which name end with c or h and content contain 'thing' </s> find . -name '*.[ch]' | xargs grep -l thing
Find directories in the current directory tree whose names are 33 characters in length </s> find . -type d -name "?????????????????????????????????"
display all the text files and pdf files in the current folder </s> find . \( -name "*.txt" -o -name "*.pdf" \)
Search level 3 of the current directory tree for the directories whose pathnames contain "New Parts" </s> find -mindepth 3 -maxdepth 3 -type d | grep "New Parts"
start from current directory, skip the directory src/emacs and all files and directories under it, and print the names of the other files found </s> find . -wholename './src/emacs' -prune -o -print
Use 'less' to nicely display control characters from the outupt of 'grep'. </s> grep -b -o $'\x0c' filename | less
prints first line of $bigfile </s> head -n1 $bigfile
show all files in the current directory and all subdirectories </s> find .
Extract any line in "f1" or "f2" which does not appear in the other </s> comm -3 <(sort -un f1) <(sort -un f2)
find StringBuffer in all *.java files </s> find . -type f -name "*.java" -exec grep -l StringBuffer {} \;
List all files under current directory that are greater than 10MB in size </s> find . -size +10M -exec ls -ld {} \;
Calculate the md5 sum of all files in the current directory and formatting the output by removing parenthesis </s> find -maxdepth 1 -type f -exec md5sum {} \; | sed 's/[^(]*(\([^)]*\)) =/\1/'
Print the IP addresses for the current host name </s> hostname  -I | awk -F" " '{print $1}'
Update timestamps of all files and directories under current directory. </s> find . -print0 | xargs -0 touch
Find and remove multiple files such as *.mp3 or *.txt under current directory </s> find . -type f -name "*.txt" -exec rm -f {} \;
find all the html files that are acces in the last 24 hours in the current folder </s> find . -mtime 1 -name "*.html" -print
Search for 'example' in all regular files from the current directory tree </s> find -type f -print0 | xargs -r0 grep -F 'example'
Find all files under $musicdir directory </s> find "$musicdir" -type f -print
find all regular files under the /etc/sysconfig directory that were accessed in the last 30 minutes </s> find /etc/sysconfig -amin -30 -type f
Find all files under the current directory and copy their permissions to the same file in "../version1" </s> find . -type f | xargs -I {} chmod --reference {} ../version1/{}
Merge each line of standard input into a single comma separated line </s> paste -s -d","
Read a line from standard input into variable "password" without echoing the input and using the prompt "Password: " </s> read -s -p "Password: " password
Rename the *.so files at level 2 of the current directory tree prepending their names with "lib" </s> find . -mindepth 2 -maxdepth 2 -name "*.so" -printf "mv '%h/%f' '%h/lib%f'\n" | sh
display all files in current folder with NULL separating each file </s> find . -print0
Search the current directory tree for .rb files ignoring the "./vendor" subdirectory </s> find . -name '*.rb' ! -wholename "./vendor/*" -print
Creates temporary folder and saves path to it in 'td' variable. </s> td=$( mktemp -d )
find all the perl files in the current folder, print0 is used to handle files with new lines in their names or only spaces </s> find . -type f -name "*.pl" -print0
Search the current directory tree recursively for the regular file named "myfile" ignoring "work" and "home" directories </s> find .  \( -name work -o -name home \)  -prune -o -name myfile -type f -print
Print position number of day '9' in fourth line of calendar output for September, 2009. </s> cal 09 2009 | awk 'NR==4{day="9"; col=index($0,day); print col }'
Replace all '置換前' with '置換後' in all regular files under current directory tree and modify them in-place </s> sudo find . -type f -exec sed -i 's/置換前/置換後/g' {} \;
Search for 'pattern' in all files with '.cc' extension under current directory tree and show the matched lines with line numbers and filenames </s> find . -name “*.cc” |xargs grep -n “pattern”
find directory which name is Cookbook under /users/al </s> find /users/al -name Cookbook -type d
Search the system for the file “testfile.txt” </s> find / -name "testfile.txt"
Print 1 byte from "/dev/urandom" as a signed decimal value and no address radix </s> od -A n -t d -N 1 /dev/urandom
Split "your_file" into files with at most 9 lines each </s> split -l9 your_file
Find all directories under current directory and make them read, write, and executable for owner & group and remove read-write-execute permission for other </s> find . -type d -name files -exec chmod ug+rwx,o-rwx {} \;
Print the file sizes along with their paths for all *.txt (case insensitive) files/directories under current directory tree </s> find . -name "*.txt" -print0 |xargs -0 du -ch
Print file system disk space usage with sizes in powers of 1000 </s> a=$( df -H )
Search for files containing string "PENDWIDTH" and view the result using the more command </s> find . -exec grep PENWIDTH {} \; | more
Sends current job to the background. </s> bg
Delete all regular files with '.txt' extension that were modified in more than 25 minutes ago in maximum 1 level down the directory '/home/u20806/public_html' </s> find /home/u20806/public_html -maxdepth 1 -mmin +25 -type f -name "*.txt" -delete
Find all files in the directory $directory or below with the permissions specificed by $permissions. </s> find "$directory" -perm "$permissions"
find all directories that names are 'project.images' </s> find  / -type d -name "project.images"
Find all *.htm files under current directory and print the changed names by appending 3 levels of parent directory names at the beginning and modifying the actual name to dd-nnn format </s> find -type f -name "*.htm" | sed 's@^./@@g;s@/@-@g' | awk -F'-' '{print $1 "-" $2 "-" $3 "-" substr($4, 5, 2) "-" $5}'
Print each line in "file1" and file2" separated by a space </s> paste -d'¤' file1 file2 | sed 's,¤, ,g'
Print 'infile' content with line numbers </s> cat -n infile
display all the files in the home folder which have read permission to the user </s> find /home -perm /u=r
Write "Some console and log file message" to standard output and "/dev/fd/3" </s> echo "Some console and log file message" | tee /dev/fd/3
Archive all files specified on standard input under "/path/to/files" to "/path" on host "targethost" as user "user" with escalated privileges </s> rsync -av --files-from=- --rsync-path="sudo rsync" /path/to/files user@targethost:/path
Display a detailed listing of the current directory, pausing for user input after each page. </s> ls -l | more
display a long list of all the directories which have files ending with ".todo" </s> find "$STORAGEFOLDER" -name .todo -printf '%h\n' | uniq | xargs ls -l
find all the files in the current folder which have been modified after the file disk.log </s> find . -newer disk.log -print
create a md5sum for all the instances of the file MyCProgram.c in current folder </s> find -iname "MyCProgram.c" -exec md5sum {} \;
Find files that don’t have 644 permissions </s> find / -type f ! -perm 644
Print which files differ between "dir1/" and "dir2/" </s> diff --brief -r dir1/ dir2/
Find the largest original ".gz" file in the current directory tree </s> find . -name '*.gz' | xargs gzip -l | tail -n +2 | head -n -1 | sort -k 2 | tail -n 1 | awk '{print $NF}'
display all normal/regular files in the folder "pathfolder" </s> find pathfolder -type f
find files in the home folder which have been modified in the last day. ( -daystart measures times from the beginning of today rather than from 24 hours ago.) </s> find ~/ -daystart -type f -mtime 1
List all files in a current folder, separating names with semicolon </s> ls -m | tr -d ' ' | tr ',' ';'
Search for the case insensitive regex expanded by $2 in all files named $1 (to be expanded) under current directory </s> find . -name "$1" -type f -print0 | xargs -0 grep -i "$2"
Find all files in the current directory tree that are newer than some_file </s> find . -newer some_file
Removes all files but $1 newest ones from current folder. </s> ls -tp | grep -v '/' | tail -n +"$1" | xargs -I {} rm -- {}
Find all *FooBar* files/directories under current directory and copy them to ~/foo/bar </s> find . -name '*FooBar*' -exec cp -t ~/foobar -- {} +
search all the lines that start with the word malloc in the files ending with .c or .h or .ch </s> grep ^malloc `find src/ -name '*.[ch]'`
wait 2 seconds and then print "hello" </s> echo "hello `sleep 2 &`"
Compress from standard input with gzip </s> gzip
Find all *.txt files under /foo and print their total size </s> find /foo -name "*.txt" -exec du -hc {} + | tail -n1
Find all files and directories whose names end in ".rpm", ignoring removable media, such as cdrom, floppy, etc. </s> find / -xdev -name \*.rpm
Print unique lines of sorted file "file1" when compared with the list of first space separated fields of all sorted strings of file "file2" </s> cut -d' ' -f1 file2 | comm -13 - file1
search files in the folder /home which have been modified after /tmp/after and before /tmp/before </s> find /home/ -type f -newer /tmp/after -not -newer /tmp/before
Removes all files like 'A*.pdf' from current folder without prompting. </s> rm -f A*.pdf
print all filenames of files under current dir containing 'foo', case-insensitive </s> find . -type f -exec grep -il 'foo' {} \;
Prints sizes of all top-level folders in a current folder with human-readable format and descending order. </s> du -h --max-depth=1 . | sort -n -r
Set the value of "to_sort" to "$1" in a subshell which no longer exists after the pipeline completes </s> echo "$1"| read -a to_sort
Find files whose pathnames contain "string" and print these pathnames replacing 'search string' with 'new string' </s> find . |xargs grep search string | sed 's/search string/new string/g'
Find *2011* files and grep for the string 'From: Ralph' in those files </s> find . -name '*2011*' -print | xargs -n2 grep 'From: Ralph'
Set permissions to 2770 for all directories in the current directory tree </s> find . -type d -exec chmod 2770 {} +
Print the lines in "table.txt" grouped by the first field </s> cat table.txt | awk '{print $1}' | sort | uniq  | xargs -i grep {} table.txt
Get current directory name without full path, ie. the part after the last / </s> basename "$(pwd)"
Find the total size of *.jpg files within the current directory tree </s> find . -type f -iname '*.jpg' -print0 | du -c --files0-from=-
Count the number of files in the /usr/ports directory tree whose names begin with 'pkg-plist' and which contain 'unexec.rmdir%D' </s> find /usr/ports/ -name pkg-plist\* -exec grep 'unexec.rmdir %D' '{}' '+' | wc -l
Remove trailing white spaces from all files under dir directory ensuring white space safety in the filename </s> find dir -type f -print0 | xargs -r0 sed -i 's/ *$//'
Clear the in-memory history </s> history -c
Print host name without a newline </s> echo -n `hostname`
display all the hidden files in the directory "/dir/to/search/" </s> find /dir/to/search/ -name ".*" -print
Print every file's type, name, and inode </s> find -printf "%y %i %prn"
Find out if there are any files on the system owned by user `account' </s> find / -path /proc -prune -o -user account -ls
Save absolute path of "$path" that must exist along with all parents to variable "abspath" </s> abspath=$(readlink -e $path)
Unzip and untar "openssl-fips-2.0.1.tar.gz" </s> gunzip -c openssl-fips-2.0.1.tar.gz | tar xf ­-
Find all *.java files under current directory containing the string 'String' </s> find . -name "*.java" -exec grep "String" {} \+
Print position number of day '9' in fourth line of calendar output for September, 2009. </s> cal 09 2009 | awk 'BEGIN{day="9"}; NR==4 {col=index($0,day); print col }'
Print the full name of "$USER" </s> finger $USER |head -n1 |cut -d : -f3
Print yesterday's date as yyy:mm:dd </s> date +%Y:%m:%d -d "yesterday"
Find all directories in level 1 down the $queue directory </s> echo "$queue" | xargs -I'{}' find {} -mindepth 1 -maxdepth 1 -type d
display all the ip addresses in all the files that are present in /etc folder </s> find /etc -type f -exec cat '{}' \; | tr -c '.[:digit:]' '\n' | grep '^[^.][^.]*\.[^.][^.]*\.[^.][^.]*\.[^.][^.]*$'
List the files/directories under /PATH_to_SEARCH, do a numeric sort and print the ones with different inode numbers </s> find /PATH_to_SEARCH -ls | sort -n | awk '!seen[$1]++'
Search the current directory tree for .rb files ignoring .vendor directories </s> find . -name .vendor -prune -o -name '*.rb' -print
show all the regular/normal files in the folder /home/user/demo </s> find /home/user/demo -type f -print
Find all your text files </s> find . -name "*.txt" -print
Locate all OGG files that reside in the home directory and have not been accessed in the past 30 days </s> find $HOME -iname '*.ogg' -atime +30
display a long list of all the jpg files in the home folder(plus at the end is used to give bulk data as input) </s> find ~ -iname '*.jpg' -exec ls {} +
search for the word "foo" in all the regular/normal files in the directory "/path/to/dir" </s> find /path/to/dir -type f -print0 | xargs -0 grep -l "foo"
Print common files of directory "1" and "2" </s> comm -12  <(ls 1) <(ls 2)
display list of all the files in the /tmp folder </s> find /tmp/ -exec ls "{}" +
display the version of find command </s> find -version
find all the files in the filesystem which do not belong to any group </s> find / -nogroup -print
Find all directories under var/ directory and change their permission to 700 </s> find var/ -type d -exec chmod 700 {} \;
Print a colon-separated list of all directories from the ~/code directory tree, except hidden ones and those below them </s> find ~/code -name '.*' -prune -o -type d -printf ':%p'
Find files in the "dir" directory tree whose names are 33 characters in length </s> find dir -name '?????????????????????????????????'
Find all regular files residing in the current directory tree and search them for string "/bin/ksh" </s> find . -type f -print | xargs grep -i 'bin/ksh'
Print which files differ in "dir_one" and "dir_two" recursively and sort the output </s> diff -qr dir_one dir_two | sort
find all the php files in current folder and search for multiple patterns in these files and display the file names </s> find -name '*.php' -exec grep -in "fincken" {} + | grep TODO | cut -d: -f1 | uniq
Read a line from standard input into variable "REPLY" with prompt "> $line (Press Enter to continue)" </s> read -p "> $line (Press Enter to continue)"
Force pseudo tty allocation on connection to "somehost" and execute "~/bashplay/f" </s> ssh -t somehost ~/bashplay/f
Find all files/directories in level $i down the current directory with all positional parameters appended with the find command </s> find -mindepth $i -maxdepth $i "$@"
archive all files in a current directory modified in the last 30 days </s> tar czvf mytarfile.tgz `find . -mtime -30`
Find directories in the current directory recursively that are not "executable" by all </s> find -type d ! -perm -111
Find all files/directories named 'photo?.jpg' under current directory tree </s> find . -name photo\?.jpg
Print absolute path of java executable </s> readlink -f $(which java)
Recursively find the latest modified file in the current directory </s> find . -type f -print0|xargs -0 ls -drt|tail -n 1
change the permissions of al the directories in the current folder </s> sudo find . -type d -exec chmod 755 {} +
Decompress "/file/address/file.tar.gz" to standard output </s> gzip -dc /file/address/file.tar.gz
List all .c and .h files in the current directory tree that contain "thing" </s> find . -name '*.[ch]' | xargs grep -l thing
Filters out strings, using the extended regexp pattern '^#|^$|no crontab for|cannot use this program' from "$USERTAB" </s> echo "$USERTAB"| grep -vE '^#|^$|no crontab for|cannot use this program'
Perform a case insensitive search for *filename* files/directories under current directory tree </s> find . -iname "*filename*"
Search the /etc directory tree for files accessed within the last 24 hours </s> find /etc -atime -1
Request IP address of 'myip.opendns.com' from name server 'resolver1.opendns.com' </s> dig +short myip.opendns.com @resolver1.opendns.com
Find all 664 permission files/drectories under current directory tree </s> find . -perm -664
Find all php files under current directory </s> find . -type f -name "*.php"
Calculate md5 sum of file $item and save it to variable 'md5' </s> md5=$(md5sum $item | cut -f1 -d\ )
Delete all files with inode number 804180 </s> find -inum 804180 -exec rm {} \
Recursively change owner to "amzadm" and group to "root" of all files in "/usr/lib/python2.6/site-packages/awscli/" </s> chown amzadm.root -R /usr/lib/python2.6/site-packages/awscli/
display list of all the hidden directories in the directory "/dir/to/search/" </s> find /dir/to/search/ -type d -iname ".*" -ls
Join columns in "file1" and "file2" if their first field matches and format the output as a table </s> awk 'NR==FNR{m[$1]=$2" "$3; next} {print $0, m[$1]}' file2 file1 | column -t
Find all files in the /home/ directory tree that were last modified less than 7 days ago </s> find /home -mtime -7
Find all directories recursively starting from / and skipping the contents of /proc/, and count them </s> find / -path /proc -prune -o -type d | wc -l
Print a list of regular files from directory tree sort_test/ sorted with LC_COLLATE=en_US.UTF-8 </s> find sort_test -type f | env -i LC_COLLATE=en_US.UTF-8 sort
Rename "file001abc.txt" to "abc1.txt" </s> mv file001abc.txt abc1.txt
delete all the "wmv" "wma" files in the currnet folder, </s> find . \( -name '*.wmv' -o -name '*.wma' \) -exec rm {} \;
Find all files/directories that contain 'target' (case insensitive) in their names under current directory no-recursively </s> find -maxdepth 1 -iname "*target*"
Search the /home/test directory tree for directories and files called '.ssh' </s> find /home/test -name '.ssh'
Find PHP files with abstract classes </s> find . -type f -name "*.php" -exec grep --with-filename -c "^abstract class " {} \; | grep ":[^0]"
Find all files named "filename" </s> find -name "filename"
Use the output of "ping google.com" as input to awk script "packet_loss.awk" </s> ping google.com | awk -f packet_loss.awk
Create a symbolic link named "/usr/bin/my-editor" to "/usr/share/my-editor/my-editor-executable" and attemp to hard link directories </s> ln -sF /usr/share/my-editor/my-editor-executable   /usr/bin/my-editor
Print yesterday's date </s> date -j -v-1d
Print the top 10 commands with their use count </s> history | awk '{print $2}' | awk 'BEGIN {FS="|"}{print $1}' | sort | uniq -c | sort -nr | head
List environment variable values whose name matches '^\w*X\w*' </s> set | grep -P '^\w*X\w*(?==)' | grep -oP '(?<==).*'
Find all files/directories named 'file1' under current directory tree </s> find . -name file1 -print
find all the directories in current folder and delete them </s> find . -type d -delete
change the permissions of all the regular/normal files to 644 in the folder /home/nobody/public_html </s> find /home/nobody/public_html -type f -exec chmod 644 {} \;
Overwrites file $FILE with random content, then truncates and deletes it. </s> shred -u $FILE
Find all the files which were accessed 50 days ago </s> find / -atime 50
Search for "facebook\|xing\|linkedin\|googleplus" in "access-log.txt" and print a count of the unique entries </s> grep -ioh "facebook\|xing\|linkedin\|googleplus" access-log.txt | sort | uniq -c | sort -n
create a symbolic link in current directory named "environments" to file "../config/environments" </s> ln -s "../config/environments"
search for files in the current folder using name patterns </s> find . -name '[mM][yY][fF][iI][lL][eE]*'
Delete all regular files named 'FILE-TO-FIND' under current directory tree </s> find . -type f -name "FILE-TO-FIND" -exec rm -f {} \;
Save the current date to 'DATE' variable </s> DATE=$(echo `date`)
Extracts a bz2 file. </s> bunzip2 file.bz2
find all the files in the current folder which are readable </s> find . -readable
Find all directories containing 'linux' in their names under '/root' directory tree </s> find  /root -type d -iname "*linux*"
Print a sorted list of the extensions of the regular files from the current directory tree </s> find . -type f | grep -o -E '\.[^\.]+$' | sort -u
Find files with extension .conf in the /etc directory tree </s> find /etc -name "*.conf"
Make a directory in the current working directory with a random 32 alphanumeric character name </s> cat /dev/urandom | tr -dc 'a-zA-Z0-9' | fold -w 32 | head -n 1 | xargs mkdir
Shows state of 'globstar' shell option. </s> shopt globstar
Read a line of standard input into variable "_command" with the prompt as the current working directory followed by "$" </s> read -p "`pwd -P`\$ " _command
Find files/directories under '/usr' directory tree that are newer than /tmp/stamp$$ by modification time </s> find /usr -newer /tmp/stamp$$
Find all *$VERSION* files/directories under current directory where $VERSION is a variable </s> find . -name "*$VERSION*"
search for the file "process.txt" in the current folder (case insensitive search) </s> find . -iname 'process.txt' -print
Print a single line of numbers from "001" to "010" </s> yes | head -n 10 | awk '{printf( "%03d ", NR )}'    ##for 01..10
Find files whose pathnames end in "f" </s> find .  -path '*f'
Get current directory name without full path, ie. the part after the last / </s> pwd | awk -F / '{print $NF}'
Replace all spaces with underscores in file paths under current directory. </s> find -name "* *" -type f | rename 's/ /_/g'
Find all files/directories with name pattern $nombre that are at most 2 levels down the $DIR_TEMPORAL and $DIR_DESCARGA directories and show only the file names (without parent path) appended with '.torrent' </s> find "$DIR_TEMPORAL" "$DIR_DESCARGA" -maxdepth 2 -name "$nombre" -printf '%f.torrent\n'
Search for 'keyword' in all javascript files under current directory tree excluding all paths that includes the directory 'node_modules' </s> find ./ -not -path "*/node_modules/*" -name "*.js" | xargs grep keyword
Delete all empty directories under test directory </s> find test -depth -type d -empty -delete
Find all .gz archives in the current directory tree </s> find . -name '*.gz'
Print content of 'domains.txt' with removed first one of dot-delimited fields </s> rev domains.txt | cut -d '.' -f 2- | rev
Insert "insert" every 3 lines for the output of "seq 1 10" </s> seq 1 10 | sed $': loop; n; n; a insert\nn; b loop'
Delete the oldest file with '.tgz' or '.gz' extension under '/home/backups' directory tree </s> ls -tr $(find /home/backups -name '*.gz' -o -name '*.tgz')|head -1|xargs rm -f
Find all $1 files/directories under current directory and enter into the parent directory of the first one found </s> cd $(dirname $(find . -name $1 | sed 1q))
Find all files under ~/code that are executable by owner without descending into hidden directories and print their parent directories appended with : at the beginning and remove all newlines and the last : (colon) </s> find ~/code -name '.*' -prune -o -type f -a -perm /u+x -print | sed 's@/[^/]\+$@:@' | sort | uniq | tr -d '\n' | sed 's/^/:/; s/:$//'
Find all files in current directory that were modified less than 1 day ago excluding hidden files and put the output to full_backup_dir variable </s> full_backup_dir=$(find . -depth \( -wholename \./\.\* \) -prune -o -mtime -1 -print)
Show the list of all files on the system whose names do not end in ".c" </s> find / \! -name "*.c" -print
display the number of lines in all the ".c" files in the current folder </s> find . -name "*.c" -print0 | xargs -0 wc -l
Find all files in the current directory tree whose size is greater than 1MB, and move them to the "files" folder </s> find . -size +1M -exec mv {} files \+
use regex with find command </s> find . -regextype posix-egrep -regex '\./[a-f0-9\-]{36}\.jpg'
Change directory to the user's home directory </s> cd
Search for 'some string' in all *.axvw files under current directory and show the matched lines with line numbers </s> find . -name '*.axvw' -exec grep -n 'some string' {} +
Make directory "/tmp/foo" </s> mkdir /tmp/foo
find any files or directories called ".svn" under the current directory and run a recursive delete (without prompting) command on each one. </s> find . -iname .svn -exec bash -c 'rm -rf {}' \;
Print the base name of the current working directory </s> pwd | xargs basename
Print the kernel configuration options found in "/proc/config.gz" </s> cat /proc/config.gz | gunzip
find all normal/regular files in the entire file system having the word "filename" in their name. </s> find / -type f -iname "filename"
Print the full real path of "/dev/disk/by-uuid/$1" followed by "is mounted" </s> echo $(readlink -f /dev/disk/by-uuid/$1) is mounted
find all php files in the folder  /var/www/ </s> find /var/www/ -type f -iname "*.php" -print
Rename all files in current directory to lowerase. </s> rename 'y/A-Z/a-z/' *
Counts lines of /dir/file.txt file. </s> cat /dir/file.txt | wc -l
List all cron jobs which contain "word". </s> crontab -l | egrep "word"
Find all files in your home directory and below that are exactly 100M. </s> find ~ -size 100M
Search the current directory recursively for .sh files whose names begin with "new" </s> find . -name "new*.sh"
Change the user and group of all files and directories under /var/www to www-data:www-data </s> find /var/www -print0 | xargs -0 chown www-data:www-data
Print second field from semicolon-seprated line $string. </s> echo $string | cut -d';' -f2
Find all files under /path/to/dir that were modified less than 7 days ago with null character as the delimiter </s> find /path/to/dir -type f -mtime -7 -print0
find all the files in the current folder which have been changed in the last 60 minutes </s> find . -cmin -60
Search the /home/weedly directory tree for regular files named myfile </s> find /home/weedly -name myfile -type f -print
Find all files in the current directory tree ignoring the ".git" directory </s> find . -type d -name '.git*' -prune -o -type f -print
find all the backup files in the current folder and delete them after user confirmation </s> find . -type f -name "*.bak" -exec rm -i {} \;
Create tar archive "foo.tar" and copy all files from directory tree /tmp/a1 to it </s> find /tmp/a1 | xargs tar cvf foo.tar
Remove files under /mnt/zip matching "*prets copy" with confirmation </s> find /mnt/zip -name "*prefs copy" -print0 | xargs -0 -p /bin/rm
Print the name of "file1" if this file is newer than "file2" </s> find file1 -prune -newer file2
Search the current directory recursively for files writable for `others' </s> find . -perm -o+w
Find all files named 'text.txt' under current directory tree and display their contents </s> find . -name 'text.txt' -print -exec cat {} \;
Find all *.$input_file_type files/directories under $source_dir </s> find "$source_dir" -name *.$input_file_type
Find all files under path_to_dir </s> find path_to_dir -type f
Search the /tmp tree for files between 10kb and 20kb </s> find /tmp -size +10k -size -20k
Search for the extended regex expanded by"$MONTH\/$YEAR.*GET.*ad=$ADVERTISER HTTP\/1" in the decompressed contents of the /var/log/apache2/access*.gz files that are newer than ./tmpoldfile and older than ./tmpnewfile </s> find /var/log/apache2/access*.gz -type f -newer ./tmpoldfile ! -newer ./tmpnewfile \ | xargs zcat | grep -E "$MONTH\/$YEAR.*GET.*ad=$ADVERTISER HTTP\/1" -c
List all regular files in the current directory tree </s> find . -type f | xargs ls -l
Search for all directories named foo, FOO, or any other combination of uppercase and lowercase characters beneath the current directory. </s> find . -iname foo -type d
Change the owner to "owner" and group to "nobody" of "public_html" </s> chown owner:nobody public_html
Make directory "/path/to/destination" </s> mkdir /path/to/destination
change the permissions of all regular/normal files in the file system </s> chmod 640 `find ./ -type f -print`
Change permissions to 644 for all directories under and below /path/to/someDirectory/ </s> find /path/to/someDirectory -type d -print0 | xargs -0 sudo chmod 755
search for the file chapter1 in the folder /work </s> find /work -name chapter1
Changes group ownership of 'myprogram' to ${USER} (the current user) </s> chgrp "${USER}" myprogram
Rename all *.txt regular files in the current directory tree to *.abc </s> find . -type f -iname '*.txt' -print0 | xargs -0 rename .txt .abc
Print "$line" in hexadecimal 2-byte units </s> echo -n $line | od -x
Replace any sequence of spaces in file 'text.txt' with single space and print 4th space separated field </s> cat text.txt | tr -s ' ' | cut -d ' ' -f 4
Find all directories named 'files' under current directory and set read-write-execute permission for owner and group and no permission for other for those directories </s> find . -type d -name files -exec chmod ug=rwx,o= '{}' \;
Find files in and below the current directory whose names begin with "not" and remove one of them </s> find . -name not\* | tail -1 | xargs rm
find all files in the current directory that are less than 1 byte size </s> find . -size -1c -print
Show the mv commands that would rename the *.so files in the current directory tree prepending their names with "lib" </s> find . -name "*.so" -printf "mv '%h/%f' '%h/lib%f'\n" | less -S
Find files and directories owned by xuser1 and change their ownership to user2 </s> find . -user xuser1 -exec chown -R user2 {} \;
Find all files under current directory whose file type description contains "image", display only path to each file. </s> find . -type f -exec file {} \; | awk -F: '{ if ($2 ~/[Ii]mage|EPS/) print $1}'
Change owner to "root" and group to "wheel" of "bin" </s> sudo chown root:wheel bin
Removes '/var/lib/mongodb/mongod.lock' in 'sudo' mode. </s> sudo rm /var/lib/mongodb/mongod.lock
Change to folder where the oracle binary is. </s> cd $(which oracle | xargs dirname)
Find all files that were modified later than ordinary_file in the current directory and its sub-directories. </s> find -newer ordinary_file
Search the /Path directory tree for files whose pathnames match pattern "/Path/bar*" and whose names match pattern "file_name*" </s> find /Path -path "/Path/bar*" -name "file_name*"
Delete all files named '-F' under current directory tree </s> find . -name "-F" -exec rm {} \;
find all normal/regular files in current folder and display the total lines in them </s> find . -type f -print0 | xargs -0 wc -l
replaces the last occurrence of 'a' with 'c' </s> tac | sed '0,/a/ s/a/c/' | tac
display all the jpg files in the current folder and do not search in sub directories </s> find . -maxdepth 1 -mindepth 1 -iname '*.jpg' -type f
Search the current directory tree for files and directories whose names begin with "pro" </s> find . -name pro\*
Find all first occurrences of directories named '.texturedata' under '/path/to/look/in' directory tree </s> find /path/to/look/in/ -type d -name '.texturedata' -prune
Find all files/directories following symlinks under /path/to/dir/* paths and print the timestamp in YmdHMS format along with their paths </s> find -L /path/to/dir/* -printf "%TY%Tm%Td%TH%TM%TS|%p\n"
Look for all files whose names match pattern 'my*' </s> find / -name 'my*'
Save the UTC date represented by time string $sting2 as the seconds since epoch to variable 'FinalDate' </s> FinalDate=$(date -u -d "$string2" +"%s")
Print which files differ between dir1 and dir2, treating absent files as empty </s> diff --brief -Nr dir1/ dir2/
Find all readme.txt files/directories under your home directory </s> find ~ -name readme.txt
Find all directories under current directory having DIRNAME in their name </s> find . -type d | grep DIRNAME
Decompress "file2.txt" and "file1.txt" and print lines in "file1.txt" that match the 5th tab separated field in "file2.txt" </s> awk -F'\t' 'NR==FNR{a[$5];next} $5 in a' <(zcat file2.txt) <(zcat file1.txt)
Search for "pattern" in "file" and join each line by a space </s> cat file | grep pattern | paste -sd' '
Find all files/directories that belong to the group 'accts' under '/apps' directory tree </s> find /apps -group accts -print
Find all *.sql file that are not newer than  $oldest_to_keep excluding the  $oldest_to_keep file </s> find . -name \*.sql -not -samefile $oldest_to_keep -not -newer $oldest_to_keep
Find all .php files starting from the root directory and ignoring /media </s> find / -name "*.php" -print -o -path '/media' -prune
Split "system.log" into files of at most 10 MiB in size with a numeric suffix and prefix "system_split.log" </s> split -b 10M -d  system.log system_split.log
Set variable PacketLoss to first digit of percentage of packet loss occurring when pinging host specified by TestIP </s> PacketLoss=$(ping "$TestIP" -c 2 | grep -Eo "[0-9]+% packet loss" | grep -Eo "^[0-9]")
find all the files in the current folder which have been modified in the last 60 minutes </s> find . -mmin -60
Recursively removes all empty folders from the X folder. </s> find X -depth -type d -exec rmdir {} \;
Find all files/directories under current directory that match the case insensitive glob pattern {EA,FS}_* </s> find . -iname "{EA,FS}_*"
Search the current directory tree for the files with extension "trc" and list them if they are more than three days old </s> find . -name "*.trc" -ctime +3 -exec ls -l {} \;
display a long list of all the files in the directory "/mydir" which have not been modified in the last 20*24 hours or which have not been accessed in the last 40*24 hours </s> find /mydir \(-mtime +20 -o -atime +40\) -exec ls -l {} \;
Find all 777 permission files in entire file system and set permissions to 644 </s> find / -type f -perm 0777 -print -exec chmod 644 {} \;
display all the regular files in the current folder which have the permission 777 </s> find . -type f -perm 777
Print the files to which symbolic links in the current directory point </s> find . -type l -print | xargs ls -ld | awk '{print $10}'
change the permission of all the php files in the folder /var/www/ to 700 </s> find /var/www/ -type f -iname "*.php" -exec chmod 700 {} \;
Find all directories in /path/to/dir/ without going into sub-directories and append a null character at the end of each paths </s> find /path/to/dir/ -mindepth 1 -maxdepth 1 -type d -print0
Search the .java files from the current directory tree for TODO lines </s> find . -name "*.java" -exec grep -Hin TODO {} \;
Print every 20 bytes of standard input as tab separated groups of bytes 1-3, 4-10, and 11-20 </s> fold -b -w 20 | cut --output-delimiter $'\t' -b 1-3,4-10,11-20
Archive "src/bar" on host "foo" to local directory "/data/tmp" </s> rsync -avz foo:src/bar /data/tmp
sleep for 5 seconds </s> sleep 5
Search file aaa from current direcoty downwards and print it . </s> find . -name aaa -print
Change permissions of all files ending in ".php" under the current directory to 755 and print a '+' for each file </s> find . -name '*.php' -exec chmod 755 {} \; -exec echo '+' \;
Make $WEEKS_TO_SAVE+1 directories named "weekly.N" where N ranges from 0 to "$WEEKS_TO_SAVE" </s> mkdir -p $(seq -f "weekly.%.0f" 0 $WEEKS_TO_SAVE)
print all files in the directories except the ./src/emacs directory </s> find . -wholename './src/emacs' -prune -o -print
Print the content of the file 'file' deleting the last four lines </s> nl -b a file | sort -k1,1nr | sed '1, 4 d' | sort -k1,1n | sed 's/^ *[0-9]*\t//'
Search the file system for regular files whose names are shorter than 25 characters </s> find / -type f|egrep "/[^/]{0,24}$"
Find all directories under maximum 1 level down the /parent  directory and set their permission to 700 recursively </s> find /parent -maxdepth 1 -type d -print0 | xargs -0 chmod -R 700
Display an amount of processes running with a certain name </s> ab=`ps -ef | grep -v grep | grep -wc processname`
Print the average time of 4 ping requests to "www.stackoverflow.com" </s> ping -c 4 www.stackoverflow.com | awk -F '/' 'END {print $5}'
Delete all files/directories under current directory tree with '.$1' extension where $1 expands as the first positional parameter </s> find . -name "*.$1" -delete;
Reports count of characters in the value of ${FOO_NO_EXTERNAL_SPACE} variable as follows:  "length(FOO_NO_EXTERNAL_SPACE)==<counted number of characters>" </s> echo -e "length(FOO_NO_EXTERNAL_SPACE)==$(echo -ne "${FOO_NO_EXTERNAL_SPACE}" | wc -m)"
Prints full path to files in a current folder. </s> ls -1 | awk  -vpath=$PWD/ '{print path$1}'
Find all files and directories whose names end in ".rpm" and change their permissions to 755 </s> find / -name *.rpm -exec chmod 755 '{}' \;
search the file "myfile.txt" in home folder </s> find "$HOME/" -name myfile.txt -print
search for a file "file" in current folder and display all instances of this file </s> find -name file -print
Count md5sum of all '*.py' files in a current folder with subfolders. </s> find /path/to/dir/ -type f -name "*.py" -exec md5sum {} + | awk '{print $1}' | sort | md5sum
Find all the files whose name is tecmint.txt </s> find . -name tecmint.txt
Sort strings of 'test.txt' file by second from the end field </s> rev   test.txt | sort  -k2 | rev
Find recursively the latest modified file in the current directory </s> find . -type f -printf '%T@ %p\n' | sort -n | tail -1 | cut -f2- -d" " | sed 's/.*/"&"/' | xargs ls -l
Saves space separated content of $RAW_LOG_DIR in FILES variable </s> FILES=`cat $RAW_LOG_DIR | xargs -r`
Find all *Company* files/directories under /root/of/where/files/are directory </s> find /root/of/where/files/are -name *Company*
Recursively finds all *.dbf files from the root folder and prints list of folders with such files. </s> find / -name \*.dbf -print0 | xargs -0 -n1 dirname | sort | uniq
Search for first match of the regex 're' in all *.coffee files under current directory and print the file names </s> find . -name \*.coffee -exec awk '/re/ {print FILENAME ":" $0;exit}' {} \;
display all files in the current folder after pruning those in the current folder ( dot is the output of this command ) </s> find . -prune -print
Search the entire file system for any file that is writable by other. </s> find / – perm -0002
Print the current user name associated with standard input </s> who -m | awk '{print $1;}'
find all the javascript files in current folder using regular expressions </s> find . -regex '.+\.js'
Find all files in the current directory tree whose size is greater than 1MB, and move them to the "files" folder </s> find . -size +1M -print0 | xargs -0 -I '{}' mv '{}' files
Print a hex dump byte to byte of the output of "echo Aa" </s> echo Aa | od -t x1
Search the current directory tree for files containing "needle" in their names </s> find . -iname "*needle*"
Print concatenated content of all files ending with '.foo' under the current folder </s> cat `find . -name '*.foo' -print`
Change the ownership of all files in the current directory tree to myuser:a-common-group-name </s> find . -exec chown myuser:a-common-group-name {} +
Find regular files named "expression -and expression" under and below /dir/to/search/ </s> find /dir/to/search/ -type f -name 'expression -and expression' -print
get year-month-day from date </s> date +%Y-%m-%d
Find all directories named "0" in the current directory tree and create a single tar archive of their RS* subdirectories </s> find . -type d -name "0" -execdir tar -cvf ~/home/directoryForTransfer/filename.tar RS* \;
Move all files from the `sourceDir' directory tree to the `destDir' directory </s> find sourceDir -mindepth 1 -print0 | xargs -0 mv --target-directory=destDir
Mount "tmpfs" filesystem to "/path/to/dir" </s> mount none -t tmpfs /path/to/dir
Print lines in "file1.txt" that do not exist in "file2.txt" </s> sort <(sort -u file1.txt) file2.txt file2.txt | uniq -u
Find all files/directories under current directory </s> find -print0 | xargs -0
Replace ",," with ", ," in "$file" and display the "," delimited result as a table in "less" with a shift value of 5 and line numbers </s> cat "$file" | sed -e 's/,,/, ,/g' | column -s, -t | less -#5 -N -S
Delete all files with '.old' extension under current directory tree </s> find . -name “*.old” -print | xargs rm
Handles shell option 'nullglob' according with flags stored in $NGV variable. </s> shopt "$NGV" nullglob
Find all files called "INPUT.txt" in the current directory tree and remove lines starting with # in them, saving backup copies as INPUT.txt.bak </s> find . -type f -name INPUT.txt -print0 | xargs -0 -I {}  sed -i.bak '/^#/d' {}
Print every found file like '*.cfg' under '/path/to/files/' directory followed by its content, and wait 2 seconds after each printed file </s> find /path/to/files -type f -name \*.cfg  -print -exec cat {} \; -exec sleep 2 \;
Execute "awk -F, '$1 ~ /F$/'" on contents of "file.gz" </s> zcat file.gz | awk -F, '$1 ~ /F$/'
Find all files/directories named 'articles.jpg' under 'images' directory tree </s> find images -name "articles.jpg"
display all files which have been modified between two dates in current folder </s> find . -type f -newermt "2014-01-01" ! -newermt "2014-06-01"
List all the .c files under the current directory and below in a 3 column format </s> find . -name "*.c" | xargs -n3
Type unique list of all directories contiaining each file named 'myfile' under the /home directory </s> find /home/ -name 'myfile' -type f | rev | cut -d "/" -f2- | rev | sort -u
Search the /storage/sdcard0/tencent/MicroMsg/ directory tree for JPG files </s> find  /storage/sdcard0/tencent/MicroMsg/ -type f  -iname '*.jpg' -print0
Find recursively all regular files in directory tree b that were changed within the last 5 minutes and copy them to directory c </s> find b -type f -cmin -5 -exec cp '{}' c \;
search for a word in all the regular files in the current folder without traversing the sub directories . </s> find -maxdepth 1 -type f | xargs grep -F 'example'
Find all directories in 1 level down the current directory </s> find . -mindepth 1 -maxdepth 1 -type d
grep for the last occurrence of text between two tags </s> tac a | grep -m1 -oP '(?<=tag>).*(?=</tag>)'
Search directories /opt, /usr, /var for regular file foo </s> find /opt /usr /var -name foo -type f
show the disk use of all the regular/normal files in the file system which are bigger than 100MB </s> find / -type f -size +100M | xargs du -sh
Find all files/directories named orm.properties under  /eserver6 directory </s> find /eserver6 -name "orm.properties"
display all directories in the folder "/myfiles" </s> find /myfiles -type d
Find all *.jpg files in */201111/* paths and numerically sort them according to the second field in the file name with a delimiter '_' </s> find */201111/* -name "*.jpg" | sort -t '_' -nk2
Find all .php files starting from the root directory / </s> find / -name "*.php"
Unzip "file.gz" and print each line with the 5th " or | separated field greater than 5 </s> zcat file.gz | awk -F'[|"]' '$5>5'
display the version of find command </s> find --version
Find all regular files on the system whose names are 'myfile' </s> find / -name myfile -type f -print
Recursively list contents of the current directory in a tree-like format </s> tree
display all the regular files in the current folder that are bigger than 10KB </s> find . -type f -size +10k
List the entire cron job list of user "apache". </s> crontab -u apache -l
Count the total number of lines in all "*.gz" files in the current directory tree after decompression </s> find . -type f -name '*.gz' | xargs zcat | wc -l
Search for ERROR in all btree*.c files under current directory </s> grep ERROR $(find . -type f -name 'btree*.c')
Lists content of all subfolder (without recursion) in a current folder. </s> ls -d -1 $PWD/**/*
Print "a\nb\ncccccccccccc\nd" as two columns and neatly format into a table </s> echo -e "a\nb\ncccccccccccc\nd" | paste - - | column -t
View manual page of the find command </s> man find
View contents of files matching "/usr/share/doc/mysql-server-5.0/changelog*.gz" in "less" </s> zcat /usr/share/doc/mysql-server-5.0/changelog*.gz | less
Search the current directory tree for executable files </s> find . -type f -executable -print
Split "abc.txt" into files with at most 1500000000 bytes each and use prefix "abc" </s> split --bytes=1500000000 abc.txt abc
Find command will display top 5 small files from curent directory . most probably you will get ZERO  bytes files . </s> find . -type f -exec ls -s {} \; sort -n |head -5
Display all variables with names starting with "derby" in a Window's command line </s> set derby
delete all normal/regular files in the current folder which are empty </s> find . -type f -empty -delete
find a 'fool.scala' named regular file under /opt /usr /var those directories. </s> find /opt /usr /var -name foo.scala -type f
create an archive excluding files matching patterns listed in /path/to/exclude.txt </s> tar -czf backup.tar.gz -X /path/to/exclude.txt /path/to/backup
sleep for 1 second </s> sleep 1
List all files except for those in directory SCCS </s> find . -print -o -name SCCS -prune
Delete and count files in $DIR_TO_CLEAN that are older than $DAYS_TO_SAVE days </s> find "$DIR_TO_CLEAN" -type f -mtime +$DAYS_TO_SAVE -print0 | awk -v RS='\0' -v ORS='\0' '{ print } END { print NR }' | xargs -0 rm
Remove empty directories from the current directory tree </s> find . -depth -empty -type d -delete
display all files in the current folder that have been modified in the last 24 hours whose name has only 1 letter </s> find . -name \? -mtime -1
Archive "fileToCopy" to "/some/nonExisting/dirToCopyTO" on host "ssh.myhost.net" via ssh </s> rsync -ave ssh fileToCopy ssh.myhost.net:/some/nonExisting/dirToCopyTO
Creates temporary folder within TMPDIR, with name like current shell name and 10-letter suffix. </s> mktemp -dt "$(basename $0).XXXXXXXXXX"
Recursively search for all files with names ending with "_test.rb", renaming them to end with "_spec.rb", using at most 1000000 characters per command. </s> find . -name "*_test.rb" | xargs -s 1000000 rename s/_test/_spec/
Get files that last had their meta information changed more than 3 days ago </s> find / -ctime +3
Print DISPLAY of "orschiro" user </s> who | awk -F '[()]' '/orschiro/{print $(NF-1)}' | grep -v orschiro | uniq
Fetch a script from the web and interpert (run) it in the current shell, without writing the script to disk. </s> source <(wget -q -O - "http://www.modulesgarden.com/manage/dl.php?type=d&id=676")
Unzip "path/to/test/file.gz" to standard output and save all lines matching "my regex" to files with a 1000000 limit </s> gzip -cd path/to/test/file.gz | awk 'BEGIN{global=1}/my regex/{count+=1;print $0 >"part"global".txt";if (count==1000000){count=0;global+=1}}'
find all files in the file system which have no user and no group </s> find / -nouser -nogroup
search for a regular/normal file "myfile" in the entire file system excluding the folder in excluded_path </s> find / -path excluded_path -prune -o -type f -name myfile -print
Removes empty folder, and hides error message if one is not empty. </s> rmdir --ignore-fail-on-non-empty $newBaseDir/Data/NewDataCopy
Find files with size more than 200557600B and which are more than 2 days old under  ${userdir}/${i}/incoming directory and remove them </s> find ${userdir}/${i}/incoming -mtime +2 -type f -size +200557600c -exec rm {} \;
find all the html files in the current folder which have been modified in the last 7 days </s> find . -mtime -7 -name "*.html" -print
Go to directory /cygdrive/c/Program Files (x86) using backslashes to escape special characters </s> cd /cygdrive/c/Program\ Files\ \(x86\)
Search for files bigger than 10M </s> find ~ -size +10M
Find all the *.c files at any level of directory Programming under any 'src' directory </s> find ~/Programming -path '*/src/*.c'
Copy "/home/username/path/on/server/" to "username@your.ip.address.here:/Users/username/path/on/machine/" and convert encoding from UTF-8 to UTF-8-MAC </s> rsync --iconv=UTF-8,UTF-8-MAC /home/username/path/on/server/ 'username@your.ip.address.here:/Users/username/path/on/machine/'
Create a symbolic link named "$HOME/bin/" to "$HOME/downloads/fnord" </s> ln -s $HOME/downloads/fnord $HOME/bin/
find all the files in the entire file system that have been accessed in the last 60 days ago </s> find / -amin -60
Search directory tree `foo' for files named `Headers' </s> find foo -name Headers
Print a count of case insensitive duplicate filenames in the current directory </s> ls -1 | tr '[A-Z]' '[a-z]' | sort | uniq -c | grep -v " 1 "
Prints the first N bytes of file.txt </s> head -c N file.txt
Report total disk usage info on root file system, printing all sizes as power of 1000 </s> df -H --total /
Print the base name of the current working directory </s> basename $(pwd)
Find all regular files in the entire filesystem that belong to the group 'users' </s> find /  -type f -group users
Find all empty directories under current directory </s> find . -type d -empty
Remove files from the file system that are owned by nobody </s> find / -nouser -exec rm {} +
Print 'echo 'hello, world' </s> echo 'hello, world' | cat
List all *.jar files/directories under /usr, /home and /tmp directory </s> find /usr /home  /tmp -name "*.jar"
Remove all empty files in /tmp/ and below </s> find /tmp -type f -empty -print | xargs rm -f
display all the text files in the home folder </s> find /home -name "*.txt"
Compare each file in "repos1/" and "repos2/", treat absent files as empty, ignore differences in whitespace and tab expansions, and print 3 lines of unified context </s> diff -ENwbur repos1/ repos2/
Overwirte file '/path/to/your/file' with random content, then overwrite with zeroes, and remove, showing progress while execution. </s> shred -v -n 1 -z -u /path/to/your/file
Find all files in the current directory tree that are not newer than some_file </s> find . ! -newer some_file
Show a long listing of the latest file or directory under current directory </s> ls -lrt | tail -n1
find all files in the current folder which have only the write permission for the others </s> find . -perm -0002 -print
Print all lines of "seq 10" except the last 3 </s> seq 10 | tac | sed '1,3d' | tac
Find all files/directories under current directory excluding the paths that match the POSIX extended regex ".*def/incoming.*|.*456/incoming.*" </s> find . -regex-type posix-extended -regex ".*def/incoming.*|.*456/incoming.*" -prune -o -print
Count the number of directories in the current directory and below </s> find . -type f -exec basename {} \; | wc -l
Find all hidden regular files under /tmp and below </s> find /tmp -type f -name ".*"
Find all the Sticky Bit set files in entire file system whose permission are 551 </s> find / -perm 0551
create directory /path/to/destination </s> mkdir /path/to/destination
Save full path of command "cat" to variable "CAT" </s> CAT=`which cat`
Find all image.pdf files/directories under ./polkadots </s> find ./polkadots -name 'image.pdf'
Delete all files under /path/to/files that are not newer than dummyfile </s> find /path/to/files -type f ! -newer dummyfile -delete
Remove all "core" files that were last changed more than 4 days ago from the current directory tree </s> find . -name core -ctime +4 -exec /bin/rm -f {} \;
Show version information of the find utility </s> find -version
Create intermediate directories as required and directory project/{lib/ext,bin,src,doc/{html,info,pdf},demo/stat/a} </s> mkdir -p project/{lib/ext,bin,src,doc/{html,info,pdf},demo/stat/a}
Search the current directory tree for .VER files </s> find . -name "*.VER"
Read a line from standard input into variable "response" without backslash escapes using the prompt "About to delete all items from history that match \"$param\". Are you sure? [y/N] " </s> read -r -p "About to delete all items from history that match \"$param\". Are you sure? [y/N] " response
list files in the directory "$directory" with permissions "$permissions" </s> find "$directory" -perm "$permissions"
Print the last 10 lines of the file '/var/log/syslog' </s> tail /var/log/syslog
Display bash function definition of "foobar" </s> set | sed -n '/^foobar ()/,/^}/p'
Find all the regular files with '.tgz' and '.gz' extensions and delete the oldest file under '/home/backups' directory tree </s> find /home/backups -type f \( -name \*.tgz -o -name \*.gz \) -print0 | xargs -0 ls -t | tail -1 | xargs rm
Answer "y" to all "Are you sure?" prompts from command "cp * /tmp" </s> yes | cp * /tmp
Print "$somedir is empty" if $somedir is empty </s> find "$somedir" -maxdepth 0 -empty -exec echo {} is empty. \;
find all the files which have been changed after the modification of a file. </s> find -cnewer /etc/fstab
Infinitely print "1" then "0" </s> yes 0 | sed '1~2s/0/1/'
Print out every command that is executed in the script </s> set -x
Print a random number from 2000 to 65000 </s> seq 2000 65000 | sort -R | head -n 1
Finds strings with dot-separated sequence of numbers, and prints part of that sequence before the first dot. </s> echo "$f" | grep -Eo '[0-9]+[.]+[0-9]+[.]?[0-9]?' | cut -d. -f1
Change the permission of all regular files under current directory tree to 644 </s> find . -type f -exec chmod 644 {} \;
Find all files in the /home/ directory tree that are owned by bob </s> find /home -user bob
Set shell option 'dotglob'. </s> shopt -s dotglob
Display a list of files with sizes in decreasing order of size of all the regular files under $dir directory tree that are bigger than $size in size </s> find $dir -type -f size +$size -print0 | xargs -0 ls -1hsS
Find all files under current directory without descending into .snapshot directory that were modified in last 24 hours with null character as the delimiter </s> find . -name .snapshot -prune -o \( -type f -mtime 0 -print0 \)
Starts new tmux session, assuming the terminal supports 256 colours. </s> tmux -2
Find all directories in /path/to/dir/ without going into sub-directories </s> find /path/to/dir/ -mindepth 1 -maxdepth 1 -type d
Copy directory tree preserving UID and GID and leaving user files alone </s> find . -depth -print | cpio -o -O /target/directory
display all the regular files in the current folder and do not search in sub folders </s> find "$dir" -maxdepth 1 -type f
Locate file "file1" </s> find -name file1
Enables shell option 'promptvars'. </s> shopt -s promptvars
Search the *.code files from the current directory tree for string 'pattern' </s> find . -name '*.code' -print0 | xargs -0 grep -H 'pattern'
find all the mp3 files in the entire file system whose size is bigger than 10MB </s> find / -type f -name *.mp3 -size +10M -exec rm {} \;
Merge lines whose first comma-separated field in file 'in1' also appears as a first comma-separated in file 'in2', also outputting unmatched lines from 'in2' - both files must be sorted, and the output format of each line will be: first field of in1, second field of in2, and third field of in2. </s> join -t, -o 1.1,1.2,2.3 -a1 in1 in2
file all the Sticky Bit set files whose permission are 551 </s> find / -perm 1551
delete all the empty files(files with size 0 bytes) in the current folder </s> find . -empty -delete -print
Give a long listing of all the  *.pl files (Perl files) beneath the current directory. </s> find . -name "*.pl" -exec ls -ld {} \;
change owner and group  of all files and directory into current directory to user and group apache </s> find . -maxdepth 1 -not -name "." -print0 | xargs --null chown -R apache:apache
list all java file that StringBuff in context. </s> find . -type f -name "*.java" -exec grep -l StringBuffer {} \;
Set the bash prompt to "username@hostname" </s> PS1="`whoami`@`hostname | sed 's/\..*//'`"
Find all regular files under current directory </s> find . -type f
Search the current directory tree for files and directories called "test" </s> find . -name test -print
Save the first two letters of the system host name to variable "DC" </s> DC=`hostname | cut -b1,2`
Print the current directory tree </s> tree
Search all regular files in the current directory for "example" </s> find -maxdepth 1 -type f | xargs grep -F 'example'
Search for files/directories which have read and write permission for their owner, and group and only read permission for others </s> find . -perm -664
Find all "G*.html" files modified more than 7 days ago in the current directory tree </s> find . -mtime +7 -name "G*.html"
Lists all top-level files in a '/home/dreftymac/' folder. </s> ls /home/dreftymac/
Count the number of lines in "testfile" wrapped to fit in a width of "$COLUMNS" characters </s> fold -w "$COLUMNS" testfile | wc -l
List all regular files from the current directory tree that were modified less than 60 minutes ago </s> find . -type f -mmin -60 | xargs -r ls -l
return every file that does not have bar somewhere in its full pathname </s> find . ! -path '*bar*' -print
Search for the regex '^ERROR' in all *.log files under current directory </s> find . -name "*.log" -exec egrep -l '^ERROR' {} \;
display all file in the folder /dir/to/search except ".c" files </s> find /dir/to/search/ -not -name "*.c" -print
Find all *.foo files under current directory and print their contents </s> find . -name '*.foo' -exec cat {} +
Display a long listing of all the regular files in the file system which belong to user 'root' and which have suid bit set </s> find / -type f -user root -perm -4000 -exec ls -l {} \;
List all cron jobs which contain "word". </s> crontab -l | grep 'word'
Format the time string @133986838 according to the default time format and save it to variable 'VARIABLENAME' </s> VARIABLENAME=$(date -d @133986838)
Gets IP address of 'en1' network interface. </s> ifconfig en1 | awk '{ print $2}' | grep -E -o "([0-9]{1,3}[\.]){3}[0-9]{1,3}"
display all the files in the entire file system which begin with "apache-tomcat" </s> find / -name "apache-tomcat*"
Search the /dir directory tree for files whose names match regular expression '2015.*(album|picture)' </s> find /dir|egrep '2015.*(album|picture)'
List all *.java files/directories under /home/bluher with their full paths </s> find /home/bluher -name \*.java
Find all files in and below the home directory that have been modified in the last 90 minutes </s> find ~ -mmin -90
Interpret all lines containing an equal sign in myfile (usually, grab all variables from myfile into current shell) </s> grep "=" myfile | source /dev/stdin
Find all *.m4a files under /home/family/Music directory </s> find  /home/family/Music -type f -name '*.m4a' -print0
Find all files/directories under current directory tree whose names start with 'test' followed by two digits and end with '.txt' extension </s> find . -regextype sed -regex "./test[0-9]\{2\}.txt"
Save absolute path of "/home/nohsib/dvc/../bop" in variable "absolute_path" </s> absolute_path=$(readlink -m /home/nohsib/dvc/../bop)
Print the total disk usage in bytes of all files listed in "files.txt" </s> cat files.txt | xargs du -c | tail -1 | awk '{print $1}'
Search for files/directories which have read and write permission for their owner, and group and only read permission for others </s> find . -perm 664
Print out ln commands for each file in /home/folder1/*.txt that can be run to create symlinks appending '_CUSTOM_TEXT.txt' in their names </s> find /home/folder1/*.txt -type f | awk -F '.txt' '{printf "ln -s %s %s_CUSTOM_TEXT.txt\n", $0, $1}'
Calculate the md5 sum of every ".py" file in directory tree "/path" </s> find /path -type f -name "*.py" -exec md5sum "{}" +;
Remove the last two alphanumeric file extensions from "mpc-1.0.1.tar.gz" </s> echo "mpc-1.0.1.tar.gz" | sed -r 's/\.[[:alnum:]]+\.[[:alnum:]]+$//'
print bindings for "p" and "e" with no case sensitivity </s> bind -p|grep -i '"[pE]"'
Print mount point of the file system containing $path. </s> df -P "$path"  | tail -1 | awk '{ print $NF}'
Find all btree*.c files under current directory </s> find . -type f -name 'btree*.c'
display all the files in the current folder which are in the path "./sr*sc" </s> find . -path './sr*sc'
find regular files under the current directory, whose name ends in .mbox and rename each file, to the same name without .mbox at the end </s> find . -type f -wholename \*.mbox | sed 's/\(.*\)\.mbox/mv "\1.mbox" "\1"/' | sh
Print a colon-separated list of all directories from the $root directory tree </s> find $root -type d | tr '\n' ':'
create a symbolic link named "$ORACLE_HOME/include" to file "/usr/include/oracle/11.2/client" </s> sudo ln -s /usr/include/oracle/11.2/client $ORACLE_HOME/include
Remount "/system" with read only permission </s> mount -o remount,ro /system
create directory destdir </s> mkdir destdir
display long list of all the files in the folder /home/peter which belong to no user and change the owner,group of all these files (after user confirmation) to "peter","peter" </s> find /home/peter -nouser -exec ls -l {} \; -ok chown peter.peter {} \;
Finds files in 'directory' folder with the same name and location but different content than files in 'directory.original' folder and saves location of such files to 'directories' variable. </s> directories=$(diff -qr directory directory.original | cut -d' ' -f2 | xargs dirname | uniq)
Print a line of 100 random characters either "." or " " </s> cat /dev/urandom | tr -dc '. ' | fold -w 100 | head -1
Search for all files not newer than file /tmp/t </s> find / -not -newer /tmp/t
display the manual page of find </s> man find
Read the first 10 characters from standard input in an interactive shell into variable "VAR" </s> read -n10 -e VAR
find all the files in the current directory that have the extension "bar" and donot search in the subdirecotries directories. </s> find . -name *.bar -maxdepth 2 -print
Find directories under maximum 1 level down the directory $dir with 100 permission that are owned by the user $username </s> find $dir -maxdepth 1 -type d -user $username -perm -100
Save the system host name in variable "HOSTNAME" </s> HOSTNAME=$(hostname)
find all the files in the entire file system excluding the folder proc, which do not belong to any user or any group </s> find / -path /proc -prune -o -nouser -o -nogroup
Find all files name passwd in the root directory and all its sub-directories. </s> find / -name passwd
Find files and directories with the name RAID but don't traverse a particular directory </s> find . -name RAID -prune -o -print
find all the files in the home folder that have been modified between 24 to 48 hours </s> find $HOME -mtime -2 -mtime +1
Read a line of standard input in an interactive shell </s> read -e
Search for all files that end in ".conf" </s> find / -type f -name "*.conf"
change the permissions of all the regular files in the current folder </s> find . -type f -exec chmod 500 {} ';'
search for the file test.txt in the folders /home and /opt </s> find /home /opt -name test.txt
Forcibly removes files  '/tmp/stored_exception', '/tmp/stored_exception_line', '/tmp/stored_exception_source' </s> rm -f /tmp/stored_exception /tmp/stored_exception_line /tmp/stored_exception_source
verbosely create intermediate directoriy tmp as required and directory boostinst </s> mkdir -pv /tmp/boostinst
Find all files in the current directory аргумент and its sub-directories with the optional constraints of опция_поиска, значение and/or значение. </s> find аргумент [опция_поиска] [значение] [значение]
Find the files in the current directory that match pattern '*.ISOLATE.quantifier.txt' and move them to folder ISOLATE/ </s> find -name '*.ISOLATE.quantifier.txt' -maxdepth 1 -exec mv {} ISOLATE/ +
Find all files/directories in maximum 1 level down the current directory which do not have only read permission for 'other' </s> find . -maxdepth 1 ! -perm  -o=r
Search the current directory tree for .aux files </s> find . -name ".aux"
Save the full path of command "~/f" to variable "foo" </s> foo=`which ~/f`
List the current directory recursively ignoring the "dir1" subdirectory </s> find . -path ./dir1  -prune -o -print
Show filename and filetype description of all PHP files in current directory whose name or filetype description includes "UTF" </s> file *.php | grep UTF
Delete all files in the /myDir directory tree that were last modfied 7 days ago </s> find /myDir -mindepth 1 -mtime 7 -exec rm -rf {} \;
Find all files under ${searchpath} that match the regex ${string1}.*${string2}.*${string3}  in their contents where ${string1} etc.. will be expanded </s> find "${searchpath}" -type f -print0 | xargs -0 grep -l -E "${string1}.*${string2}.*${string3}"
Print the full path of command "rails" </s> which rails
find all the files in the folder /opt which have been modified exactly 20 days ago </s> find /opt -mtime 20
find all *.java files/directories under current directory </s> find . -name  \*.java
Find all syslog directories under /var/log directory </s> find /var/log -name "syslog" -type d
Find all files/directories under /path/to/dir and set directory permission to 0755 and file permission to 0644 </s> find /path/to/dir -type d -exec chmod 0755 '{}' \; -o -type f -exec chmod 0644 '{}' \;
Unzip all files matching "test1/*/*.gz" </s> gunzip test1/*/*.gz
Find all files/directories owned by user 'michel' under current directory </s> find -user michel
Delete all files named 'Waldo' under ~/Books directory tree where '~' expands to user's home directory </s> find ~/Books -type f -name Waldo -exec rm {} \;
Find all links pointing to /path/to/foo.txt </s> find . -lname /path/to/foo.txt
Find the first file/directory under current directory and quit </s> find . ... -print -quit
rename all the png files to jpg files in the current fodler </s> find . -name "*.png" -print0 | sed 'p;s/\.png/\.jpg/' | xargs -0 -n2 mv
Print full date of yesterday </s> echo `date -v-1d +%F`
find all files in the current directory which are bigger than 2MB </s> find -size +2M
Prints list of user 'myuser' groups in a format: 'groups: [comma-separated groups list]'. </s> echo "groups: [ $(groups myuser | sed -e 's/.\+\s\+:\s\+\(.\+\)/\1/g' -e 's/\(\s\+\)/, /g') ]"
Find all files/directories under current directory tree that start with 'R' and end with 'VER' in their names and were modified more than 1 day ago </s> find . -name "R*VER" -mtime +1
Find and remove multiple *.txt files </s> find . -type f -name "*.txt" -exec rm -f {} \;
Find all files in the `work' directory tree, pass them to grep and search for "profit" </s> find ./work -print | xargs grep "profit"
Get a sorted list of the longest line with line number for each file under current directory </s> find . -iname '*.page' -exec awk '{if(length($0) > L) { LINE=NR;L = length($0)}} END {print L"|"FILENAME":"LINE}' {} \; | sort
Format time string @$TIMESTAMP according to default time format </s> date -d @$TIMESTAMP
Print a list of all duplicate filenames in the current directory tree if there is no white space in filenames </s> find . |sed 's,\(.*\)/\(.*\)$,\1/\2\t\1/\L\2,'|sort|uniq -D -f 1|cut -f 1
check find version </s> find --version
Find all empty files in home directory </s> find ~ -empty
Find all duplicate ".jar" files in the current directory tree </s> find . -type f -printf "%f\n" -name "*.jar" | sort -f | uniq -i -d
Create a symbolic link named "$SYMLINK" to "$ACTUAL_DIR" </s> ln -s "$ACTUAL_DIR" "$SYMLINK"
Search the current directory tree for *.wav files that have "export" in their pathnames </s> find -type f -name "*.wav" | grep export
Find all files/directories under '/etc' directory tree that have been modified after '/etc/motd' </s> find /etc -newer /etc/motd
Removes empty folder 'edi' and 'edw'. </s> rmdir edi edw
display all regular/normal files in temp folder and display the filename along with file size </s> find tmp -type f -printf "f %s %p\n"
Print all unique directory paths under "dir1" compared to "dir2" </s> comm -23 <(find dir1 -type d | sed 's/dir1/\//'| sort) <(find dir2 -type d | sed 's/dir2/\//'| sort) | sed 's/^\//dir1/'
create directory dirname with permissions 777 </s> mkdir -m 777 dirname
Return all of the .conf files in Pat's user folder and subdirectories </s> find /home/pat -iname "*.conf"
change owner of the file destination_dir to user "user: </s> chown user destination_dir
display all the files in the /usr folder which have the permissions 777 </s> find /usr -perm 0777 -print
Removes all files from current folder but 5 newest ones. </s> rm `ls -t | awk 'NR>5'`
find all the files in the current folder and search for the word "vps admin" in them. </s> find . -exec grep -i "vds admin" {} \;
Split "list.txt" into files with at most 600 lines each </s> split -l 600 list.txt
Find all regular files under current directory tree containing 'some text' in their names without descending into hidden directories and excluding hidden files </s> find . -type d -path '*/\.*' -prune -o -not -name '.*' -type f -name '*some text*' -print
force delete all the files in the current folder expect xml files </s> find . | grep -v xml | xargs rm -rf {}
Search the files residing in the current directory tree whose names contain "bills" for "put" </s> find . -name '*bills*' -exec grep put {} \;
Print only lines from 'file1.txt' that not present in 'file2.txt' and beginning with 'Q' </s> cat file1.txt | grep -Fvf file2.txt | grep '^Q'
Find all files/directories named 'com.apple.syncedpreferences.plist' (case insensitive) under ~/Library directory tree </s> find ~/Library/ -iname "com.apple.syncedpreferences.plist"
Write the lines appended to "xxxx" as it appears to the console and append to "yyyy" in the background </s> tail -F xxxx | tee -a yyyy &
Reports count of processors in system. </s> grep "^core id" /proc/cpuinfo | sort -u | wc -l
Search directory /Users/david/Desktop/ recursively for regular files </s> find /Users/david/Desktop/ -type f
Recursively add read and directory access to all permissions of all files and directories </s> chmod -R a+rX *
Finds shell options with 'login' in name. </s> shopt | grep login
Rename file "edited_blah.tmp" to "/etc/blah" </s> sudo mv edited_blah.tmp /etc/blah
ERROR - will overwrite the executable if it's not a symlink. </s> sudo ln -sf /usr/local/ssl/bin/openssl `which openssl`
search for all the rpm files in the file system which reside in the same partition as that of the root </s> find / -xdev -name "*.rpm"
find md5sum of 'string to be hashed' </s> echo 'string to be hashed' | md5
Show the last 10 .conf files found by `find' in the /etc directory </s> find /etc -maxdepth 1 -name "*.conf" | tail
Append "<br/>" to the end of each line in "1\n2\n3" </s> echo -e "1\n2\n3" | sed 's/.*$/&<br\/>/'
Mount remote "smbfs" filesystem "//username@server/share" on "/users/username/smb/share" as soft </s> mount -t smbfs -o soft //username@server/share /users/username/smb/share
Set the 'verbose' shell option causing bash to print shell input lines as they are read </s> set -v
Find all regular files with the group read permission set in your home directory and below and output detailed information about each file. </s> find . -perm -g=r -type f -exec ls -l {} \;
Sort numerically and compare files "ruby.test" and "sort.test" </s> diff <(sort -n ruby.test) <(sort -n sort.test)
Find all files/directories named '.todo' under $STORAGEFOLDER directory tree and print the parent directory names </s> find "$STORAGEFOLDER" -name .todo -printf '%h\n'
Archive "myfile" to "/foo/bar/" and create directory "/foo/bar/" if "/foo/" exists </s> rsync -a myfile /foo/bar/
Change to folder where the oracle binary is. </s> cd "$(dirname $(which oracle))"
create a cpio archive of the entire contents the current directory while preserving the permissions, times, and ownership of every file and sub-directory </s> find . -depth -print | cpio -o -O /target/directory
Convert all characters in standard input to lower case </s> sed 's/.*/\L&/'
search for the directory "uploads" in current folder and change the permission of the folder and all the files to 755 </s> find . -type d -name 'uploads' -print0 | xargs -0 chmod -R 755
find all the files that have been modified in the last 7 days, </s> find . -mtime -7 -print
Finds every folder with file 'header.php' within, and copies file 'topscripts.php' to every one of them. </s> find -type f -name 'header.php' | xargs -n 1 dirname | xargs -n 1 cp -f topscripts.php
find all the symbolic links in the current folder and follow to the original file </s> find -L . -type l
change the permissions of all regular/normal files in the current directory </s> find . -type f | xargs chmod 664
Mount the "linprocfs" filesystem on "/proc" </s> mount -t linprocfs none /proc
Prints long listing of content in a root folder, including hidden files, with human-readable sizes, and stores output to '/root/test.out' file. </s> echo 'ls -hal /root/ > /root/test.out' | sudo bash
Print summary of new/missing files, and which files differ between dir1 and dir2. </s> diff  --brief --recursive dir1/ dir2/
display all scala files in the directory "src/main" </s> find . -type f -path "*src/main/*\.scala"
Find files in the current directory tree which are larger than 5 MB in size </s> find . -size +5000k -type f
find all the files in the current folder (handles files which contain newlines or only spaces in their names) </s> find . -print0 | xargs -0 -l -i echo "{}";
Prints long listing of a last modified file in a current folder. </s> find . -type f -printf '%T@ %p\n' | sort -n | tail -1 | cut -f2- -d" " | sed 's/.*/"&"/' | xargs ls -l
List all files under current directory with their sizes and paths </s> find . -type f -printf '%s %p\n'
Make directories as needed in "dest" for every directory found under "src/" </s> find src/ -type d -exec mkdir -p dest/{} \;
find all the word press configuration php files in the folder /var/www and do not search beyond two levels </s> find /var/www/ -name wp-config.php -maxdepth 2
Find all symbolic links containing 'vim' in their names uder '/usr/bin' directory tree </s> find /usr/bin -name '*vim*' -type l
Display differences between directories dir1 and dir2. </s> diff -r dir1/ dir2/
List all files without descending into subdirectories </s> find * -type f -print -o -type d -prune
find and delete all the files in the entire file system whose size is greater than 100MB. </s> find / -size +100M -exec rm -rf {} \;
See all pages in section 3. </s> apropos -s 3 .
Find one file or directory in the current directory whose name matches the pattern given as a variable $a </s> find . -maxdepth 1 -name "$a" -print -quit
List file information of the full path of command "c++" </s> ls -ald `which c++`
Count the number of unique duplicate lines in "file1" and "file2" combined </s> sort file1 file2 | uniq -d | wc -l
Output all lines in 'file' which contain a tab character. </s> awk -F"\t" 'NF>1' file
Modify and rewrite 'file' replacing the first instance of "foo" on each line with "bar" </s> sed -i 's/foo/bar/' file
display all the files in the folder "/home/mywebsite" which have been changed in the last 7*24 horus </s> find /home/mywebsite -type f -ctime -7
List in detail regular files from the current directory tree whose names match Perl regular expression '\w+-\d+x\d+\.\w+$' </s> find -type f |  grep -P '\w+-\d+x\d+\.\w+$' | sed -re 's/(\s)/\\\1/g' | xargs ls -l
Find the passwd file under the root directory and two levels down </s> find / -maxdepth 3 -name passwd
Find all files/directories under current directory matching the case insensitive pattern 'pattern' </s> find -iname pattern
Find all files matching pattern '.#*' in the current directory tree </s> find -iname '.#*'
List all environment variables (name and value) whose name starts with GOROOT </s> env | grep '^GOROOT'
List all environment variables </s> set
Locate files that reside in the home directory and have not been accessed in the past 30 days </s> find $HOME -atime +30
display all the files in the current folder which have been modified between two dates </s> find . -newermt “Sep 1 2006” -and \! -newermt “Sep 10 2006”
find all the files in the present directory which have the group staff and check if is a symbolic link and display it. </s> find `pwd` -group staff -exec find {} -type l -print ;
Find all files whose filename does not end with *.html. </s> find . -type f -not -name "*.html"
Print "echo ping -c 2" on each string in file 'ips' </s> cat ips | xargs -n1 echo ping -c 2
find all the files with the name test in the current folder ( case insensitive ) </s> find . -iname test
Find all *.cpp files in the current directory tree that contain "sub" in their names </s> find . -name "*sub*.cpp"
Find every file/directory under /var/spool that was modified more than 60 days ago. </s> find /var/spool -mtime +60
Gets IP address of first network interface which name matches pattern "venet0:0\|eth0". </s> ifconfig | grep -A2 "venet0:0\|eth0" | grep 'inet addr:' | sed -r 's/.*inet addr:([^ ]+).*/\1/' | head -1
Search for files/directories which are writable by both their owner and their group </s> find . -perm -220
Find all the .c files in the current directory tree that contain the string ‘stdlib.h’ </s> find . -name ‘*.c’ | xargs egrep stdlib.h
Find a directory named 'project.images' in the entire filesystem </s> find  / -type d -name "project.images"
Show directory sizes in KB and sort to give the largest at the end </s> du -sk $(find . -type d) | sort -n -k 1
Find all files/directories named 'FindCommandExamples.txt' under '/root' directory tree </s> find /root -name FindCommandExamples.txt
display all the files in the usr folder which have been modified after Feburary 1st </s> find /usr -newermt "Feb 1"
create a zip of log files in the current directory which have not been accessed in the last 3 days (-p is for parallel processing for a 4 cpu machine, -n is for maximum work units) </s> find . -name '*.log' -mtime +3 -print0 | xargs -0 -n 500 -P 4 bzip2
Display the named characters in "line1\r\nline2" </s> echo -e "line1\r\nline2" | od -a
Find all directories whose name is root in / directory </s> find / -type d -name root
Find all filenames ending with .c in the current directory tree, case insensitive </s> find -iname "*.c"
display all the files in the usr folder and those that are in the path local </s> find /usr/ -path "*local*"
Find *.html files in the /usr/src/linux directory tree </s> find /usr/src/linux -name "*.html"
Print the list of all directories in the /myfiles directory tree </s> find /myfiles -type d
display all files in the folder /usr/src excluding those ending with ",v" </s> find /usr/src ! \( -name '*,v' -o -name '.*,v' \) '{}' \; -print
Print first column of every line in every *.txt separated by a space </s> paste -d':' *.txt | sed 's/ [^:]*$//;s/ [^:]*:*/ /g;s/://g'
Make a new directory "new-dir" in every directory in the current working directory non-recursively </s> find . -maxdepth 1 -type d | xargs -I "{x}" mkdir "{x}"/new-dir
get all the files that have been modified within the last 30 days </s> find . -mtime -30 -print
Display the file size of file '/data/sflow_log' in bytes </s> du -sb /data/sflow_log | cut -f1
change the permission of all the normal/regular files to 644 in the current folder </s> find -type f -exec chmod 644 {} \;
Search the current directory tree for all files matching either pattern "*.rb" or pattern "*.py" </s> find . -name "*.rb" -or -name "*.py"
Find all empty files under /tmp </s> find /tmp -type f -empty
Find all empty files starting from the current directory and delete them </s> find . -type f -empty -delete
Find all files/directories whose names start with 'readme' (case insensitive) under '/usr/share/doc' directory tree </s> find /usr/share/doc -iname readme\*
display the number of lines in all the php files in the current folder </s> find -name '*php' | xargs cat | wc -l
Find all files and directories containing "disc" in their names </s> find . -name *disc*
display all the files in the folder "/dev" which belong to the user "peter" </s> find /dev -user "peter" |more
Save a line of 100 random characters either "." or " " in variable "foo" </s> foo=$(cat /dev/urandom | tr -dc '. ' | fold -w 100 | head -1)
Output the system host name and date to the console </s> echo Hostname=$(hostname) LastChecked=$(date)
Find all files whose names end with "~" in the /home/peter directory tree, following symlinks, and delete them </s> find -L /home/peter -name *~ -exec rm '{}' \;
Copy the executable "python2.7" in $PATH to "myenv/bin/python" </s> cp `which python2.7` myenv/bin/python
Find all directories under /home/username/public_html/themes and set their permission to 750 </s> find /home/username/public_html/themes -type d -exec chmod 750 {} +
Wrap each line in "file" to fit in 80 characters and count the number of lines </s> fold file | wc -l
find all CSS files under currenty directory and use sed to edit them </s> find . -name "*.css" -exec sed -i -r 's/#(FF0000|F00)\b/#0F0/' {} \;
Gets IP addresses of all active network interfaces on host. </s> ifconfig | grep 'inet' | grep -v '127.0.0.1' | awk '{print $2}' | sed 's/addr://'
Append all regular files modified in the last 24 hours to the "$archive.tar" tar archive </s> find . -mtime -1 -type f -print0 | xargs -0 tar rvf "$archive.tar"
search for all the files in the current directory which have size greater than 10KB (approx) and less than 32KB(approx). </s> find . -size +10000c -size -32000c -print
Copies file 'test' to each of directories like './fs*/*'. </s> echo ./fs*/* | xargs -n 1 cp test
Find files/directories under /users/tom that matches both the pattern "*.pl" and  "*.pm" </s> find /users/tom -name "*.pl" -name "*.pm"
Find all directories under /home/me/"$d" </s> find /home/me/"$d" -type d
Recursively change ownership of "/usr/local/lib" to the current user </s> sudo chown -R `whoami` /usr/local/lib
find all the files in the entire file system whose size is between 50Mb to 100MB </s> find / -size +50M -size -100M
Search for command "tail" in the maps of the process with PID 2671 </s> cat /proc/2671/maps | grep `which tail`
List all regular files in the current directory tree </s> find . -type f -exec ls -l '{}' \;
find all the files that have been modified in the last 4 days ( daystart is used to check files according to date i.e, all files modified from currentDay-4 00:00:00 to current day) and copy them to folder. </s> find . -mtime 4 -daystart -exec cp -a {} /home/devnet/fileshare\$ on\ X.X.X.X/RECOVER/ \;
Print file names of all files ending with '*.csv' in  '/home/ABC/files/' directory </s> ls /home/ABC/files/*.csv | rev | cut -d/ -f1 | rev
Recursively find files in the current directory with a modification time more than 7 days ago, save the filenames to "compressedP.list", and compress no more than 10 at a time </s> find . -type f  -mtime +7 | tee compressedP.list | xargs -I{} -P10 compress {} &
Prints listing of a root folder including hidden files, and saves output to 'output.file'. </s> ls -a | tee output.file
Print unique lines in "file_a" and "file_b" </s> sort file_a file_b|uniq -u
Find and remove the file with inode number 782263 in the current directory tree </s> find . -inum 782263 -exec rm -i {} \;
Search for all files with either "sitesearch" or "demo" in their path names </s> find . -iregex '.*sitesearch.*' -iregex '.*demo.*'
Pipe the output of ls into "read var" in its separate process </s> ls | read var
Print the last command in history </s> history | tail -1 | awk '{print $1}'
Find out all hard links in the /home directory to file1 </s> find /home -xdev -samefile file1
Get directory listing of URL $1 and save them to variable 'header' by deleting '\r' characters </s> header="$(curl -sI "$1" | tr -d '\r')"
Read hexadecimal bytes from device "/dev/midi1" </s> od -vtx1 /dev/midi1
Compresses all files listed in array $*, executing in background. </s> compress $* &
Make 3 directories named "~/Labs/lab4a/folder" followed by the number 1, 2, or 3 </s> mkdir ~/Labs/lab4a/folder{1,2,3}
find the top 25 files in the current directory and its subdirectories </s> find . -type f -exec ls -al {} \; | sort -nr -k5 | head -n 25
bind word "pwd\n" to key code "\e[24~" </s> bind '"\e[24~":"pwd\n"'
Archive "/path/to/copy" to "/path/to/local/storage" on host "host.remoted.from" as user "user" updating files with different checksums, showing human readable progress and statistics, and compressing data during transmission </s> rsync -chavzP --stats /path/to/copy user@host.remoted.from:/path/to/local/storage
split listing of the current directory into pieces per 500 lines named "outputXYZNNN" </s> ls | split -l 500 - outputXYZ.
Find all regular files under current directory tree that match the regex 'tgt/etc/*' in their paths </s> find . -type f -name \* | grep "tgt/etc/*"
Send TERM signal to process with id listed in '/var/run/DataBaseSynchronizerClient.pid' file </s> kill `cat /var/run/DataBaseSynchronizerClient.pid`
find all directories that names are 'project.images' and display details </s> find  / -type d -name "project.images" -ls
Find all files/directories that start with 'screen' (case insensitive) in their names under user's home directory tree and show them by paging through one screenful at a time </s> find ~ -iname "screen*" | more
display all the users in the current folder which do not belong to the user root </s> find . ! -user root
search in the current folder for all the directories with the name "test" </s> find . -type d -name test
Delete files in $DIR_TO_CLEAN older than $DAYS_TO_SAVE days </s> find "$DIR_TO_CLEAN" -mtime +$DAYS_TO_SAVE -exec rm {} \;
Send Output From Find The Find Command To A File </s> find / -name *.mp3 -fprint nameoffiletoprintto
Find all *.jpg files under current directory and print only unique names </s> find . -name *.jpg | uniq -u
Find all files/directories in 1 level down the current directory </s> find -mindepth 1 -maxdepth 1
find all the files in the file system which have the permission 777 and with the name "dateiname" </s> find / -perm 777 -iname "Dateiname"
Find all *.pdf files under ./polkadots </s> find ./polkadots -type f -name "*.pdf"
find all text files in the current folder excluding those that are presenti n the folder "/svn" and search for a pattern. </s> find . -name '*.txt' \! -wholename '*/.svn/*' -exec grep 'sometext' '{}' \; -print
Log into "ubuntu@ec2-XX-XXX-XXX-XXX.us-west-2.compute.amazonaws.com" using identity file "~/path/mykeypair.pem" </s> ssh -i ~/path/mykeypair.pem ubuntu@ec2-XX-XXX-XXX-XXX.us-west-2.compute.amazonaws.com
Give all directories in the /path/to/base/dir tree read and execute privileges </s> find /path/to/base/dir -type d -print0 | xargs -0 chmod 755
Create the directory '.npm-global' in the user's home directory(~). </s> mkdir ~/.npm-global
find all the html files in the current folder and rename them to .var files </s> find -name '*.html' -print0 | xargs -0 rename 's/\.html$/.var/'
find all the files in the home folder which have been modified in the last 30 minutes </s> find $HOME -mmin -30
Search for 'text' in all regular files under current directory tree </s> find . -type f -exec grep "text" {} /dev/null \;
From a script, output the name of the script itself, without containing directories. </s> basename $0
Prints sorted list of logged in users. </s> w -h  | cut -d' ' -f1 | sort | uniq
display the contents of all the text files in the current directory </s> find . -name  '*.txt' -exec cat {} \;
Create a symbolic link named "$1/link" to the existing full and real path of "$2" </s> ln -s "$(readlink -e "$2")" "$1/link"
unsafed rm all file which name start with '#' </s> find / -name '#*' -atime +7 -print | xargs rm
Search for 'organic' in all files with '.html' extension under ~/html directory </s> find ~/html/ -name '*.html' -exec grep organic '{}' ';'
Split "$ORIGINAL_FILE" into files of at most "$MAX_LINES_PER_CHUNK" lines each with a prefix "$CHUNK_FILE_PREFIX" </s> split -l $MAX_LINES_PER_CHUNK $ORIGINAL_FILE $CHUNK_FILE_PREFIX
create directory /tmp/new </s> mkdir /tmp/new
Find all empty files under /tmp and below </s> find /tmp -type f -empty
Save the number of bytes in "$file" after decompression into variable "size" </s> size="$(zcat "$file" | wc -c)"
Find all regular files on the system whose size is greater than 20000k </s> find / -type f -size +20000k
Display the host's ECDSA fingerprint using the md5 hasing algorithm. </s> ssh-keygen -l -E md5 -f /etc/ssh/ssh_host_ecdsa_key.pub
Find all files under current directory that were modified in the last 24 hours and also include the files that were modified in less than 1 day ago </s> find -daystart -mtime +0
Run rsync with options specified by variable OPTS, copying directory(ies) specified by variable FIND, and to destination specified by variable BACKUPDIR. </s> rsync $OPTS $FIND $BACKUPDIR
Find all regular files under current directory non-recursively that have execute permission set for all (user, group and other) </s> find . -maxdepth 1 -type f -perm -uga=x
List all files/directories under current directory ensuring white space safety </s> find -print0 | xargs --null
Recursively add read and execute permissions to all files and folders in "directory" </s> chmod -R +xr directory
Find all .mp3 files starting from the current directory </s> find . -type f -iname *.mp3
Recursively removes all files like '*.pyc' in a current folder. </s> find . -name "*.pyc"|xargs rm -rf
List the unique parent directories of all .class files found in the entire filesystem </s> find / -name *.class -printf '%h\n' | sort --unique
Locate all `readme.txt' files under the home directory </s> find ~ -name readme.txt
find  case-insensitive StringBuffer in all *.java files </s> find . -type f -name "*.java" -exec grep -il string {} \;
Set timestamp of B to the timestamp in stat format specified by variable "old_time" </s> touch -d"$(date --date="@$old_time")" B
Execute the 'echo' command on each file from the current directory tree individually </s> find . -exec echo {} \;
display all the files in the current folder excluding search in the paths containing the folder having the word "mmm" </s> find . ! -path *mmm*
ERROR - this is for DOS </s> ping -n 1 %ip% | find "TTL"
Send one ping request to host with local address in the 192.168.1.x range, with last number specified by variable "COUNTER", and output only lines containing "ms" to standard output. </s> ping -c 1 192.168.1.$COUNTER | grep 'ms'
find all pdf files in the current folder </s> find . -name “*.pdf” -print
find all the word press configuration php files in the folder /var/www </s> find /var/www/ -name wp-config.php
Search the current directory recursively for files with the exact permissions u=rwx,g=rx,o=rx </s> find . -perm a=rwx,g-w,o-w
find *.gif files under the currently directory and sub-directories and list them using the ls command </s> find . -name *.gif -exec ls {} \;
Replace "dummyvalue" with the system IP address in "filename" </s> sed -i s/'dummyvalue'/$(hostname -I | head -n1 | awk '{print $1;}')/g filename
Extract number from $filename of the form "something_12345_else" and set the variable "number" to this number. </s> number=$(echo $filename | awk -F _ '{ print $2 }')
change owner and group of the all files with group owner vboxusers into home directory to user and group kent </s> find ~ -group vboxusers -exec chown kent:kent {} \;
Find all the files which are greater than 50MB and less than 100MB </s> find / -size +50M -size -100M
find all directories in the current folder </s> find -type d
Set up local port forwards in the background with no terminal or command execution from port 4431 to host "www1" port 443 and port 4432 to host "www2" port 443 via the host "colocatedserver" </s> ssh -fNT -L4431:www1:443 -L4432:www2:443 colocatedserver
Search for filenames matching "android" in the current directory and number the output </s> ls | grep android | nl
Remove all libGLE* files from the current directory tree </s> find . -name libGLE* | xargs rm -f
Decompress "path/to/test/file.gz" to standard output and save all lines matching "my regex" and not matching "other regex" to files with a 1000000 line limit </s> gzip -dc path/to/test/file.gz | grep -P 'my regex' | grep -vP 'other regex' | split -dl1000000 - file
This command find displays the files which are modified in the last 15 minutes. And it lists only the unhidden files. i.e hidden files that starts with a . (period) are not displayed in the find output. </s> find . -mmin -15 \( ! -regex ".*/\..*" \)
display all files in current folder excluding those that have the word "git" in their name and display files that have git in their path names </s> find . ! -name '*git*' | grep git
Display a long listing of all files/directories named 'file' under current directory tree </s> find -name file -ls
Find every JavaScript file in the wordpress directory tree </s> find wordpress -name '*js'
Find all .rpm files and change their permissions to 755 </s> find / -name *.rpm -exec chmod 755 '{}' \;
find all the php files in current folder and search for multiple patterns in these files </s> find -name '*.php' -exec grep -li "fincken" {} + | xargs grep -l "TODO"
Search the /path directory tree for files that do not have a valid user or group </s> find /path -nouser -or -nogroup
Print 1 to 10 by separating them with colon (':') </s> echo {1..9}: 10 | tr -d ' '
search for a function in all python files in the current folder </s> find . -name '*.py' | xargs grep some_function
List all aliencoders.[0-9]+ files/directories under /home/jassi/ directory </s> find /home/jassi/ -name "aliencoders.[0-9]+" | xargs ls -lrt | awk print '$9'
Make directory "~/log" </s> mkdir ~/log
Find all *.c files located under /home and below </s> find /home -name "*.c"
find file named foo.txt under root / directory. </s> find / -name foo.txt
Remove gitlab.site.org from root's known hosts file. </s> ssh-keygen -f "/root/.ssh/known_hosts" -R gitlab.site.org
Compare files "A1" and "A2" with 3 lines of unified context and print lines beginning with "+" </s> diff -u A1 A2 | grep -E "^\+"
Shows strings that NOT match regex '^($|\s*#|\s*[[:alnum:]_]+=)' </s> echo "${line}" | egrep --invert-match '^($|\s*#|\s*[[:alnum:]_]+=)'
Find and remove multiple *.mp3 files </s> find . -type f -name "*.mp3" -exec rm -f {} \;
Replace each newline in input "1\n2\n3\n4\n5" with a comma </s> echo "1\n2\n3\n4\n5" | paste -s -d, /dev/stdin
Sets shell option 'nullglob'. </s> shopt -s nullglob
Print the current shell </s> ps | tail -n 4 | sed -E '2,$d;s/.* (.*)/\1/'
Remove with prompting all files starting in /mydir that have not been accessed in over 100 days </s> find /mydir -atime +100 -ok rm {} \;
Print the current user's mail file in "/var/spool/mail" </s> cat /var/spool/mail/`whoami`
Display differences between file1 and file2 side-by-side. </s> diff -y file1 file2
Search the XML files from directories /res/values-en-rUS and /res/xml for string "hovering_msg" </s> find /res/values-en-rUS /res/xml -iname '*.xml' -print0 | xargs -0 -d '\n' -- grep -i "hovering_msg" --
Find files/directories under /tmp smaller than 100 bytes </s> find /tmp -size -100c
find all the php files in the current folder (discards any directory which has an extension of ".php") </s> find . -name \*.php -type f
Show the current UTC date in '%Y-%m-%dT%k:%M:%S%z' format </s> date -u '+%Y-%m-%dT%k:%M:%S%z'
Change to directory 'xyz' and resolve any symlinks in the resulting path, making the physical path the current one. </s> cd -P xyz
Search the current directory tree for all files except SVN ones </s> find .  ! -regex ".*[/]\.svn[/]?.*"
Find all files/directories in entire file system that have  "write" bit set for either the owner, the group, or others </s> find / -perm /u+w,g+w,o+w
Find all files under the current directory whose filenames are not "file.txt", ignoring the case </s> find . -maxdepth 1 -not -iname file.txt
find all the directories  with the name "c" in the current folder which are at least 3 levels deep and which are not present in the path "/p/". </s> find -mindepth 3 -type d -path '*/p/*' -prune -o -name c -print
Find all .mp3 files starting from the current directory and delete them </s> find . -type f -iname *.mp3 -delete
Cut all remote paths from HTTP URLs received from standard input (one per line) keeping only the protocol identifier, host name, and trailing slash, of the form http://example.com/ </s> sed -n 's;\(http://[^/]*/\).*;\1;p'
Split "file.tar.gz" into files of size 1024 MB with a prefix of "file.tar.gz.part-" </s> split -b 1024m "file.tar.gz" "file.tar.gz.part-"
Find all regular files under ${path} without following symlinks </s> find ${path} -P -type f
display a long listing of all the files in the current folder which are bigger than 10KB </s> find . -size +10k -exec ls -lh {} \+
Split "/usr/bin/gcc" into 100000 files of about equal size </s> split -n 100000 /usr/bin/gcc
Find the file whose inode number is 1316256 </s> find . -inum 1316256
Remove "_dbg" from all file or directory names under the current directory </s> rename _dbg.txt .txt **/*dbg*
Merge file1 and file2 by outputting all lines where the first comma-separated field of both files matches, followed by extra fields in file1 and those in file2 </s> join -t, <(sort file1) <(sort file2)
Run 'somecommand' in an environment without the FOO variable. </s> env -u FOO somecommand
Find all files residing in /home/dm/Video or below that were changed less than 7 days ago </s> find /home/dm/Video -mtime -7
Find *.c files under $HOME and search for the string 'sprintf' in those files </s> find $HOME -name '*.c' -print | xargs    grep -l sprintf
search for all Scala files under the current directory that contain the string null </s> find . -type f -name "*.scala" -exec grep -B5 -A10 'null' {} \;
Search the /myfiles directory tree for files that are 5 512 byte blocks in size </s> find /myfiles -size 5
Find all the files in file system which are modified more than 50 days back and less than 100 days </s> find / -mtime +50 –mtime -100
Find all regular files recursively in the current directory </s> find . -type f
search for the file, filename.txt in the current folder </s> find . -name filename.txt
Display differences between /tmp/test1 and /tmp/test2 side-by-side. </s> diff -y /tmp/test1  /tmp/test2
Make directory "foo" </s> mkdir foo
Prints current month calendar, without highlighting of a current date. </s> cal -h
Creae a tarball 'files.tar.gz' containing all regular files under current directory tree that are newer than 2013-12-04 and older than 2013-12-05 </s> find . -type f -name "*" -newermt 2013-12-04 ! -newermt 2013-12-05 | xargs -I {} tar -czvf files.tar.gz {}
Sort a file 'file' preserving only unique lines and change the file in-place </s> sort -u -o file !#$
Removes all files from current folder but 5 newest ones, filtering out directories from initial search. </s> ls -tp | grep -v '/$' | tail -n +6 | xargs -d '\n' rm --
Remove all files with names like "vmware-*.log" from the current directory tree </s> find . -name "vmware-*.log" -exec rm '{}' \;
Find empty files/directories under test directory </s> find test -empty
Search the current directory recursively for directories with the execute permission set for everybody </s> find -type d ! -perm -111
Show long listing of current directory by deleting all digits from the output </s> ls -lt | tr -d 0-9
Print the given file name's extensions. </s> echo "$NAME" | cut -d'.' -f2-
Find all regular files under '/directory_path' directory tree that have been modified within the last day </s> find /directory_path -type f -mtime -1 -print
Delete files older than 31 days </s> find ./ -mtime +31 -delete
Set 644 permission to all regular files under /path </s> find /path -type f -exec chmod 644 {} +;
list all the files in the current directory which are of size 0 bytes. </s> find . -empty
Change directory to the alphabetically last path under the current directory </s> cd "$(find . -print0 | sort -z | tr '\0' '\n' | tail -1)"
find files changed in the last 1 day </s> find . -mtime -1 -type f
Print second section of space-separated data coming from stdin. </s> cut -d ' ' -f 2
Find all .gz archives in the /path/to/dir directory tree </s> find /path/to/dir -name "*.gz" -type f
Set permissions to 644 for all regular files under the current directory tree that have permissions 755 </s> find . -type f -perm 755 -exec chmod 644 {} \;
Find all executable files under current directory and show a few lines of output from the beginning </s> find . -perm /a=x | head
Find all PHP files in the current directory recursively and search them for string "$test" with 8 simultaneous processes </s> find . -name \*.php -type f -print0 | xargs -0 -n1 -P8 grep -Hn '$test'
find all the files that have been modified in the last 1 day ago </s> find -mtime -1
recursively change owner and group of the directory /your/directory/to/fuel/ and all files into it to user and group nginx </s> chown nginx:nginx /your/directory/to/fuel/ -R
extract "filename.tar.xz" with verbose output </s> $ tar xvfJ filename.tar.xz
display all the regular files in the current folder excluding those that are present in the path "git" </s> find . -path "*.git*" -prune -o -type f -print
find all files in the current directory and sub-directories that were modified after the /etc/passwd file was modified </s> find -newer /etc/passwd
Prints all child processes of a process with id 20238. </s> pstree -p 20238 | sed 's/(/\n(/g' | grep '(' | sed 's/(\(.*\)).*/\1/'
find all javascript files under the current folder </s> find . -name '*.js'
Sort file "file" by line </s> sort file -o !#^
Find all regular .mp3 files larger than 10M and delete them </s> find / -type f -name *.mp3 -size +10M -exec rm {} \;
list all regular files which path is not dir1 or dir2 </s> find dir -not \( -path "dir1" -prune \) -not \( -path "dir2" -prune \) -type f
Print all business days in the current month without column titles </s> cal -h | cut -c 4-17 | tail -n +3
find all the files in the current directory which start with t and have been modified between one hour (60 minutes) and 12 hours (720 minutes) ago. </s> find . -mmin -720 -mmin +60 -type f -name "t*" -exec ls -l '{}' \;
Rename "Tux.png" to ".Tux.png" </s> mv Tux.png .Tux.png
Scan every file in /etc for IPV4 addresses. </s> find /etc -exec grep '[0-9][0-9]*[.][0-9][0-9]*[.][0-9][0-9]*[.][0-9][0-9]*' {} \;
Gets IP addresses of all network interfaces. </s> ifconfig | grep -E "([0-9]{1,3}\.){3}[0-9]{1,3}" | grep -v 127.0.0.1 | awk '{ print $2 }' | cut -f2 -d:
Create a symbolic link in the current directory for each file under the directories matching "../[12][0-9][0-9]" </s> find ../[12][0-9][0-9][0-9] -type f -exec ln -s {} \;
Search the current directory tree for files and directories whose names do not end in "exe" and "dll" </s> find . | grep -v '(dll|exe)$'
Find all *fink* files/directories in entire file system </s> find / \( -type f -or -type d \) -name \*fink\* -print
Search the current directory tree for regular files last changed more than 14 days ago </s> find -type f -ctime +14
find all the files in the entire file system which belong to the user "roger" </s> find / -user roger -print
Find all directories by the name `httpdocs' on the system </s> find / -type d -name 'httpdocs'
display all files in the current folder expect text files </s> find . -name "*.txt" -prune -o -print
Replace spaces with underscores in the names of all files and directories in the "/tmp" directory tree </s> find /tmp/ -depth -name "* *" -execdir rename " " "_" "{}" ";"
Find directory "your/dir" if it is empty </s> find your/dir -prune -empty -type d
Sort "file1.txt" and output the result to "file1.txt" </s> sort -o file1.txt file1.txt
find  files which full path name is foo/bar under foo directory and print </s> find foo -path /tmp/foo/bar -print
find all empty files in home directory </s> find ~ -empty
Remove all .txt files with spaces in names in and below the current directory </s> find -name "*\ *.txt" | xargs rm
find all files in current folder which have been accessed exactly 10 minutes ago </s> find . -amin 10
List all files/directories under /myfiles directory </s> find /myfiles -exec ls -l {} ;
display the name of all directories in the current folder and do not search in sub directories </s> find . -type d -maxdepth 1 -exec basename {} \;
Find all regular files that reside in the current directory tree and were last modified more than 1 day ago </s> find . -type f -mtime +1
display all file in the home folder except ".c" files </s> find $HOME -not -iname "*.c" -print
Find 10 largest files in the current directory and its subdirectories </s> du -hsx * | sort -rh | head -10
Find all files in the /etc folder that have been modified within the last 30 days and copy them to /a/path/. </s> find /etc/ -mtime -30 | xargs -0 cp /a/path
find and delete all the empty directories in the current folder and all its sub directories too </s> find . -depth -empty -type d -delete
Print only unique lines in files 'set1' and 'set2' </s> cat set1 set2 | sort -u
Find all PHP files under current directory </s> find . -type f -name *.php
Report file system containing /example disk usage in kilobytes. </s> df -k /example
Add read permission for 'other' for all files/directories named 'rc.conf' under current directory tree </s> find . -name "rc.conf" -exec chmod o+r '{}' \;
display all regular/normal files which have been modified in the last 30 minutes </s> find -type f -and -mmin -30
Find strings with 'Features' in /var/run/dmesg.boot' file </s> cat /var/run/dmesg.boot | grep Features
Find all regular files with '.jpg' (case insensitive) extension, sort them by name, print the output  and also save the list to file 'file_list.txt' </s> find . -type f|grep -i "\.jpg$" |sort| tee file_list.txt
Find all files under "/path" that do not contain a "." and append ".jpg" to their file name </s> find /path -type f -not -name "*.*" -print0 | xargs -0 rename 's/(.)$/$1.jpg/'
Print second section of line <line> where sections are separated by one or more whitespace. </s> echo -e "<line>" | sed 's:\s\+:\t:g' | cut -f2
Add group write permission to all files in the current directory </s> find . -maxdepth 0 -type f -exec chmod g+w {} ';'
Find all files under /home/username/public_html/sites/all/modules and set their permission to 640 </s> find /home/username/public_html/sites/all/modules -type f -exec chmod 640 {} +
Set permissions to 600 for regular files under media/ </s> find media/ -type f -exec chmod 600 {} \;
Remove all regular files found in and below /path </s> find /path -type f -print | xargs rm
Find all directories named "D" in the current directory tree </s> find . -name "D" -type d
List all *.txt files/directories under current directory </s> find . -name "*.txt" -exec $SHELL -c 'echo "$0"' {} \;
Copy file header.shtml to directories dir1, dir2, dir3, and dir4 </s> find dir1 dir2 dir3 dir4 -type d -exec cp header.shtml {} \;
delete all the empty files in the current directory </s> find . -empty -exec rm {}\;
Create a symbolic link in directory "/path/to/dir" for each file and directory under the current directory starting with "." </s> find $PWD -name '.[^.]*' -exec ln -s '{}' /path/to/dir \;
Find all *.html files under current directory and for each file replace the first occurrence of STRING and previous lines with the content of common_header file </s> find . -type f -name '*.html' -exec sed -i -e '1r common_header' -e '1,/STRING/d' {} \;
Delete all contents form the files that contain the case insensitive regex 'stringtofind' in maximum 1 level down the / directory excluding other partitions </s> find / -maxdepth 1 -xdev -type f -exec grep -i "stringtofind" -q "{}" \; -print0 | xargs -0 sed '/./d'
Find all files named "filename" in the current directory tree, not descending into "FOLDER1" directories </s> find . -name FOLDER1 -prune -o -name filename
change the extension of all the ".abc" files in the folder "/the/path" to ".edefg" and do not change in the sub directories </s> find /the/path -depth -name "*.abc" -exec rename 's/\.abc$/.edefg/' {} +
Print file type of the executable file of command "python" </s> file `which python`
Identify CMS version/releases accross all your Wordpress websites </s> find /home/*/public_html/ -type f -iwholename "*/wp-includes/version.php" -exec grep -H "\$wp_version =" {} \;
Change group ownership to `foo' for files with GID=2000 </s> find / -group 2000 -exec chgrp -h foo {} \;
Find all *.rb (regular) files under current directory ensuring white space safety and print at most two file names/paths per line </s> find . -name "*.rb" -type f -print0 | xargs -0 -n 2 echo
Print a count of duplicate lines in "filename" sorted by most frequent </s> sort filename | uniq -c | sort -nr
Find and remove zero bytes files from user's directories . </s> find /usr/* -size 0c -exec rm {} \;
Remove files in the current directory tree whose names match pattern "file?" </s> find . -name "file?" -exec rm -vf {} \;
display a long listing of all the xls or csv files in the entire file system </s> find / -type f \( -name "*.xls" -o -name "*.csv" \) -exec ls -l {} \;
find all files that names are filename and open in nano text editor </s> find / -name filename -exec  nano '{}' \;
Find SUID files </s> find / -perm +4000
Find files under current directory that are not newer than $date_time in regards of modification time </s> find . -type f -not -newermt "$date_time"
Find all *.jpg files and copy them to / </s> find / -type f -name *.jpg  -exec cp {} . \;
Find all files on the system that have been modified in the last 10 minutes </s> find / -mmin -10
Search the 'tmp' directory for .mp3 files </s> find tmp -maxdepth 1 -name '*.mp3'
Print line number of each line in /etc/passwd file, where current user name is found </s> cat /etc/passwd -n | grep `whoami` | cut -f1
display the three largest files by size in current folder </s> find . -type f -exec ls -s {} + | sort -n -r | head -3
Save the md5 sum hash of "${my_iso_file}" to variable "md5" </s> md5=`md5sum ${my_iso_file} | awk '{ print $1 }'`
delete all the files ending with "~" in current folder </s> find -name '*~' -print0 | xargs -0 rm
Prints total count of lines of all files in a current folder and subfolders. </s> find . -type f -exec wc -l {} \; | awk '{ SUM += $0} END { print SUM }'
list jobs including its PIDs </s> jobs -l
Delete all files/directories named 'file' under current directory tree </s> find -name file -delete
Set the shell option 'errexit'  causing bash to exit immediately if one of the commands in a multi-command statement fails. </s> set -e
Counts lines of all *.txt files in a current folder. </s> cat *.txt | wc -l
delete all the files in the current folder which do not belong to any user </s> find . -nouser | xargs rm
Find all regular files that reside in the current directory tree and were last modified more than 7 days ago </s> find . -type f -mtime +7
Search all files under and below /etc for IP addresses </s> find /etc -exec grep '[0-9][0-9]*[.][0-9][0-9]*[.][0-9][0-9]*[.][0-9][0-9]*' {} \;
Output only the filetype suffix of "foo.tar.gz", in this case "gz" </s> echo "foo.tar.gz" | rev | cut -d"." -f1 | rev
Create tar archive "dirall.tar" and copy all files from directory tree /tmp/a1 to it </s> find /tmp/a1 -exec tar -rvf dirall.tar {} \;
Change the owner to "hduser" and group to "hadoop" of "{directory path}" </s> sudo chown hduser:hadoop {directory path}
Find all *.rb files/directories under current directory </s> find . -name "*.rb"
find all files in the home folder that are modified in the last 24 hours </s> find $HOME -mtime -1
find the md5 sum of all the regular files in multiple folders and display them in sorted order </s> find teste1 teste2 -type f -exec md5 -r {} \; | sort
Split "file.txt" excluding the first line into files with at most 20 lines each and a prefix "split_" </s> tail -n +2 file.txt | split -l 20 - split_
List all *.txt files/directories under /etc </s> find /etc -name "*.txt" -ls
search for a word in all the normal/regular files in the current folder </s> find . -type f | xargs grep "text"
Remove all regular non-hidden files modified more than 7 days ago and residing in the /tmp directory tree </s> find /tmp -type f -name '*' -mtime +7 -print0 | xargs -0 rm -f
Change the permission to 644 for all files under current directory </s> find . -type f | xargs -I{} chmod -v 644 {}
For each line which has a common first field in file1.csv and file2.txt, output the first 4 fields of file1.csv </s> join -o 1.1,1.2,1.3,1.4 -t, <(sort file1.csv) <(sort file2.txt)
Display machine architecture, ie. x86_64 </s> uname -m
Remove all files in the $backup_path directory recursively that were last modified more than 30 days ago </s> find $backup_path/* -mtime +30 -exec rm {} \;
Removes any empty folder that matches pattern ed*. </s> rmdir ed*
Find all files/directories starting with 'onlyme' in their names under current directory tree in minimum 1 level deep </s> find . -mindepth 1 -name 'onlyme*'
Edit the cron job list for user 'wwwrun' using default editor specified by the EDITOR environment variable, or /usr/bin/editor if no default editor is specified. </s> sudo crontab -u wwwrun -e
Recursively find all files ending with '*.txt' and print they names and content </s> find  . -name \*.txt -print -exec cat {} \;
Modify and rewrite 'file' replacing all instances of "foo" with "bar" </s> sed -i 's/foo/bar/g' file
Find all *.php files under current directory and change their permission to 644 </s> find . -type f -name '*.php' -exec chmod 644 {} \;
display all regular/normal files in the current folder ending with the word ummy </s> find -type f -name *ummy
Raise an error for using uninitialized variables </s> set -u
Gets MAC addresses of all active network interfaces. </s> ifconfig | awk '$0 ~ /HWaddr/ { print $5 }'
Prints long listing of the current directory and top-level directories within, sorted from oldest to newest, with appended indicators. </s> $ ls -Fltr *
Print the ping statistics of 4 requests to "www.google.com" </s> ping -c4 www.google.com | awk '/---/,0'
Print all filenames in /usr/src except for those that are of the form '*,v' or '.*,v' </s> find /usr/src -not \( -name "*,v" -o -name ".*,v" \) '{}' \; -print
Removes all empty folders under path '/thepath', printing info message on each operation. </s> find /thepath -type d -empty -print0 | xargs -0 rmdir -v
recursively change user of the direct public_html and all files into it to user owner </s> chown -R owner:owner public_html
Find all *.* files under current directory </s> find . -type f -a -name '*.*'
Search the current directory tree for regular files that were changed $FTIME days ago </s> find . -type f -ctime $FTIME
Search for files which have read and write permission for their owner, and group, but which other users can read but not write to. </s> find . -perm 664
find all the files in the current folder which do not have the execute permission </s> find . -type d ! -perm -111
Recursively change the owner and group of "subdir2" to "user2" </s> chown user2:user2 -R subdir2
create a symbolic link in current directory named "my_db" to file "/media/public/xampp/mysql/data/my_db" </s> ln /media/public/xampp/mysql/data/my_db -s
Find all regular files under and below /root that match pattern "*linux*", case insensitive </s> find /root -type f -iname "*linux*"
Find all files/directories with '.js' extension under current directory tree without descending into  and ignoring './directory' completely </s> find . -not \( -path ./directory -prune \) -name \*.js
Find all TXT files in the current directory and copy them to directory "$HOME/newdir" </s> find "$HOME" -name '*.txt' -type f -print0 | xargs -0 cp -ut "$HOME/newdir"
Count the number of directories under directory '/directory/' non-recursively </s> find /directory/ -maxdepth 1 -type d -print| wc -l
Find all files under current directory and set their permission to 775 </s> find -type f | xargs chmod 775
Search the current directory recursively for regular files last accessed more than 2 minutes ago </s> find . type -f -amin +2
display the change owner command for all the regular files in the current folder. </s> find . -type f -exec echo chown username {} \;
Count the number of files in the directory trees whose pathnames match pattern '/dev/sd*[a-z]' </s> find /dev/sd*[a-z] | wc -l
change the permissions of all the files ending with "fits" in the folder "/store/01" </s> find /store/01 -name "*.fits" -exec chmod -x+r {} \; \
find all the configuration files which have been accessed in the last 30 minutes. </s> find /etc/sysconfig -amin -30
displays all files in the current directory </s> find .
Find all *shp* files/directories under current directory and move them to ../shp_all/ </s> find . -name "*shp*" -exec mv {} ../shp_all/ \;
Find all *.txt files/directories under current directory terminating their names/paths with null character </s> find . -name '*.txt' -print0
Count the number of all directories under current directory non-recursively </s> find . -mindepth 1 -maxdepth 1 -type d | wc -l
login as user postgres </s> sudo su -l oracle
Merge already sorted files in the current directory starting with "_tmp" and write the output to "data.tsv.sorted" </s> sort -m _tmp* -o data.tsv.sorted
Locate all files "needle.txt" </s> find . -name "needle.txt"
Move "tobecopied/tobeexcluded" to the current directory </s> mv tobecopied/tobeexcluded .
find files under the current directory containing a space in the filename and delete them </s> find . -name "* *" -exec rm -f {} \;
Copy file or directory 'gtest' from directory 'include' in current directory to /usr/include, preserving ownerships and permissions. </s> sudo cp -a include/gtest /usr/include
Delete all .pyc files in the current directory tree </s> find . -name "*.pyc" | xargs -0 rm -rf
Change permissions to 644 for all files showing the respective chmod command </s> find ./ -type f -print0 | xargs -t -0 chmod -v 644
find all the files in the current directory and print them excluding those that have the name SCCS. </s> find . -print -o -name SCCS -prune
display all files in current folder which have not been modified in the last 60 minutes </s> find -mmin +60
Unzip every ".gz" file in the current directory tree </s> find . -name '*.gz' -exec gunzip '{}' \;
Copies newest file under the current folder to the '/tmp/' </s> cp $(ls -1tr * | tail -1) /tmp/
find all text files in user/directory/ which have been modified today and display the last line of these files </s> find /user/directory/ -name "*txt" -mtime 0 -type f -printf '%p: ' -exec tail -1 {} \;
display all the regular/normal files in the folder "/home/user/demo" which have the permission 777. </s> find /home/user/demo -type f -perm 777 -print
Print the list of files from the "/zu/durchsuchender/Ordner" directory tree whose names begin with "beispieldatei" and which contain string "Beispielinhalt" </s> find "/zu/durchsuchender/Ordner" -name "beispieldatei*" -print0 | xargs -0 grep -l "Beispielinhalt"
find all the files in the entire file system whose size is exactly 15MB </s> find / -size 15M
find all the cpp files in the current folder and move them to another folder </s> find . -type f -iname '*.cpp' -exec mv {} ./test/ \;
display all text files in a folder </s> find $target -type f -iname "*.txt"
Find files under current directory that contains the string '/bin/ksh' </s> find . -type f -print | xargs    grep -il 'bin/ksh'
Report file systems disk usage human-readable using POSIX output format. </s> df -Ph
Find all files under var/ directory and change their permission to 600 </s> find var/ -type f -exec chmod 600 {} \;
Print information about all users who are logged in </s> who -la
Clear the in-memory history and read from the current history file </s> history -cr
Go to first directory specified in PATH which contains the command 'oracle' </s> cd $(which oracle | xargs dirname)
Recursively finds all folders in a current folder that contain files like '.git'. </s> find . -name '.git' | xargs dirname
Display all lines containing UTRACE in the current kernel's compile-time config file. </s> grep UTRACE /boot/config-$(uname -r)
Print the day 1 day ago </s> date --date='1 days ago' '+%a'
find all the "jpg" file in a folder. </s> find /win/C -iname *JPG
search for a word in all c files in the current folder </s> find . -name '*.c' | xargs grep 'stdlib.h'
Displays the count of of each unique line read from standard input </s> sort | uniq -c
Find all files/directories named 'fprintf.c' under '/usr/src' directory tree </s> find /usr/src -name fprintf.c
Find all *.mp4 files under directory named 'working' and show the first one found </s> find working -type f -name "*.mp4" | head -1
find all the files in the current directory and change the permissions to 775. </s> find . -exec chmod 775 {} \;
find all the files in the current folder which have execute permission </s> find . -executable
Find all files under /path and below executable by `group' or `other' </s> find /path -perm /011
display all files in current folder which have been modified in the last 60 minutes </s> find -mmin 60
Generates name for temporary file with 6-letter suffix, and saves path to that new file in 'fn' variable. </s> fn=$(mktemp -u -t 'XXXXXX')
Prints string "0 1 * * * /root/test.sh" to the terminal, and append it to file '/var/spool/cron/root' </s> echo "0 1 * * * /root/test.sh" | tee -a /var/spool/cron/root
Search the home directory for OGG and MP3 files </s> find $HOME -iname '*.ogg' -o -iname '*.mp3'
Delete all .svn directories under current directory </s> find . -type d -name .svn -print0|xargs -0 rm -rf
Calculate the md5 sum of hex byte 61 </s> echo -n -e '\x61' | md5sum
Find all *.ini files </s> find . -name *.ini
Assign permissions 644 to files in the current directory tree </s> find . -type f -print0 | xargs -0 chmod 644
Remove the last 3 characters from 987654321, keeping only 987654 </s> echo 987654321 | rev | cut -c 4- | rev
Find all files on your system that are world writable </s> find / -wholename  '/proc' -prune  -o  -type f -perm -0002 -exec ls -l {} \;
display list of all the regular/normal files in the home folder which are exactly 6579 bytes </s> find /home/ -type f -size 6579c -exec ls {} \;
find all the files in the current folder that have been modified in the last 24*3 hours </s> find ./ -mtime -3
Search the regular files of the current directory tree for string "texthere" </s> find -type f -exec grep -Hn "texthere" {} +
Create 5 empty .txt files </s> echo "a.txt b.txt c.txt d.txt z.txt" | xargs touch
find all the files that have been modified exactly 1 day ago </s> find -mtime 1
Find all files in the current directory tree, except GIT files </s> find -type f -name .git -prune -o -print
List file contents of compressed file 'compressed.tar.gz' </s> gzip -l compressed.tar.gz
Find all of jzb's files </s> find -user jzb
Search directory trees /tmp and /var/tmp for "testfile.txt" </s> find /tmp /var/tmp -iname "testfile.txt"
change the permissions of all the regular/normal files in the folder "/path/to/someDirectory" to 644 </s> sudo find /path/to/someDirectory -type f -print0 | xargs -0 sudo chmod 644
Remove all regular files found in and below /path </s> find /path -type f -exec rm '{}' +
show all regular/normal the files in the current folder whose size is bigger than 0 bytes excluding everything </s> find * -prune -type f -size +0c -print
Read standard input and replace any repeated characters except spaces with a single instance </s> tr -cs '[:space:]'
Recursively removes all files like '._*' from current folder. </s> find . -name "._*" -print0 | xargs -0 rm -rf
Archive "/home/user1" to "wobgalaxy02:/home/user1" excluding hidden files </s> rsync -av /home/user1 wobgalaxy02:/home/user1
Find all files/directories named 'document' in the root filesystem partition </s> find / -xdev -name document -print
Find all symlinks under current directory </s> find . -type l
Archive "/path/to/files" to "user@targethost:/path" </s> rsync -av /path/to/files user@targethost:/path
Count the number of areas that differ in "file1" and "file2" with 0 lines of unified context </s> diff -U 0 file1 file2 | grep ^@ | wc -l
Save the directory name of the current bash script to variable "path" if it is found in one of the directories specified by PATH. </s> path="$( dirname "$( which "$0" )" )"
Exclude directory from find . command </s> find -name "*.js" -not -path "./directory/*"
Print "file1.txt" "file2.txt" and "file3.txt" with filename headers </s> tail -n +1 file1.txt file2.txt file3.txt
Find files with size more than 200557600B and which are more than 2 days old under  ${userdir}/${i}/incoming directory </s> find ${userdir}/${i}/incoming -mtime +2 -type f -size +200557600c -ls
Search the .cs files of the current directory tree for string "content pattern" </s> find ./ -type f -iname "*.cs" -print0 | xargs -0 grep "content pattern"
Delete all lines matching "some string here" in "yourfile" </s> sed --in-place '/some string here/d' yourfile
Find all files on the system that are world writeable </s> find / -perm -0002
Find all the files which are accessed in last 1 hour in entire file system </s> find / -amin -60
Replace all instances of ";" with "\n" in "bla@some.com;john@home.com" </s> echo "bla@some.com;john@home.com" | sed -e 's/;/\n/g'
Search the current directory tree for files containing "album" and "vacations" in their names and not containing "2015" </s> find . -name "*album*" -a -name "*vacations*" -a -not -name "*2015*"
Create an empty file 'last.check' in directory pointed by variable "log_dir", with specified timestamp. </s> touch -m 201111301200.00 $log_dir/last.check
Search the current directory for regular files whose names start with my </s> find . -name 'my*' -type f
display all the regular/normal files in the current directory </s> find . -type f
find .gif files in /var/www and below that were last changed between 90 and 180 days ago </s> find /var/www -name *.gif -ctime +90 -ctime -180
Find all directories named 'local' in entire file system </s> find / -name local -type d
Find all files/directories in the paths expanded by the glob pattern '.*' </s> find .*
display long listing of all the text files in the current folder </s> find . -name "*.txt" -exec ls -la {} \;
List all files in the current directory tree that were modified 60 minutes ago </s> find . -mmin 60 | xargs '-rd\n' ls -l
display all the directories in the current folder </s> find . -type d
Find all files under $YOUR_DIR </s> find $YOUR_DIR -type f
Merge lines whose first comma-separated field in file 'in1' also appears as a first comma-separated in file 'in2' - both files must be sorted, and the output format of each line will be: first field of in1, second field of in2, and third field of in2. </s> join -t, -o 1.1,1.2,2.3 in1 in2
Non-recursively finds all '*.pdf' files in a current folder and removes them. </s> find -maxdepth 1 -name '*.pdf' -exec rm "{}" \;
Merge colon-separated information from standard input and file1.txt where the first field of both files matches, print unpairable lines from standard input, replace missing fields with "no-match", and output the second field from standard input and the second and third field from file1.txt </s> join -t, -o 1.2,2.2,2.3 -a 1 -e 'no-match' - <(sort file1.txt)
Locate all the hard links of file `passwd' </s> find / -samefile passwd
Generates default-formatted file name of temporary file in a /dev/mapper folder, and saves path to it in a variable 'MAPPER'. </s> MAPPER=$(mktemp -up /dev/mapper)
Split "input.txt" into files of at most 10 bytes each with prefix "/tmp/split-file" </s> split -b 10 input.txt /tmp/split-file
Replace all occurrence of "subdomainA.example.com" with "subdomainB.example.com" in all files under /home/www and below </s> find /home/www/ -type f -exec sed -i 's/subdomainA\.example.com/subdomainB.example.com/g' {} +
Recursively finds all files with whole word "pattern" in a current folder, and precedes found string with its number in file. </s> grep -rnw `pwd` -e "pattern"
change owner of the file process to user root </s> sudo chown root process
Search for files with "sitesearch" in their names and "demo" in their path names </s> find . -iname '*sitesearch*' | grep demo
Descend into every directory under /etc and print the file/directory names with relative paths </s> find /etc -execdir echo "{}" ';'
Find all files in the current directory tree and count them </s> find | wc -l
Read a single character from standard input into variable "doit" with prompt "Do that? [y,n]" </s> read -n1 -p "Do that? [y,n]" doit
find all the directories in the home folder do not search in sub directories </s> find /home -maxdepth 1 -type d
Print only printable characters from "/dev/urandom" </s> cat /dev/urandom | tr -dC '[:graph:]'
Count the number of users logged in </s> who | wc -l
search for files which are writable by either their owner or their group </s> find . -perm /u=w,g=w
find all the html files in the current folder which have been modified exactly 7 days ago </s> find . -mtime 7 -name "*.html" -print
Change owner and group of "script.sh" to "root" </s> chown root:root script.sh
recursively change owner of the directory /tmp to the current user </s> sudo chown -R $USER ~/tmp
find all the symbolic links in the current folder </s> find /etc -type l -print
Find all files in $dir directory without going into sub-directories and print only their names preceded by 3 spaces </s> find "$dir" -maxdepth 1 -type f | sed 's#.*/#   #'
Search all files in the current directory tree that are named "whatever" for "whatever" </s> find . -name whatever -print | xargs grep whatever
Search every directory except the subdirectory excluded_path for a regular file 'myfile' </s> find / -path excluded_path -prune -o -type f -name myfile -print
Find every file/directory under the directory /home owned by the user joe </s> find /home -user joe
Print the empty files/directories among empty1, empty2 and not_empty </s> find empty1 empty2 not_empty -prune -empty
Run "command" on server "host" as user "user" </s> echo "command" | ssh user@host
Find all orm.* files/directories under current directory </s> find . -name "orm.*"
create a tar file of all the songs on my system that have been modified in the last 180 days (which is essentially six months) </s> find . -name -type f '*.mp3' -mtime -180 -print0 | xargs -0 tar rvf music.tar
Search  in current directory downwards all files whic  have permission 777 . </s> find . -perm 777 -print
Find all directories named CVS, and deletes them and their contents. </s> find . -type d -name CVS -exec rm -r {} \;
Gives the primary group of $USERNAME. </s> groups $USERNAME | cut -d\  -f 1
Remove everything in a current folder without prompting. </s> find -mindepth 1 -maxdepth 1 -print0 | xargs -0 rm -rf
change the permissions of all the directories in the current folder, print0 is used for handling files with newlines in their file name </s> find . -type d -print0 | xargs -0 chmod 2775
Search for files/directories with a case insensitive .txt extension in entire file system </s> find / -iname '*.txt'
split file data.csv into pieces per 100 lines </s> split -l 100 date.csv
Split "hugefile.txt" into files with 100000 lines each starting with "part." and using numeric suffixes </s> split -a4 -d -l100000 hugefile.txt part.
Display list of files ending with '.txt' in the current folder to the terminal twice and output it to the text file "txtlist.txt" </s> ls *.txt | tee /dev/tty txtlist.txt
Find all files/directories under current directory and print their paths </s> find . -exec echo {} +
Create symbolic links in the current directory for all files under "bar1" that are not directories and do not end in ".cc" </s> find bar1 -name '*foo*' -not -type d -not -name '*.cc' -exec ln -s $PWD/'{}' bar2/ \;
Create a symbolic link named "foo" to "/var/cache/apt/archives/bash_4.3-14ubuntu1_amd64.deb" </s> ln -s   /var/cache/apt/archives/bash_4.3-14ubuntu1_amd64.deb foo
display a list of all files in the folder passed as argument to a script </s> find $@ -ls
Locating large files (> 100 MB) in /home/ for 'cleaning' </s> find /home -type f -size +100M -delete
Execute "ls -l" on host "something" as user "root" </s> ssh root@something 'ls -l'
Search the current directory tree for regular files whose names end in ".shtml" or ".css" </s> find . -type f | egrep '\.(shtml|css)$'
Print only first line of 'file' content, formatted as 29-symbol wide column, regarding space symbol as a word separator </s> cat file | fold -s -w29 | head -1
Set variable BZIP2_CMD to the full path of command "bzip2" </s> BZIP2_CMD=`which bzip2`
Find files/directories in entire file system that had their meta information changed more than 3 days ago </s> find / -ctime +3
Search history for "part_of_the_command_i_still_remember_here" </s> history | grep 'part_of_the_command_i_still_remember_here'
Return 0 if file system is mounted on '/full/path' </s> df /full/path | grep -q /full/path
Find all OGG files in the home directory larger than 20 megabytes </s> find $HOME -iname '*.ogg' -size +20M
delete all the files in the file system which belong to the user edwarda after user confirmation </s> find / -user edwarda -ok rm "{}" \;
find all the regular files in current folder, that have been changed in the last 3 days and display last 5 files </s> find . -type f -ctime -3 | tail -n 5
find all js files under the build direcotry except build/external and build/log directory. </s> find build -not \( -path build/external -prune \) -not \( -path build/blog -prune \) -name \*.js
Display the contents of "sample_0001.gz" with "lk=1&" removed </s> zcat sample_0001.gz | sed -e 's/lk=1&//g'
Print unique lines in sorted "file1" compared to sorted file "file2" </s> comm -23 file1 file2
removes last N lines from file.txt </s> head --lines=-N file.txt
Remove all *.mp3 files in tmp directory but not in it's subdirectories </s> find tmp -maxdepth 1 -name '*.mp3' -maxdepth 1 | xargs    rm
Display differences between files dir1.txt and dir2.txt. </s> diff dir1.txt dir2.txt
Find all directories starting from the current directory </s> find . -type d
find all .pm, .pl files in /users/tom and search for multiple pattern in same files and display the matched file names </s> find /users/tom -name '*.p[lm]' -exec grep -l -- '->get(' {} + | xargs grep -l '#hyphenate'
find all files without 777 permision </s> find / -type f ! perm 777
find all files in the current directory do not display the files which do not have read permission to all users </s> find . ! -perm -g+r,u+r,o+r -prune
Read one character from standard input into variable 'c' </s> read -n 1 c
Print file system disk space usage </s> df
Remove containing directories from variable 'path' ie. "/some/specific/directory" becomes "directory". </s> path=$(basename $path)
display all the text files  in the current folder </s> find . -name "*.txt" -print
Find all files in the file system with the SUID bit </s> find / -perm -u+s -print
search for the file "foo.txt" in the entire file system </s> find / -name foo.txt
Execute awk script "script.awk" that exists in "$PATH" with argument "arg1" </s> awk -f `which script.awk` arg1
Print chmod commands that can change permissions of regular files residing in the current directory tree to u=rw,g=r,o= </s> find . -type f -exec echo chmod u=rw,g=r,o= '{}' \;
List every symbolic link in every home directory's subdirectory owned by group `staff' </s> find `pwd` -group staff -exec find {} -type l -print ;
Search the /root directory recursively for the regular file named "myfile" ignoring "work" directories </s> find /root/ -name 'work' -prune -o -name myfile -type f -print
Find *.scm files recursively in the current directory </s> find . -name '*.scm'
Changes group ownership of '/var/run/fcgiwrap.socket' to 'forge'. </s> chgrp forge /var/run/fcgiwrap.socket
Find all directories in the /data1/realtime directory tree that were last modified more than 5 minutes ago but less than 60 minutes ago </s> find /data1/realtime -mmin -60 -mmin +5 -type d
Report only total size of file systems in 1T blocks. </s> df --total -BT | tail -n 1 | sed -E 's/total *([^ ]*).*/\1/'
Finds files in 'directory' folder with the same name and location but different content than files in 'directory.original' folder and prints location of such files. </s> diff -qr directory directory.original | cut -d' ' -f2 | xargs dirname | uniq
Fix files to default permissions 755 </s> find . -type d -exec chmod 755 {} \;
Set variable OS to the name of the operating system, ie. "Linux" </s> OS=$(uname -s)
Display the last slash-separated part of each filename path in file.txt </s> rev file.txt | cut -d/ -f1 | rev
find the most recently changed files under current directory </s> find . -type f -printf '%TY-%Tm-%Td %TT   %p\n' | sort
Process each file beginning with "file" in the current directory as an argument to "bash script.sh" </s> find -type f -maxdepth 1 -name 'file*' -print0 | sort -z | xargs -0 bash script.sh
find all the files that have been modified in the last 2 day </s> find -daystart -mitime -1
find all the files in the current directory and search for the word "pw0" in them. </s> find . -exec grep -i "pw0" {} \;
Find all *.plist files/directories under current directory </s> find -name \*.plist
search for all the regular/normal files in the current folder which start with "my" </s> find . -name 'my*' -type f
force create hard link between $GIT_DIR/../apresentacao/apresentacao.pdf and $GIT_DIR/../capa/apresentacao.pdf </s> ln -f $GIT_DIR/../apresentacao/apresentacao.pdf $GIT_DIR/../capa/apresentacao.pdf
print all readline bindings </s> bind -P
Change permissions to 755 for all directories in the current directory tree </s> find . -type d | xargs chmod -v 755
Show the list of files that are owned by user wnj or are newer than file `ttt' </s> find / \( -newer ttt -or -user wnj \) -print
display all the directories in the current folder for the files which have not been accessed in the last 48 hours </s> find . -type d -atime +2
Remove all files with names like "vmware-*.log" from the current directory tree </s> find . -name vmware-*.log -print0 | xargs -0 rm
Search the current directory tree for hidden files skipping .htaccess </s> find . -type f \( -iname ".*" ! -iname ".htaccess" \)
remove all core dump files from user's home directory </s> find ~/ -name 'core*' -exec rm {} \;
display all normal/regular files in current directory </s> find . -type f
Search for 'Attached: Yes' in all regular files under '/proc/scsi' directory tree matching the path '/proc/scsi/usb-storage' and show only the matched filenames </s> find /proc/scsi/ -path '/proc/scsi/usb-storage*' -type f | xargs grep -l 'Attached: Yes'
Returns unsuccessful exit code on each found file like '*tests*' within current directory. </s> find . -name '*tests*' -print -exec false \;
find all the png files in the current folder which are present in the pattern list search .txt </s> find . -name '*.png' | grep -f search.txt
Print canonical filename of "/path/there/../../" even if it does not exist </s> readlink -m /path/there/../../
Find files that were modified in less than 1 minute ago </s> find / -mmin -1
Save full path of command "tr" to variable "TR" </s> TR=`which tr`
Search the /Path directory tree for files matching pattern "file_name*" </s> find /Path -name "file_name*"
Compare sorted files 'f1.txt' and 'f2.txt' and print in three columns strings unique for first file, second file, and common ones </s> comm <(sort f1.txt) <(sort f2.txt)
Display bash function definition of "foobar" </s> set | grep -A999 '^foobar ()' | grep -m1 -B999 '^}'
Delete all regular files that have not been modified in the last 31 days under '/path/to/junk/files' directory tree </s> find /path/to/junk/files -type f -mtime +31 -exec rm -f {} \;
Find all directories named '.texturedata' under '/path/to/look/in/' directory tree </s> find /path/to/look/in/ -type d -name '.texturedata'
Search the current directory tree for the files with extension "trc" and remove them if they are more than three days old </s> find . -name "*.trc" -ctime +3 -exec rm {} \;
Find all directories in the /data1/realtime directory tree that were modified within the last 60 minutes </s> find /data1/realtime -mmin -60 -type d
Append "foo" and "bar" column in file "file" with values dependent on the current table contents </s> awk 'NR==1 {print $0, "foo", "bar"; next} {print $0, ($2=="x"?"-":"x"), ($4=="x"?"-":"x")}' file | column -t
Move all hidden files in "/path/subfolder/" to "/path/" </s> mv /path/subfolder/.* /path/
Recursively change the owner of all "*.txt" files under "/mydir" to "root" </s> find /mydir -type f -name "*.txt" -execdir chown root {} ';'
Find *.java files in the current directory with GNU find and replace foo with bar in those files </s> find . -name "*.java" -exec sed -i s/foo/bar/g \;
Remove everything within parentheses and substitute all non digit characters with a space from "1/2 [3] (27/03/2012 19:32:54) word word word word 4/5" and format the output as a table </s> echo '1/2 [3] (27/03/2012 19:32:54) word word word word 4/5' | sed -e 's/(.*)//' -e 's/[^0-9]/ /g' | column -t
Change the ownership of "file.sh" to "root" </s> sudo chown root file.sh
Rename all .jpg files to .jpeg under the current directory and below </s> find  | rename 's/\.jpg$/.jpeg/'
Find all files/directories named 'openssl' under current directory tree without printing 'Permission denied' error messages </s> find . -name "openssl" | sed '/Permission denied/d;'
Unzip and untar "myarchive.tar.gz" and check for corruption </s> gunzip -c myarchive.tar.gz | tar -tvf -
search through only the /usr and /home directories for any file named Chapter1.txt </s> find /usr /home -name Chapter1.txt -type f
find all the directories in the current folder which have been modified in 24 hours and move them to the folder  /path/to/target-dir </s> find . -depth -type d -mtime 0 -exec mv -t /path/to/target-dir {} +
Show a long listing of files not modified in over 20 days or not accessed in over 40 days </s> find /mydir \(-mtime +20 -o -atime +40\) -exec ls -l {} \;
Numerically sort standard input by the second word of each line and output from greatest value to least value </s> sort -nrk 2,2
Search all regular files in the current directory tree for "string" </s> find . -type f -exec grep string {} \;
Find all regular files under and below /home/user/demo/ </s> find /home/user/demo -type f -print
Prints information about active network interfaces in system. </s> echo "$(ifconfig)"
Find all files whose names do not begin with "zsh" on ext3 file systems </s> find / -fstype ext3 -name zsh*
find all regular/normal files which have cpp folder in their path </s> find . -type f -path "*/cpp/*"
Make sure the file ".bash_profile" exists in current directory, update its timestamp to current date/time. </s> touch .bash_profile
Limit each line in "your_file" to 80 characters and view via "more" </s> fold -80 your_file | more
Counts all files in a current folder and subfolders. </s> find . -type f | wc -l
Create 6-letter named temporary file in a folder path $file1, and save the path to it in a variable 'tmpfile' </s> tmpfile=$(mktemp $(dirname "$file1")/XXXXXX)
Find files in the current directory tree whose size is 24000 bytes </s> find . -size 24000c
Print a sorted list of *.so files in the bla directory tree </s> find bla -name *.so -print0 | sort -rz
create directory /etc/cron.5minute </s> mkdir /etc/cron.5minute
change owner of the file my_test_expect.exp to user el </s> sudo chown el my_test_expect.exp     //make el the owner.
display all the regular files in the current folder that are less than 10KB </s> find . -type f -size -10k
find in the file system for the directories with the name "httpdocs" </s> find / -type d -name 'httpdocs'
Recursively change the owner and group of "subdir1" to "user1" </s> chown user1:user1 -R subdir1
Print the IP addresses for the current host name </s> hostname -i
Print the directory of the full path to the current script </s> echo $(dirname $(readlink -m $BASH_SOURCE))
Find find symlinks pointing to /mnt/oldname* in the entire file system </s> find / -type l -lname '/mnt/oldname*'
recursively finds all files newer than a date </s> find . -type f -newermt "$(date '+%Y-%m-%d %H:%M:%S' -d @1494500000)"
Search the file system for regular files whose names are shorter than 25 characters </s> find / -type f | egrep '.*/.{1,24}$'
Read and execute file 'lib/B' that located in the same directory as the current script, will fail if currently running script is not in PATH. </s> source "$( dirname "$( which "$0" )" )/lib/B"
display all the html files in the current folder </s> find . -name \*.html
Write "127.0.0.1 ad.doubleclick.net" to the console and append to "/etc/hosts" as root </s> echo 127.0.0.1 ad.doubleclick.net | sudo tee -a /etc/hosts
Print the output of history without line numbers </s> history|awk '{$1="";print substr($0,2)}'
find all jpg files in current folder </s> find . -type f -name "*.JPG"
Read a line from standard input into variable "response" ignoring backslash escapes and using the prompt "${1:-Are you sure? [y/N]} " </s> read -r -p "${1:-Are you sure? [y/N]} " response
Write "deb blah ... blah" to standard output and append to "/etc/apt/sources.list" as root </s> echo 'deb blah ... blah' | sudo tee --append /etc/apt/sources.list
Make directory "destdir" </s> mkdir destdir
Search all *.c files from the current directory tree for "hogehoge" </s> find . -name \*.c -print0 | xargs -0 grep hogehoge /dev/null
create a symbolic link named "-pdf-kundendienst" to "local--pdf-kundendienst" file </s> ln -s -- ./local--pdf-kundendienst -pdf-kundendienst
Print the sorted unique column of usernames of users who are currently logged in </s> finger | cut -d ' ' -f1 | sort -u
Write "fifo forever" infinitely using the named pipe "fifo" by writing its contents to standard output and to "fifo" </s> echo "fifo forever" | cat - fifo | tee fifo
Change the owner to "user" and group to "group" of files "file ..." </s> chown user:group file ...
Print a listing of the `other' directory </s> $ find other -maxdepth 1
Recursively change the owner and group of "/workspace" and "775" to "your_user_name" </s> chown -R your_user_name.your_user_name 775 /workspace
Gets IP address of 'eth0' network interface. </s> ifconfig eth0 | awk '/inet addr/{sub(/[^0-9]*/,""); print $1}'
Search the /path tree for all executables </s> find /path -perm /ugo+x
Print all string from file 'file2.txt' matching pattern in file 'file1.txt' </s> grep "$(cat file1.txt)" file2.txt
Print every 4th line from 10 lines of "y" with line numbers </s> yes | cat -n | head -10 | awk 'NR % 4 == 1'
Count the number of files/directories named file1 under current directory </s> find -name file1 | wc -l
Takes folder path from string '/path/to/copy/file/to/is/very/deep/there' and created it with all parents. </s> mkdir -p `dirname /path/to/copy/file/to/is/very/deep/there` \
Ping every address from 192.168.0.1 to 192.168.0.254 with a timeout of 1 second and filter out no responses </s> echo $(seq 254) | xargs -P255 -I% -d" " ping -W 1 -c 1 192.168.0.% | grep -E "[0-1].*?:"
Find files with 002 permission in entire file system with the null character as the delimiter </s> find / -type f -perm -002 -print0
find all the text files in current folder and move all these to another folder appending ".bar" at the end of these files </s> find . -name "*.txt" | xargs -I '{}' mv '{}' /foo/'{}'.bar
Find "*prefs copy" files in the /mnt/zip directory tree and remove them </s> find /mnt/zip -name "*prefs copy" -print0 | xargs rm
Print command with PID 11383 </s> ps | egrep 11383 | tr -s ' ' | cut -d ' ' -f 4
List all .jpg files in the home directory tree in a fast way </s> find . -name "*.jpg" -exec ls {} +
Find all directories under current directory tree that were modified $FTIME days ago </s> find . -type d -mtime $FTIME
Search the directory $path recursively for regular files with the given $extension </s> find $path -type f -name "*.$extension"
find all the files in the current directory which have been modified in the last 24 hours </s> find . -mtime 0
find directory names starts with 'bar' </s> find . -path './bar*' -print
Page through the contents of 'input_file_name' hexdumped with space-separated 2-byte units. </s> od -xcb input_file_name | less
display all the hidden files in the folder /home </s> find /home -name ".*"
change owner and group of the current directory and all files into it to user and group andrew </s> chown -R andrewr:andrewr *
Recursively finds all '*.pdf' files in a current folder and removes them. </s> find . -name '*.pdf' -exec rm {} +
Run script $2 on remote host $1 using interpreter $INTERPRETER with pseudo-terminal allocation </s> cat $2 | grep -v "#" | ssh -t $1 $INTERPRETER
display only the file names of all the files which end with ".deb" </s> find . -name '*.deb' -printf "%f\n"
Find all files on the system whose names are 'autoload.php' </s> find / -name autoload.php
Find all of the character devices on the system </s> find / -type c
Change to the directory of the executable "python" </s> cd `dirname $(which python)`
Replace "-" with "0" in columns 4 and 5 of file "test.in" and format as a table </s> awk '{gsub(/-/,"0",$4);gsub(/-/,"0",$5)}1' test.in | column -t
List all IP addresses assigned to current hostname, pausing for user interaction after each page. </s> more /etc/hosts | grep '[[:space:]]*'`hostname`'[[:space:]]*' | awk '{print $1}'
Find files in the current directory and below that are 2000 kB in size </s> find . -size 2000k -print
Remove trailing white spaces from all files under dir directory </s> find dir -type f -exec sed -i 's/ *$//' '{}' ';'
Identify files that do not have a listing in the /etc/passwd or /etc/group file </s> find / -nouser -o  -nogroup
find all read me files in a folder </s> find /usr/share/doc -name README
Delete empty regular files </s> find . -type f -empty -delete
Search the files from the current directory tree for text "documentclass" </s> find . -type f -print0 | xargs -0 grep -H 'documentclass'
Displays information about all network interfaces in system, including inactive ones. </s> ifconfig -a
find all text files in the current directory </s> find . -name "*.txt" -print
Save the current time formatted according to the format string "%Y-%m-%d %H:%M:%S" to the variable 'CDATE' </s> CDATE=$(date "+%Y-%m-%d %H:%M:%S")
Disable jobs running in their own process group in the shell </s> set +m
Find files whose names match the pattern given by the 2nd argument $2 of the Bash script and replace string $3 with $4 in them </s> find ./ -type f -name "$2" -exec sed -i "s/$3/$4/g" {} \;
display all files in the current directory excluding those that are present in the directories whose name starts with "efence" and do not search in the sub directories </s> find * -maxdepth 0 -name "efence*" -prune -o -print
Print content of 'filename' file, showing all non-printing characters and displaying $ at the end of each line. </s> cat -v -e filename
display long listing of first 10 directories in the current folder </s> find . -type d -ls | head
Find all regular files in the current directory tree last modified between 1 and 3 days ago and list them using format '%TY %p\n' </s> find ./ -daystart -mtime -3 -type f  ! -mtime -1  -printf '%TY %p\n'
display all directories in the folder "PROD" and do not search in the sub directories </s> find /PROD -maxdepth 1 -type d
Find files newer than start.txt but not newer than end.txt </s> find ./ -newer start.txt -and ! -newer end.txt
Find all files/directories under /path directory that were modified more than 30 minutes ago </s> find /path -mtime +30m
Recursively find the latest modified file in the current directory and print the modification time and filename </s> find . -type f -printf '%T@ %p\n' | sort -n | tail -1 | cut -f2- -d" " | sed 's/.*/"&"/' | xargs ls -l
Locate world-writable files and directories on the system </s> find / -path /proc -prune -o -perm -2 ! -type l -ls
display all the files in current folder which have been changed in the last 2-6 days </s> find . -cmin +2 -cmin -6
Print which files differ in "dir1" and "dir2" recursively </s> diff -qr dir1/ dir2/
Rename .jpg files to .jpeg in all level 2 subdirectories of the current directory </s> find -maxdepth 3 -mindepth 3 -type f -iname '*.jpg' -exec rename -n 's/jpg$/jpeg/i' {} +
Find all files whose names end with "~" in the /home/peter directory tree, following symlinks, and delete them </s> find -L /home/peter -name *~ -print0 |xargs -0 -r -n1000 rm
display all the files in the home folder excluding directories which have been modified in the last 24 hours </s> find /home/ -mtime -1 \! -type d
Print a hex dump of "$DIREC" as characters </s> echo "$DIREC" | od -c
List files in the current directory </s> find . \( -path './*' -prune \)
Login to "host" using identity file "id_rsa" </s> ssh -i id_rsa host
List all aliencoders.[0-9]+ files/directories under /home/jassi/ directory </s> find /home/jassi/ -name "aliencoders.[0-9]+" -exec ls -lrt {} + | awk '{print $9}'
Find files which are more than 2 days old under  ${userdir}/${i}/incoming directory </s> find ${userdir}/${i}/incoming -mtime +2 -type f -ls
Gets MAC address of eth0 network interface. </s> ifconfig eth0 | grep HWaddr | cut -d ' ' -f 9
Removes resursively all files and folders named "Thumbs.db", ignoring case distincts. </s> find . -iname "Thumbs.db" -print0 | xargs -0 rm -rf
Sets shell options 'globstar', 'dotglob' and 'nullglob'. </s> shopt -s globstar nullglob dotglob
find  file which case-insensitive name is too in currect directory </s> find . -iname foo
Find all or single file called tecmint.txt under the / directory of owner root </s> find / -user root -name tecmint.txt
Calculate md5 sums for each files matching 'main.cpp*' </s> md5sum main.cpp*
Search the current directory and its sub-directories for any file that has "bsd" somewhere in its name. </s> find . -name "*bsd*" -print
From a script, output the name of the script itself, without containing directories - from a shell, output the name of the shell. </s> basename -- $0
Append the contents of "file.txt" to the current in-memory history list </s> history -r file.txt
Find all Name* files under ../../$name-module and rename them by replacing 'Name' with $Name (will be expanded in the current shell) in their names </s> find ../../$name-module -print0 -name 'Name*' -type f | xargs -0 rename "s/Name/$Name/"
list regular file which file name end with 'cache' 'xml' or 'html' in current directory </s> find . -type f \( -name "*cache" -o -name "*xml" -o -name "*html" \)
Find all PNG and JPG files and append them to archive `images.tar' </s> find . \( -iname "*.png" -o -iname "*.jpg" \) -print -exec tar -rf images.tar {} \;
search in all the regular/normal files of the current folder for the word "word" and display the matched file name </s> find . -type f -exec grep -l "word" {} +
Find all files/drectories under '/u/bill' directory tree that have been accessed in the last 2 to 6 minutes </s> find /u/bill -amin +2 -amin -6
find all the files in the current folder and display adding quotations to each file and replace spaces with new line </s> find $PWD | sed -e 's/^/"/g' -e 's/$/"/g' | tr '\n' ' '
search for all the regular files that have been changed in the last 48 hours and sync these to another folder </s> find /my/source/directory -ctime -2 -type f -printf "%P\n" | xargs -IFILE rsync -avR /my/./source/directory/FILE /my/dest/directory/
Find all files under /mnt/naspath directory without descending into .snapshot directory that were modified in last 24 hours with null character as the delimiter </s> find /mnt/naspath \! \(-name .snapshot -prune\) -type f -mtime 0 -print0
display all the text files in a folder </s> find $1 -type f -name '*'$n'.txt'
Print all user names and terminals of users who are logged in </s> who | awk '{ print $1, $2 }'
Creates temporary folder within a $mnt_dir folder and saves path to it in a 'rsync_src' variable. </s> rsync_src=`mktemp -d -p $mnt_dir`
Delete all *.zip files under current directory that are older than 2 days </s> find . -name "*.zip" -mtime +2 -print0 | xargs -0 -I {} rm {}
Find all the files/directories under user's home directory that do not belong to the user $USER </s> find ~ ! -user ${USER}
Find all directories under $path </s> find $path -type d
Find all read-only files </s> find / -perm /u=r
Find and remove multiple files such as *.mp3 or *.txt </s> find . -type f -name "*.mp3" -exec rm -f {} \;
Find all files/directories named 'filename' that belong to user 'username' and group 'groupname' in the entire filesystem </s> find / -user username -group groupname -name filename
Move all files from "src/test/" to "dest" displaying progress </s> rsync -a --progress --remove-source-files src/test/ dest
Copy src_dir recursively to dest_dir, but without overwriting existing files. </s> cp -nr src_dir dest_dir
Search /root/directory/to/search recursively for the files matching pattern 'filename.*' </s> find /root/directory/to/search -name 'filename.*'
display all the files in the user folder which have been modified after the files /tmp/stamp$$ </s> find /usr -newer /tmp/stamp$$
Copy file or folder linked to by "file" to "file" </s> cp -rf --remove-destination `readlink file` file
Print lines in the sorted contents of "file2" that are not in the sorted contents of "file1" </s> comm -13 <(sort file1) <(sort file2)
Find all files under current directory and set read-write permission for owner, read permission for group and no permission for other for those files </s> find . -type f -exec chmod u=rw,g=r,o= '{}' \;
Print a sorted list of regular files from directory tree /folder/of/stuff </s> find /folder/of/stuff -type f | sort
Compare the contents of gzip-ompressed files "file1" and "file2" </s> diff <(zcat file1.gz) <(zcat file2.gz)
Find all files under current directory whose file type description contains "image", display the paths to files and file type descriptions. </s> find . -name '*' -exec file {} \; | grep -o -P '^.+: \w+ image'
Store N symbols of input into variable 'buffer' </s> read -N $BUFSIZE buffer
Evaluate the output of recursively changing the owner and group of "/data/*" to "mongodb" </s> `sudo chown -R mongodb:mongodb /data/*`
Search all the .c and .h files in the current directory tree for "expr" </s> find -name '*.[ch]' | xargs grep -E 'expr'
Print the user name of the current user </s> whoami
Print number of lines that equal in files '/home/xyz/a.csv1' and '/home/abc/tempfile' </s> comm -12 <(sort -u /home/xyz/a.csv1) <(sort -u /home/abc/tempfile) | wc -l
Change permissions to 644 of multiple regular files with permissions 755 </s> find . -type f -perm 755 -exec chmod 644 {} \;
Find recursively all files matching pattern 'file??' in the xargstest/ directory and print a sorted list of them </s> find xargstest/ -name 'file??' | sort
Find the "*.foo" files in the current directory tree that are not under ".snapshot" directories </s> find . -name .snapshot -prune -o -name '*.foo' -print
Split "$1" into files of at most "$2" or default 10000 using a numeric suffix of length 6 and suffix "${tdir}/x" </s> split -l ${2:-10000} -d -a 6 "$1" "${tdir}/x"
Print appended data in "/var/log/syslog" as the file grows </s> tail -f /var/log/syslog
find all the files in the current folder which have execute permission to all the users </s> find . -perm /u=x,g=x,o=x
Find all directories in 1 level down the /home directory that have two consecutive vowels in their names and count them </s> find /home -mindepth 1 -maxdepth 1 -type d -name '*[aeiou][aeiou]*' -printf '*' | wc -c
Search the files from the current directory tree for "chrome" </s> find . | xargs grep 'chrome' -ls
find foo, Foo, FOo, FOO, etc., but only files </s> find . -iname foo -type f
List all files that are between 10000 and 32000 bytes in size </s> find . -size +10000c -size -32000c -print
delete all text files in the home folder after user confirmation </s> find $HOME/. -name "*.txt" -ok rm {} \;
searches through the /usr/local directory for files that end with the extension .html </s> find /usr/local -name "*.html" -type f
display all files in the current folder and do not search in the sub directories </s> find . -maxdepth 0
Recursively search for all files with names ending with "_test.rb", renaming them to end with "_spec.rb", using at most 4 concurrent processes. </s> find . -name "*_test.rb" | xargs -P 4 rename s/_test/_spec/
List the files in the /etc directory tree containing text '128.200.34.' </s> find /etc -type f -print | xargs grep -il '128\.200\.34\.'
Saves real path of the folder containing the current script </s> DIR=$(dirname "$(readlink -f \"$0\")")
search for the directory "mysql" in the entire file system </s> find / -name mysql -type d
Find all files/directories under $1 which have at least write permission for their owner and set write permission for group for these files/directories </s> find "$1" -perm -u+w -print0 | xargs chmod g+w
Mount the directory "/etc" on "/tmp/sarnold/mount_point/" </s> mount -obind /etc /tmp/sarnold/mount_point/
Gets IP addresses of all active network interfaces. </s> ifconfig | grep -oP "(?<=inet addr:).*?(?=Bcast)"
delete all the files ending with "~" in current folder </s> find . -name "*~" -print | xargs rm
Search all of /usr for any directory named 'My Files', for each directory found, copy it to /iscsi preserving full paths and attributes. </s> find /usr -type d -name My\ Files -exec rsync -avR '{}' /iscsi \;
delete all text files in the entire file system </s> find / -type f -name "*.txt" -print | xargs rm
find all headers file *.h in /nas/projects directory </s> find /nas/projects -name "*.h"
Split "foo.txt" into files with 1 line each and use a suffix length of 5 </s> split --suffix-length=5 --lines=1 foo.txt
display all the .sh scripts in the folder /usr </s> find /usr -name '*.sh'
Find all files/directories under current directory tree with '.old' extension </s> find . -name ”*.old” -print
Recursively unzip files to stdout in "/some/dir/here" and search for "blah" </s> zcat -r /some/dir/here | grep "blah"
search for a word in all the files in the current directory </s> find . -exec grep chrome {} +
search for all the files in the current folder which have spaces and force delete them </s> find . -name "filename including space" -print0 | xargs -0 rm -rdf
display the top 20 biggest files in the current folder which are present in the same partition as that of the current folder </s> find . -xdev -printf ‘%s %p\n’ |sort -nr|head -20
find all regular/normal files in the current folder that have been modified in the last 120 hours </s> find -mtime -5 -type f -print
find all the png files in current folder which are present in the pattern list file "search.txt" </s> find . -name '*.png' | grep -f <(sed 's?.*?/[0-9]_[0-9]_[0-9]_&_?' search.txt)
Create a symbolic link in the current directory for each file .dbf under the directories matching "/home/michael/foxpro/mount/A[1FV]/[12][0-9][0-9][0-9]" </s> find /home/michael/foxpro/mount/A[1FV]/[12][0-9][0-9][0-9] -name '*.dbf' -type f -exec ln -s {} \;
Find all 400 permission files under /data directory, print 'Modifying ' appended with file path for each of them and change their permission to 755 </s> find /data -type f -perm 400 -exec echo Modifying {} \; -exec chmod 755 {} \;
Add group write permission to all files and directories in the current directory including hidden files and excluding ".." </s> chmod g+w $(ls -1a | grep -v '^..$')
Recursively removes all folders named '.svn' in a current folder. </s> find . -type d -name .svn -print0|xargs -0 rm -rf
Find all '*~' files under current directory </s> find ./ -name '*~'
beginning at the end of the file, prints lines matching /2012/ and exits after first non-matching line </s> tac error.log | awk '{if(/2012/)print;else exit}'
Find all *.htm files under current directory </s> find -type f -name "*.htm"
Remove the .jpg files from the current directory whose names match regular expression ".+-[0-9]+x[0-9]+\.jpg" </s> find . -type f -regex ".+-[0-9]+x[0-9]+\.jpg" -exec rm -rf {} \;
Print the files under current directory twice per line </s> find . -type f -exec echo {} {} \;
Search for .bam files anywhere in the current directory recursively </s> find . -name "*.bam"
Find all php files whose name is tecmint.php in a current working directory </s> find . -type f -name tecmint.php
Print the calendar for February 1956 </s> cal 02 1956
find all *.java files/directories under current directory </s> find . -name  "*.java"
Change permissions of "/dvtcolorconvert.rb" to 755 </s> sudo chmod 755 /dvtcolorconvert.rb
Print all file/directory names with white space safety under the /proc directory </s> find /proc -print0 | xargs -0
find all the files in the current folder which have set guid bit on and list the top 10 files. </s> find . -perm /g+s | head
List all leaf directories of the current directory tree </s> find -depth -type d |sed 'h; :b; $b; N; /^\(.*\)\/.*\n\1$/ { g; bb }; $ {x; b}; P; D'
Find all files under current directory whose status was changed less than 3 days ago and show last 5 lines of output </s> find . -type f -ctime -3 | tail -n 5
List recursively all files and directories in /var/www and pass the result to the `more' pager </s> find /var/www | more
Show logged in users with idle time of each one </s> w | tr -s " " | cut -d" " -f1,5 | tail -n+3
Prefix all files and directories in the current directory with "Unix_" </s> ls | xargs -I {} mv {} Unix_{}
Print IP addresses of the current host </s> hostname -I|cut -d" " -f 1
On host "server_b", connect as ssh user "user" and copy "/my_folder/my_file.xml" to directory "/my_new_folder/". </s> scp user@server_b:/my_folder/my_file.xml user@server_b:/my_new_folder/
create a compressed archive in my_dir directory matching '.[^.]* ..?*' glob pattern </s> tar -C my_dir -zcvf my_dir.tar.gz .[^.]* ..?* *
Merge 10 already sorted files and display the result, pausing at each page of output. </s> sort -m a b c d e f g h i j | more
Search the "your/dir" directory for empty subdirectories </s> find your/dir -mindepth 1 -prune -empty
Search for first match of the case insensitive regex 're' in all *.coffee files under current directory and print the file paths along with the matches </s> find . -print0 -name '*.coffee'|xargs -0 grep -m1 -ri 're'
Get domain "$domain" IP address </s> dig +short "$domain"
Search /public/html/cosi for files whose name is "wiki.phtml" </s> find /public/html/cosi -name "wiki.phtml"
Find recursively all regular files changed within the last 5 minutes starting from directory b </s> find b -type f -cmin -5
Find all files excluding *.gz files in the current directory tree and compress them with gzip </s> find . -type f ! -name '*.gz' -exec gzip "{}" \;
find all the regular/normal files in the current directory which do not have the extension comment and and redirect the output to /tmp/list </s> find . -type f \! -name "*.Z" \! -name ".comment" -print | tee -a /tmp/list
Creates temporary directory with name formatted like .daemonXXXXXXX in /tmp/ folder, and saves path to it in 'TMPDIR' variable. </s> TMPDIR=$(mktemp -p /tmp -d .daemonXXXXXXX)
search  in current directory downwards all files which were accessed exactly 7 days back </s> find . -atime 7 -print
Recursively copies "$1" to "$2". </s> cp -R "$1" "$2"
Print list of disk and mountpoint of disks matching "/dev/sd*" </s> mount | awk '/\/dev\/sd/ {print NR, $1, $3}'
Replaces any occurences of '*favicon.ico*' in any subfolder with file '/root/favicon.ico'. </s> find . | grep favicon\.ico | xargs -n 1 cp -f /root/favicon.ico
Recursively change the group of all files in "/var/lib/php/session" to "lighttpd" </s> chown -R :lighttpd /var/lib/php/session
Set read, write and execute permission for all (owner, group, other) for the files/directories in foldername directory tree </s> sudo find foldername -exec chmod a+rwx {} ";"
Find all the files whose name is FindCommandExamples.txt and contains both capital and small letters in / directory </s> find  / -iname findcommandexamples.txt
Save absolute path of "$path" whose parents exist to variable "abspath" </s> abspath=$(readlink -f $path)
Compare the contents of "/bin" and "/usr/bin" line by line </s> diff <(ls /bin) <(ls /usr/bin)
force remove all the directories with the name logs in the folder /var/www </s> find /var/www -type d -mtime 0 -name logs -exec sudo rm -fr {} \;
List *.txt files under current directory that have 'mystring' in their name </s> find . -name *.txt | egrep mystring
Find all .* files excluding list_files (case insensitive) under current directory </s> find . -iname ".*" \! -iname 'list_files'
List files in directory "one" and "two" that do not exist in the other </s> sort <(ls one) <(ls two) | uniq -u
Prints path to the folder that contains target of symbolic link ../../../../etc/passwd. </s> $(dirname $(readlink -e ../../../../etc/passwd))
display all the regular/normal files in the current folder that are not accessed in the last 10 minutes </s> find . -type f -amin +10
Search for line 111 in file "active_record.rb" with 2 lines of context </s> nl -ba  -nln  active_record.rb  | grep -C 2 '^111 '
Remove all the files and directories that are in /dir1 but not in /dir2. </s> diff -rq /dir1 /dir2 | grep -E "^Only in /dir1.*" | sed -n 's/://p' | awk '{print $3"/"$4}' xargs -I {} rm -r {}
Remove all *.swp files under current directory </s> find . -name "*.swp"|xargs rm
Change the permission to 0644 for all files under current directory </s> find . -type f -exec chmod 0644 {} \;
search for a word in all the fies in the current folder </s> find . -type f -exec grep some_string {} \;
Move all *.php~ (case insensitive) files under current directory to /mydir </s> find . -iname "*.php~" -exec mv "{}" /mydir +;
Remove all *.mp3 files in tmp directory but not in it's subdirectories </s> find tmp -maxdepth 1 -name '*.mp3' -maxdepth 1 | xargs    -n1 rm
Find all files/directories under current directory and count the number of lines for the output </s> find |wc -l
Edit current user's cron job list with editor specified by EDITOR environment variable, or default /usr/bin/editor if EDITOR is not set. </s> crontab -e
Find all regular files that were modified more than 60 days ago under '/path-to-directory' directory tree, sort them according to timestamp and print the filenames preceded with the timestamps </s> find /path-to-directory -type f -mtime +60 -printf "%T@ %p\n" | sort
Create a tar archive with all *.java files under the current directory </s> find . -type f -name "*.java" | xargs tar cvf myfile.tar
Find directories in the current directory tree that were modified within the last 24 hours and move them to /path/to/target-dir </s> find . -type d -mtime 0 -exec mv {} /path/to/target-dir \;
Remove all .mpg files in the /home/luser directory tree </s> find /home/luser -type f -name '*.mpg' -exec rm -f {} \;
Dump the character output of "echo 'hi'" </s> echo 'hi' | od -c
Run 'chmod 0644' on all files in the current directory tree </s> find . -type f -exec chmod 0644 {} \;
Unzip all files matching "/homes/ndeklein/mzml/*.gz" </s> ls /homes/ndeklein/mzml/*.gz | xargs -I {} gunzip {}
Print '-exec is an action so an implicit -print is not applied' for every file/directory found by the name 'file' under current directory tree </s> find -name file -exec echo '-exec is an action so an implicit -print is not applied' \;
Extract two semicolon-separated fields from specified strings, output them separated by a space. </s> echo "bla@some.com;john@home.com" | awk -F';' '{print $1,$2}'
View gzip's help documentation </s> gzip --help | less
Set trace prompt to print seconds, nnoseconds, script name, and line number </s> PS4='+$(date "+%s:%N") %N:%i> '
find all files in the file system which belong to the user pat and having the word "filename" in their name. </s> find / -user pat -iname "filename"
Prints long listing of directories '/tmp', '/tnt' themselves. </s> ls -ld /tmp /tnt
Dump the character output of 'echo `echo "Ho ho ho"`' </s> echo `echo "Ho ho ho"` | od -c
Change the owner of "/var/www/html/mysite/tmp_file_upload/" to "nobody" </s> sudo chown nobody /var/www/html/mysite/tmp_file_upload/
Find all executable files </s> find / -perm /a=x
Search "file1" for lines matching regex patterns listed in "file2" and list the unique results (sorted alphabetically) </s> grep -f file2 file1 | sort | uniq
Search the directories that match pattern '/path/to/directory/folder{?,[1-4]?,50}' for .txt files </s> find /path/to/directory/folder{?,[1-4]?,50} -name '*.txt'
Make a copy of the entire contents of dir1 in the Pictures directory located in the user's home directory. </s> cp -r dir1/ ~/Pictures/
Find directories with permissions 777 and change them to 755 recursively </s> find /home -type d -perm 777 -print -exec chmod 755 {} \;
Print the list of files in directory /tmp/a1 recursively </s> find /tmp/a1
Print absolute path of "PATH" </s> readlink -f PATH
search for all files ending with ".mkv" in current folder </s> find /volume1/uploads -name "*.mkv"
Removes first and last parts of path 'test/90_2a5/Windows' and prints the result. </s> echo 'test/90_2a5/Windows' | xargs dirname | xargs basename
Find a used disk space of a target directory and files inside of it </s> du -h your_directory
Find all *shp* directories under current directory and move all regular files inside those directories to ../shp_all/ </s> mv $(find $(find . -name "*shp*" -printf "%h\n" | uniq) -type f) ../shp_all/
Find the password file between sub-directory level 2 and 4 </s> find -mindepth 3 -maxdepth 5 -name passwd
List all files/directories under current directory matching the posix-egrep type regex ".+\.(c|cpp|h)$" in their names excluding the paths */generated/* and */deploy/* </s> find . -regextype posix-egrep -regex '.+\.(c|cpp|h)$' -not -path '*/generated/*' -not -path '*/deploy/*' -print0 | xargs -0 ls -L1d
Represent time string $MOD_DATE as seconds since epoch and save to variable 'MOD_DATE1' </s> MOD_DATE1=$(date -d "$MOD_DATE" +%s)
Find all files/directories under /home/foo/public_html/ that were modified less than 60 minutes ago </s> grep ! error_log | find /home/foo/public_html/ -mmin -60
Remove all *.log files from the current directory tree </s> find ./ -name '*.log' -print0 | xargs -0 rm
Find all regular files named postgis-2.0.0 under your home directory </s> find ~/ -type f -name "postgis-2.0.0"
Find all files/directories under '/directory_path' directory tree that have been modified within the last day </s> find /directory_path -mtime -1 -print
List jobs and their process ids and print them by replacing newline with '^' </s> joblist=$(jobs -l | tr "\n" "^")
change the permissions of all the directories in the current folder </s> find . -type d -exec chmod 2775 {} \;
Delete all files throughout the entire filesystem that are no longer owned by a valid user. </s> find / -nouser | xargs -0 rm
Search the regular files from directory tree 'directory_name' for "word" and print the names of the matched files </s> find directory_name -type f -print0 | xargs -0 grep -li word
create directory tata </s> mkdir tata
Search for all *.ogg (case insensitive) files in the $HOME directory that have an access time of greater than 30 days </s> find $HOME -iname '*.ogg' -atime +30
Find files matching an exact set of permissions </s> find / -perm 644
Find all files and directories that have been modified in the last seven days. </s> find . -mtime -7
Print amount of space available on the file system containing path to the current working directory in megabytes. </s> df . -B MB | tail -1 | awk {'print $4'} | grep  .[0-9]*
Search for the regex ... in the manual of the find command </s> man find | grep ...
Save the canonical path of "/usr/bin/java" with "/bin/java" removed to variable "JAVA_HOME" </s> JAVA_HOME=$(readlink -f /usr/bin/java | sed "s:/bin/java::")
Remove all regular files from the current directory tree whose names do not end with "ignore1" or "ignore2" </s> find . -type f -not -name '*ignore1' -o -not -name '*ignore2' | xargs rm
For each line in list.txt, output the line adding "FAIL" if the same line appears in fail.txt, and "PASS" otherwise - lines in fail.txt must be in the same order as they appear in list.txt. </s> sed 's/$/ FAIL/' fail.txt | join -a 1 -e PASS -j 1 -o 1.1,2.2 list.txt -
Finds all files having text "texthere" recursively in a current folder, and precedes found string with string number in file and file name. </s> find -type f -exec grep -Hn "texthere" {} +
Search the regular files of the current directory tree for string "stuff" </s> find . -type f -exec grep -n "stuff" {} \; -print
Compress all directories found in directory tree $LOGDIR that have been modified within the last 24 hours </s> find $LOGDIR -type d -mtime -1 -exec compress -r {} \;
display all the files in the folder /home which have the setuid bit enabled </s> find /home -perm /u=s
Find every file under the directory /home owned by the user joe. </s> find /home -user joe
start from current directory, skip the directory src/emacs and print it then skip all files and directories under it, and print the names of the other files found </s> find . -wholename './src/emacs' -prune -print -o -print
Make directories and parent directories as needed of "$1" with "\r" removed </s> mkdir -p $(echo -e $1 |sed $'s/\r//')
Find all regular files named 'Waldo' under ~/Books directory tree </s> find ~/Books -type f -name Waldo
Print 'Since -printf is an action the implicit -print is not applied\n' for every file named 'file' found under current directory tree </s> find -name file -printf 'Since -printf is an action the implicit -print is not applied\n'
Open all .java files in the current directory tree in the vim editor </s> find . -name '*.java' -exec vim {} +
Turns on network interface eth0. </s> ifconfig eth0 up
unzip and search for a word in all the jar files in the current folder and display the matched file name </s> find . -iname '*.jar' -printf "unzip -c %p | grep -q '<stringWithOrWithoutSpacesToFind>' && echo %p\n" | sh
Delete all files that were modified more than 60 days ago under '/path-to-directory' tree </s> find /path-to-directory -mtime +60 -exec rm -f {} \;
Print the average round trip time of 5 pings to "google.com" </s> ping -q -c 5 google.com | tail -n 1 | cut -f 5 -d '/'
Find files in two different directories (esofthub and esoft) having the "test" string and list them </s> find esofthub esoft -name "*test*" -type f -ls
find all the files in the current directory which have been modified in the last 30 days and display the contents. </s> find . -atime +30 -exec ls \;
Print lines in "file1" that exist in "file2" </s> join -t " " -j 1 <(sort file1) <(sort file2)
Search for files/directories with the case insensitive pattern anaconda* in /var/log </s> find /var/log/ -iname anaconda*
Create an empty file with a carriage return character in its name. </s> touch $'Icon\r'
Returns exit code 1 and terminates shell if 'set -e' was applied. </s> a=$(false)
Print a line of 99 '=' characters </s> seq -s= 100|tr -d '[:digit:]'
Search the current directory tree for executable files and searchable directories </s> find -executable
find the file arrow.jpg in the entire file system </s> find / -name arrow.jpg
Change every reference to the colour red to green in all CSS files </s> find . -name "*.css" -exec sed -i -r 's/#(FF0000|F00)\b/#0F0/' {} \;
Count all directories in maximum 1 level down the current directory </s> find . -maxdepth 1 -type d -exec ls -dlrt {} \; | wc --lines
Sort lines in "FILE" to standard output preserving only unique lines </s> sort -u FILE
Find files/directories named 'filename' in the entire filesystem </s> find / -name filename -print
Split "/path/to/large/file" into files with at most 50000 lines and use prefix "/path/to/output/file/prefix" </s> split --lines=50000 /path/to/large/file /path/to/output/file/prefix
display all the regular/normal files in a folder </s> find ./subdirectory/ -type f
find all files in the home folder that are modified in the last 7 days </s> find $HOME -mtime -7
Print only strings from file 'file2' that not found in 'file1' </s> comm -1 -3 file1 file2
find files in /dir/path/look/up directory that names are dir-name-here </s> find /dir/path/look/up -name "dir-name-here"
Gets IP addresses of all network interfaces. </s> ifconfig | grep ad.*Bc | cut -d: -f2 | awk '{ print $1}'
Delete everything in the current directory </s> find -mindepth 1 -maxdepth 1 -print0 | xargs -0 rm -rf
Split "$INFILE" into files of at most "$SPLITLIMT" with a numeric suffix and a prefix "x_" </s> split -d -l $SPLITLIMT $INFILE x_
find all the files with the name "datainame" in the file system which are bigger than 50MB </s> find / -size +50M -iname "Dateiname"
Save number of lines with any-cased 'merge' from $COMMIT_EDITMSG file in 'MERGE' variable </s> MERGE=$(cat $COMMIT_EDITMSG|grep -i 'merge'|wc -l)
Search the entire file hierarchy for any file that begins with zsh and exists on the ext3 file systems. </s> find / -fstype ext3 -name zsh*
find all the files that are modified exactly one day ago </s> find -daystart -mtime 1
Find all `doc.txt' files in the current directory tree printing "found" for each of them </s> find ./ -name doc.txt -printf "found\n"

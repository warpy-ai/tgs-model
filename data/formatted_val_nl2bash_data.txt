Prints all child processes of a process with id 20238, separated with comma. </s> pstree -p 20238 | sed 's/(/\n(/g' | grep '(' | sed 's/(\(.*\)).*/\1/' | tr "\n" ,
Show manual page for the find utility </s> man find
Set the environment variable "DISPLAY" to the system host name followed by ":0 skype" </s> DISPLAY=`hostname`:0 skype
download content from "http://127.0.0.1:8000" and output to "index.html" </s> curl http://127.0.0.1:8000 -o index.html
Print current UTC date in ISO format with precision to seconds </s> date -u -Iseconds
Delete all files in the /myDir directory tree that were last modified 7 days ago </s> find /myDir -mtime 7 -exec rm -rf {} \;
Saves logged in users names in 'tmp' variable. </s> tmp=$(w | awk '{print $1}')
Find all orm* files/directories under current directory </s> find . -name 'orm*'
Search the /tmp/ directory recursively for files matching regular expression ".*file[0-9]+$" </s> find /tmp -regex ".*file[0-9]+$"
Modify interval to 0.1 seconds for the watch command </s> watch -n 0.1
Print the directories that are taken by the glob pattern $SrvDir* </s> find $SrvDir* -maxdepth 0 -type d
Find all directories under mydir </s> find mydir -type d
Perform a default cPanel configuration </s> find /home/*/public_html/ -type f -iwholename “*/wp-includes/version.php” -exec grep -H “\$wp_version =” {} \;
Find all regular files with permissions 777 under and below /home/user/demo/, and change their permissions to 755 </s> find /home/user/demo -type f -perm 777 -print -exec chmod 755 {} \;
Delete empty files and print their names </s> find . -empty -delete -print
Delete files with inode number 782263 under current directory </s> find . -inum 782263 -exec rm -i {} \;
Set permissions to 755 for every subdirectory of the current directory </s> find  . -type d -mindepth 1 -print -exec chmod 755 {}/* \;
Make directory named in variable "archive" with ".tar*" stripped from the end </s> mkdir ${archive%.tar*}
Find all files in ~/clang+llvm-3.3/bin/ and print 'basename /file/path' for each file </s> find ~/clang+llvm-3.3/bin/ -type f -exec echo basename {} \;
List all environment variables (name and value) whose name either equals HOME or PATH, or starts with GO </s> env | grep '^\(GO\|HOME=\|PATH=\)'
Calculates process depth of process with id $processid, and stores it in a 'depth' variable. </s> depth=$(pstree -sA $processid | head -n1 | sed -e 's#-+-.*#---foobar#' -e 's#---*#\n#g' -eq | wc -l)
Search the current directory tree for files named "accepted_hits.bam" </s> find . -name "accepted_hits.bam"
Display the content of YourFile.txt, waiting for user input at each page. </s> more YourFile.txt
Print numbers 1 through 10 separated by ":" </s> yes | head -n10 | grep -n . | cut -d: -f1 | paste -sd:
Find *.jpg screenshots that are bigger than 500k </s> find ~/Images/Screenshots -size +500k -iname '*.jpg'
split file "${fspec} into pieces named as "xyzzyNNN" with numeric prefix from 1 to 6 </s> split --number=l/6 ${fspec} xyzzy.
Print a frequency count of column two for every file in the current directory </s> awk -F '\t' '{print $2}' * | sort | uniq -c | sort -nr
Change permissions to 644 of multiple files with permissions 755 </s> find . -perm 755 -exec chmod 644 {} \;
Connect as ssh user specified by variable USER to host whose IP address or host name is specified by HOST, and copy remote file specified by variable SRC to location on local host specified by variable DEST, disabling progress info but enabling debug info. </s> scp -qv $USER@$HOST:$SRC $DEST
display all the files in the current folder and traverse from the sub directories </s> find . -type d -depth
Resolve all symlinks in path to "firefox" binary if it exists in path, resulting in absolute path with no symlinks. </s> readlink -f $(which firefox)
List the unique second "/" delimited field of every line from standard input prefixed by the number of occurrences </s> cut -d/ -f1-2 | cut -d/ -f2- | sort | uniq -c
Force create a symbolc link named "softlink_name" to "source_file_or_directory_name" without dereferencing "softlink_name" </s> ln -sfn source_file_or_directory_name softlink_name
Page through the contents of yourFile, adding a $ at the end of each line. </s> cat -e yourFile | less
Delete all .pyc files in the current directory tree </s> find . -name "*.pyc" | xargs rm -rf
Create a variable CDATE in the current shell that contains the date in '%Y-%m-%d %H:%M:%S' format , and a variable EPOCH that contains the seconds since epoch </s> source  <(date +"CDATE='%Y-%m-%d %H:%M:%S' EPOCH='%s'")
Compress all directories found in $LOGDIR wherein a file's data has been modified within the last 24 hours </s> find $LOGDIR -type d -mtime +0 -exec compress -r {} \;
Create an empty file "foo" in each directory under the current directory containing a file named "bar". </s> find -name "bar" -execdir touch foo \;
search for the file "name_to_find" in the home folder </s> find ~ -name "name_to_find"
Print out the names of all directories in mydir recursively </s> find mydir -type d
Search $MYGROUP in /etc/group, take the 4th colon (':') separated field, replace comma (',') with newline and save the result to variable 'MYUSERS' </s> MYUSERS=`grep $MYGROUP /etc/group | cut -d ":" -f4| tr "," "\n"`
Find all files named "file.ext" in the current directory tree and print the path names of the directories they are in </s> find . -name "file.ext" -execdir pwd ';'
search all the ".sh" files in the /usr folder and follow the symbolic links to their original file </s> find /usr -follow -name '*.sh'
Recursively change the group of all files in "/tmp/php_session" to "daemon" </s> chown -R :daemon /tmp/php_session
run ls command on *.pl files </s> find . -name "*.pl" -exec ls -ld {} \;
list all javascipts file which whole name does not contain excludeddir or excludedir2  or excludedir3 </s> find . -name '*.js' | grep -v excludeddir | grep -v excludedir2 | grep -v excludedir3
Creates temporary file name and saves path to it in 'TMP_FILE' variable. </s> TMP_FILE="$(mktemp -t)"
display all directories in the current folder </s> find -type d
Create a symbolic link in the current directory to "../config/init" </s> ln -s "../config/init"
Search the current directory tree for files named "accepted_hits.bam" </s> find `pwd` -name "accepted_hits.bam"
Find all directories under current directory and set read-write-execute permission for owner, read-execute permission for group and no permission for other for those directories </s> find . -type d -exec chmod u=rwx,g=rx,o= '{}' \;
display all the files in the current directory and do not search in the sub directories </s> find . -maxdepth 0 -print
Recursively prints .txt files in current directory </s> find $(pwd) -name \*.txt -print
Find all files whose names end with "~" in the /home/peter directory tree, following symlinks, and delete them </s> find -L /home/peter -name *~ -exec rm '{}' +
Print history with the first field removed </s> history | awk '{sub($1, ""); sub(/^[ \t]+/, ""); print}'
List all files with name "someFile" and their modification time under the current directory sorted by oldest modified to newest modified </s> find . -name "someFile" -printf "%p:%T@\n" | sort -t : -k2
Set permissions to 500 for directories under the current directory </s> find . -type d -exec chmod 500 {} \;
Set variable OS to the name of the operating system, ie. "Linux" </s> OS=`uname -s`
search for all xml files in current folder and display them </s> find . -name "*.xml" -exec echo {} \;
Delete empty directories </s> find . -type d -empty -delete
Display top 500 mp4 and flv files under current directory along with their timestamps in the sorted order of time </s> find . -regex ".*\.\(flv\|mp4\)" -type f -printf '%T+ %p\n' | sort | head -n 500
Find files that are empty </s> find -empty -type -f
Extract any line in "file1.txt" which does not appear as the first ";" delimited entry in "file2.txt" </s> comm -23 <(sort file1.txt) <(grep -o '^[^;]*' file2.txt | sort)
List all files named "filename" from the current directory tree, ignoring directory "FOLDER1" </s> find . -name FOLDER1 -prune -o -name filename -print
Find all regular files under current directory (no subdirectories) and replace every occurrences of 'toreplace' with 'replace' in those files </s> find . -maxdepth 1 -type f -print0 | xargs -0 sed -i 's/toreplace/replaced/g'
Find all regular files matching the name pattern '*.?htm*' under '/srv/www' and '/var/html' directory tree </s> find /srv/www /var/html -name "*.?htm*" -type f
copy all the files with the extension ".type" from one folder to a target directory </s> find "$sourcedir" -type f -name "*.type" | xargs cp -t targetdir
Make directory "mybuild" </s> mkdir mybuild
Find all files under and below /dir that were accessed less than 60 minutes ago </s> find /dir -amin -60
find all the html files in the current folder which have not been modified in the last 7 days </s> find . -mtime +7 -name "*.html" -print
Move all files matching case insensitive ".cpp" in the current directory tree to "./test/" </s> find . -type f -iname '*.cpp' -exec mv -t ./test/ {} \+
List all variables (names only) with names containing X. </s> env | awk -F "=" '{print $1}' | grep ".*X.*"
List all files/directories under current directory by replacing all spaces with commas (,) </s> find . -ls | tr -s ' ' ,
find files in root directory that names are game </s> find / -name game
Change directory to the directory containing file path "$1" </s> cd "$(dirname "$1")"
display all instances of "foo.cpp" file in the current folder which are not in the sub directory tree ".svn" </s> find . -name 'foo.cpp' '!' -path '.svn'
Set the timestamp of B to the same one as A </s> touch -r A B
find files which full path name like '*f' at current directory and print </s> find .  -path '*f'
Creates full path with parents, that matches to folder path extracted from $f variable. </s> mkdir -p -- "$(dirname -- "$f")"
Find *.o files with permissions 664 in the current directory tree </s> find . -name *.o -perm 664 -print
Print the contents of "my_script.py" </s> cat my_script.py
search for files starting with memo and which belong to the user ann in the folder /work </s> find /work -name 'memo*' -user ann -print
Remove files from the file system that are owned by nobody </s> find / -nouser -exec rm {} \;
Force create a hard link in "/usr/local/bin" to "findpdftext" </s> sudo ln -f "findpdftext" /usr/local/bin
Recursively print all files and directories in the directory tree "$absolute/path/of/your/dir" </s> tree $absolute/path/of/your/dir
Creates temporary file and saves path to it in 'fif2' variable. </s> fif2=$(mktemp -u)
Find all directories under current directory excluding those which match the regex /\. in their names </s> find . -type d | grep -v '/\.'
Make a list of regular files from the current directory tree that have more than 1 link and view it with the "less" pager </s> find . -type f -noleaf -links +1 -printf "%n %i %f\t%h\n" | sort | less
Find all 100MB+ files and delete them </s> find / -size +100M -exec rm -rf {} \;
Calculate the md5sum of the executable file of command 'c++' </s> md5sum `which c++`
display all files in the current folder which end with extension "myfile" followed by one digit or two digits </s> find . -\( -name "myfile[0-9][0-9]" -o -name "myfile[0-9]" \)
Recursively counts non-blank, non-comment lines in all *.c files in a current folder. </s> find . -type f -name '*.c' -exec cat {} \; | sed '/^\s*#/d;/^\s*$/d;/^\s*\/\//d' | wc -l
Rename all "thumbs" directories to "thumb" in the current directory and 1 level below </s> find . -maxdepth 2 -type d | sed 'p;s/thumbs/thumb/' | xargs -n2 mv
Search for files whose size is between 100 kilobytes and 500 kilobytes </s> find . -size +100k -a -size -500k
Create 998 directories one inside another with sequential names folder1, folder2, ... folder998 and create an additional folder named 'folder9991000' inside the last 'folder998' directory </s> mkdir -p folder$( seq -s "/folder" 999 )1000
Search the current directory tree for *bash* files printing them on a single line </s> find . -name "*bash*" | xargs
Search for the regex '[0-9][0-9]*[.][0-9][0-9]*[.][0-9][0-9]*[.][0-9][0-9]*' in all files under /etc </s> find /etc -exec grep '[0-9][0-9]*[.][0-9][0-9]*[.][0-9][0-9]*[.][0-9][0-9]*' {} \;
Find all .txt files in current  directory and rename with  .html . </s> find  . -type f -name "*.txt" -exec mv {} `basename {} .html` .html \;
bind "\C-i" to "complete" function </s> bind '"\C-i":complete'
Archive files in "/mnt/source-tmp" to "/media/destination" </s> rsync -a /mnt/source-tmp /media/destination/
Print the names of the directories from the paths expanded by the glob pattern /path/to/directory/* </s> find  /path/to/directory/* -maxdepth 0 -type d -exec basename {} \;
Find all files under current directory matching the posix-egrep type regex '^.*/[a-z][^/]*$'  in their names </s> find . -regextype posix-egrep -regex '^.*/[a-z][^/]*$' -type f
find all text files in the current folder which have been modified after the file /tmp/newerthan </s> find . -name "*.txt" -newer /tmp/newerthan
Find every vim undo file in the current directory tree </s> find -type f -iname '*.un~'
Find all *bar files/directories under current directory </s> find -name *bar
find all the .jpg files in / and copy them to the current folder. </s> find / -type f -name *.jpg  -exec cp {} . \;
List the files from the current directory tree that contain lines matching regular expression '^From:.*unique sender', ignoring ~/src and ~/bin </s> find . -name bin -prune -o -name src -prune -o -type f -print | xargs egrep -il '^From:.*unique sender'
display all the regular files in the current folder excluding those that are present in the path "git" </s> find . -path "*.git" -prune -o -type f -print
Print the files in the current directory as a list of comma separated values </s> ls | sed '$!s/$/,/' | tr -d '\n'
Find all files/directories that are owned by user 'eric' under current directory tree </s> find -user eric -print
Find an inode and remove </s> find . -inum 968746 -exec rm -i {} \;
Add a number prefix followed by ')' to each line in "$string" </s> echo "$string" | nl -ba -s') '
Set permissions to ug=rwx,o= for directories under the $d directory tree </s> find $d -type d -exec chmod ug=rwx,o= '{}' \;
delete all empty files in the current directory ( empty file = size 0 bytes ) </s> find . -empty -exec rm '{}' \;
Convert ";" separated list "luke;yoda;leila" to new line separated list </s> echo "luke;yoda;leila" | tr ";" "\n"
Find all files under the current directory that are not the same file as "/home/nez/file.txt" </s> find . -maxdepth 1 -not -samefile /home/nez/file.txt
Creates temporary file and saves path to it in a 'tmpfile' variable. </s> tmpfile=`mktemp`
change the permissions of mp3 files in the folder /var/ftp/mp3 to 644 </s> find /var/ftp/mp3 -name '*.mp3' -type f -exec chmod 644 {} \;
Read a line from standard input into the variable "yn" using the first argument as the prompt ("$1 ") </s> read -p "$1 " yn
Search for files in your home directory which have been modified in the last twenty-four hours </s> find $HOME  -mtime 0
display a long list of all the files that are bigger than 10KB in current folder </s> find . -size +10k -exec ls -l {} \;
Generate the Spanish alphabet and number each character </s> echo -e {{a..n},ñ,{o..z}}"\n" | nl
Find all php files that belong to user 'takuya' and have been modified in the last 1 day </s> find -user takuya -name '*.php' -daystart -mtime -1
Rename file file.txt.123456 to file.txt </s> mv file.txt.123456 $(ls file.txt.123456 | rev | cut -c8- | rev)
Search for files/directories with the case insensitive pattern anaconda.* in var/log directory and create an archive (file1.tar) of the last block of files sent to xargs </s> find var/log/ -iname anaconda.* | xargs tar -cvf file1.tar
prints top 10 commands used </s> history | awk '{print $2}' | awk 'BEGIN {FS="|"}{print $1}' | sort | uniq -c | sort -nr | head
Prints full path of a 'cat.wav' file in a current folder. </s> ls $PWD/cat.wav
Set the variable "me" to the name of the running script, or shell, login shells have a hyphen appended to the beginning of the name, such as "-bash". </s> me=`basename -- "$0"`
Find all files/directories under current directory with null character as the delimiter </s> find -print0
Find all files that are less than 50 bytes </s> find / -size -50c
extract archive stored in $1 </s> tar -zxvf $1
explicitly list all files in the current directory </s> find . -print
Search the current directory tree for regular files omitting directory `omit-directory' </s> find . -name omit-directory -prune -o -type f
Print three lines of "some line " followed by a random number </s> seq -f 'some line %g' 500 | nl | sort -R | cut -f2- | head -3
display all the files in the current folder which do not belong to any group </s> find . -nogroup
Print all lines from the last occurrence of the regex 'pattern' to the end of the file 'file' </s> tac file | awk '/pattern/{print;exit}1' | tac
Traverse the filesystem just once, listing setuid files and directories into /root/suid.txt and large files into /root/big.txt. </s> find /       \( -perm -4000 -fprintf /root/suid.txt '%#m %u %p\n' \) , \( -size +100M -fprintf /root/big.txt  '%-10s %p\n' \)
find all the files in the current folder which have executable permission to all the users and display the ten files </s> find . -perm /a=x | head
Calculate and show md5 sums for every files under current directory tree </s> find . -type f -exec md5sum \{\} \;
Search my_folder recursively for text files containing "needle text" </s> find my_folder -type f -exec grep -l "needle text" {} \; -exec file {} \; | grep text
find all directories named build under the current directory </s> find . -type d -name build
display all the regular/normal files in the home folder that have been modified in the last 1 day (from the start of day ie, from 00:00 ) </s> find ~/ -daystart -type f -mtime 1
Find x* files/directories under /tmp directory whose status was changed less than 1 day ago and move them to ~/play </s> find /tmp/ -ctime -1 -name 'x*' -print0 | xargs -r0 mv -t ~/play/
Dump "/dev/ttySomething" in both hex and text </s> od -t x1 -t a /dev/ttySomething
Print reverse lookup for adress 127.0.0.1 </s> dig -x 127.0.0.1
Search for files in the current user's home directory and below for files that have not been accessed for more than 100 days and ask the user for permission to delete each file, one by one. </s> find ~/ -atime +100 -exec rm -i {} \;
List all IP addresses assigned to current hostname, pausing for user interaction after each page. </s> more /etc/hosts | grep `hostname` | awk '{print $1}'
Find all php files whose name is tecmint.php in the current directory </s> find . -type f -name tecmint.php
Will run checksums recursively from the current directory, and give back grouped filenames of all identical checksum results. </s> find ./ -type f -print0 | xargs -0 -n1 md5sum | sort -k 1,32 | uniq -w 32 -d --all-repeated=separate | sed -e 's/^[0-9a-f]*\ *//;'
Lists all files in a current folder, separating names with space. </s> ls -1 | awk 'ORS=" "'
change html files to mode 644 </s> find /usr/local -name "*.html" -type f -exec chmod 644 {} \;
Search the *.cc files in the current directory tree for string "xxx" </s> find . -name "*.cc" | xargs grep "xxx"
Recursively copy local file/directory "/copy/from/path" to remote location "/copy/to/path" on host "server", connecting as ssh user "user" and using identity key file "/path/to/your/.pemkey" instead of the default in ~/.ssh/ </s> scp -i /path/to/your/.pemkey -r /copy/from/path user@server:/copy/to/path
Check if 'nullglob' shell option is enabled, and if so, saves its status in 'is_nullglob' variable. </s> is_nullglob=$( shopt -s | egrep -i '*nullglob' )
Archive directory specified by variable "i" to "/iscsi" preserving relative paths. </s> rsync -avR $i /iscsi;
Change permissions to 644 for all regular files under the /path/to/dir/ tree unless these permissions are already set </s> find /path/to/dir/ -type f ! -perm 0644 -print0 | xargs -0 chmod 644
Print a count of files and directories in the current directory tree </s> tree | tail -1
Log in as "middleuser" with key "./middle_id.pem" and forward port 22 on host "middle.example.org" to port 2222 on localhost </s> ssh -i ./middle_id.pem -R 22:localhost:2222 middleuser@middle.example.org
display all the files in the current folder which contains form feed (^L) and does not contain NULL </s> find . | xargs grep -PL "\x00" | xargs grep -Pl "\x0c"
Creates temporary file with name formatted like expression in variable ${PROG}, and saves path to it in 'mytemp' variable. </s> mytemp="$(mktemp -t "${PROG}")"
Start program 'scriptname' with an empty environment. </s> env - scriptname
Shows status of a shell option 'nullglob'. </s> shopt nullglob
find all files read less than 1 minute ago </s> find . -amin -1
Remove the "^M" characters from all *.ext files under /home directory </s> find /home -type f -name "*.ext" -exec sed -i -e "s/\r$//g" {} \;
Rename "new" to "old" and backup to "old.old" if "old" exists </s> mv new old -b -S .old
Print the list of files modified within a fortnight ago removing the leading ./ from the file names </s> find .  -mtime -14 | sed -e 's/^\.\///'
find files which have all permissions to all the users in the current directory </s> find . -type f -perm 0777 -print
Set variable 'file' to the base name of first argument to script or function, that is the part following the last slash. </s> file=$( basename "$1" )
Find all *.foo files under current directory and print their contents </s> cat `find . -name '*.foo' -print`
Make directory "subdirectory" </s> mkdir subdirectory
display all the files  in the current folder excluding the perl files </s> find . -not -name "*.pl"
List the largest file in long list format of all the files under the current directory </s> find . -type f -ls | sort -nrk7 | head -1 #unformatted
Find files in the current directory whose names begin with "file" and remove them </s> find . -name file* -maxdepth 1 -exec rm {} \;
Print equal lines in compressed files "number.txt" and "xxx.txt" </s> comm -12 <(zcat number.txt.gz) <(zcat xxx.txt.gz)
Copy a large sparse file "sparse-1" to "sparse-1-copy" </s> rsync --sparse sparse-1 sparse-1-copy
Find files with 002 permission under /tmp and print them with the string 'Found world write permissions:' printed as the first line of output or print 'No world writable found' if no such files were found </s> find /tmp -type f -perm -002 | awk -- '1{print "Found world write permissions:";print};END{if(NR==0)print "No world writable found."}'
Search for files only that end with .php and look for the string $test inside those files </s> find . -name \*.php -type f -print0 | xargs -0 grep -Hn '$test'
Changes group ownership of '/etc/btsync/[prefered conf name].conf' to 'btsync'. </s> chgrp btsync /etc/btsync/[prefered conf name].conf
Find all files/directories under /myfiles that were accessed more than 30 days ago </s> find /myfiles -atime +30
Find all files/directories with '.xml' extension that start with 'log4j' in their names under '/cygdrive/e/MyDocs/Downloads/work/OATS Domain related/' directory tree, search for files that contain the string 'CONSOLE' in their contents, then search for the string 'ASYNC' in the matched files and display the matched lines along with their filenames </s> find "/cygdrive/e/MyDocs/Downloads/work/OATS Domain related/" -iname "log4j*.xml" | xargs -I % grep -ilr "CONSOLE" "%" | xargs -I % grep -H "ASYNC" %
Remove trailing whitespaces from all regular non-hidden files in the current directory tree </s> find . -type f -name '*' -exec sed --in-place 's/[[:space:]]\+$//' {} \+
delete recursively, without prompting, any files or directories under the current directory that case insensitively match the filename ".svn" </s> find . -iname .svn -print0 | xargs -0 rm -rf
display the count of total number of non empty files in the current folder </s> find . -type f -not -empty | wc -l
Mount remote "cifs" filesystem "//server/source/" on "/mnt/source-tmp" with username "Username" and password "password" </s> mount -t cifs //server/source/ /mnt/source-tmp -o username=Username,password=password
Run a shell with all environment variables specified in the file 'cronenv' in the user's home directory. </s> env - `cat ~/cronenv` /bin/sh
Answer "y" to all prompts of "rm -rf foo" </s> yes | rm -ri foo
Create a symbolic link named "/usr/local/bin/subl" to "/Applications/Sublime Text 2.app/Contents/SharedSupport/bin/subl" </s> sudo ln -s "/Applications/Sublime Text 2.app/Contents/SharedSupport/bin/subl" /usr/local/bin/subl
find all files in the folder "myfiles" which have not been accessed in the last 30*24 hours </s> find /myfiles -atime +30
Make directories "foo/bar/baz" as needed and do not cause an error if it exists </s> mkdir -p foo/bar/baz
display all the normal/regular files in the current folder </s> find . -type f
Search for the case insensitive pattern 'search for me' in all files with '.p', '.w' and '.i' extension under current directory tree without descending into '.svn' and 'pdv' directories </s> find . \( \( -name .svn -o -name pdv \) -type d -prune \) -o \( -name '*.[pwi]' -type f -exec grep -i -l "search for me" {} + \)
Lists all files in a current folder, separating names with comma. </s> ls -1 | tr '\n' ',' | sed 's/,$/\n/'
search for the host "slc02oxm.us.oracle.com" in all the xml files in the current folder and display the files which has the matched content </s> find -name “*.xml” -exec grep -l “slc02oxm.us.oracle.com” {} \;
Continuously send ping requests to broadcast address "10.10.0.255" and print the IP addresses who respond </s> ping -b 10.10.0.255 | grep 'bytes from' | awk '{ print $4 }'
display all the files in the folder "/Users/Me/Desktop" which belong to the user "popo" and which have the permission 777 </s> find /Users/Me/Desktop -user popo -perm 777
Synchronize "/path/to/dir_b" with files in "/path/to/dir_a/" if the files are newer </s> rsync -rtuv /path/to/dir_a/* /path/to/dir_b
extract "passwd.tar.gz" with verbose output </s> tar -xvzf passwd.tar.gz
split a file "list.txt" into pieces per 600 lines </s> split -l 600 list.txt
Display inputfile all on one line (replace newlines by spaces) </s> awk '{printf "%s|", $0} END {printf "\n"}' inputfile
update the permission of all the files in the folder /u/netinst to 500 </s> find /u/netinst -print | xargs chmod 500
extract "phantomjs-1.9.0-linux-x86_64.tar.bz2" </s> sudo tar xvf phantomjs-1.9.0-linux-x86_64.tar.bz2
create a backup of all the files in the home folder on a partition and save the log to a file </s> find /home -depth -print | cpio -ov -0 /dev/rmt0 | tee -a tape.log
Print nothing because 'MYVAR' string doesn`t match with '/[^/]+:' pattern </s> echo MYVAR | grep -oE '/[^/]+:' | cut -c2- | rev | cut -c2- | rev
Read a line from standard input and save response in variable "VARNAME" </s> read VARNAME
Find all files under current directory and set read-write permission for owner and group and no permission for other for those directories </s> find . -type f -exec chmod ug=rw,o= {} \;
Find all regular files under and below /somepath that have extensions PDF, TIF, TIFF, PNG, JPG, JPEG, BMP, PCX, or DCX, ignoring the case and excluding "*_ocr.pdf" files </s> find /somepath -type f -iregex ".*\.(pdf\|tif\|tiff\|png\|jpg\|jpeg\|bmp\|pcx\|dcx)" ! -name "*_ocr.pdf" -print0
Add content of "filename" to the existing cron jobs of user "user", without removing the previously existing cron jobs. </s> crontab -l -u user | cat - filename | crontab -u user -
Run 'chmod 0755' on all directories in the current directory tree </s> find . -type d -exec chmod 0755 {} \;
Find regular files that have SUID or SGID set </s> find / -perm +6000 -type f
Print permissions of every directory in the current directory tree </s> tree -p -d
find all the cpp(C++ source files), java, header files in the current directory </s> find . -name *.cpp -o -name *.h -o -name *.java
Force delete all files in the temp folder which have not been accesses in the last 240 hours </s> find /tmp/* -atime +10 -exec rm -f {} \;
Find all files whose permission are 777 </s> find / -type f -perm 777
Recursively removes all files like '*.pyc' in a current folder. </s> rm **/*.pyc
Find files in the current directory tree whose size is less than 24000 bytes </s> find . -size -24000c
remove all the files in the current working directory which have a specifc inode number </s> find . -inum $inum -exec rm {} \;
search for the word "mysql" in all the files in the current containing the word "notes" in their name. print0 is used to handle files  with newlines in their names or those which have only spaces in their names </s> find . -iname "*notes*" -print0 | xargs -I{} -0 grep -i mysql "{}"
List all files in maximum 2 levels down the current directory </s> find . -maxdepth 2  -type f -exec ls -l {} \;
Recursively finds strings with the whole word 'word-1' or 'word-2' in any file under 'directory-path', following symlinks, and prints found strings. </s> egrep -w -R "word-1|word-2” directory-path
Recursively change the owner and group of all files in the current directory to "apache" </s> find . -maxdepth 1 -not -name "." -print0 | xargs --null chown -R apache:apache
change permissions of all the script files in a directory </s> find /home/john/script -name "*.sh" -type f -exec chmod 644 {} \;
show all the regular files in current folder </s> find . -type f -print0
Copy all files with name pattern $j.sh (case insensitive) under '/tmp/2' directory tree to $i directory </s> find "/tmp/2/" -iname "$j.sh" -exec cp {} "$i" \;
display all non empty directories in current folder </s> find . \! -empty -type d
Locate and rename unprintable directories using inode numbers </s> find . -inum 211028 -exec mv {} newname.dir \;
Create a hard link named "my-hard-link" to "myfile.txt" </s> ln myfile.txt my-hard-link
display files ending with ".ext" in current folder which are present in the file "foo" </s> find . -type f -name \*.ext | xargs grep foo
Find all files/directories containing 'blah' (case insensitive) in their names that were modified in less than 2 days ago uder current directory tree </s> find . -iname '*blah*' -mtime -2
Find all *.ext files/directories under current directory and print their path and parent directory path </s> find /path -type f -name "*.ext" -printf "%p:%h\n"
find all the files in the entire file system which have been modified in the last 5 days </s> find / -mtime -5 -print
find all the files which have size 0 bytes in temp folder </s> find /tmp -type f -empty
find files which do not have all permissions to all the users in the current directory </s> find . -type f ! -perm 777 | head
Print which files differ in "dir1" and "dir2" recursively </s> diff -rq dir1 dir2
Display unique names of logged in users </s> finger | sed 's/\t/ /' | sed 's/pts\/[0-9]* *[0-9]*//' | awk '{print $2"\t("$1")\t"$3" "$4" "$5}' | sort | uniq
Print the first 5 characters followed by the next 5 characters on a new line for each line in "input_file" and split the result into files of at most 2000000 lines each with a filename prefix "out-prefix-" </s> sed 's/\(.....\)\(.....\)/\1\n\2/' input_file | split -l 2000000 - out-prefix-
Find all *.txt and *.json files in current directory </s> find . -type f \( -name "*.txt" -o -name "*.json" \)
Take a file path from standard input and remove it. </s> xargs -i rm '{}'
find files with the extension .conf in the /etc directory </s> find /etc -name '*.conf'
delete all the regular files in the temp folder which have not been modified in the last 24 hours </s> find /tmp/ -type f -mtime +1 -delete
Split "bigfile" into files of at most 1000 lines each with prefix "/lots/of/little/files/here" </s> split bigfile /lots/of/little/files/here
Search the current directory tree for *.conf and *.txt files </s> find . -type f \( -name "*.conf" -or -name "*.txt" \) -print
Recursively change owner to "tomcat6" of "webapps", "temp", "logs", "work", and "conf" </s> chown -R tomcat6 webapps temp logs work conf
search for a word in all the shell scripts in the current folder and display the matched files.(case insensitive search in grep commad) </s> find . -type f -name "*.sh" -exec grep -il landoflinux {} \;
Isolate first comma-delimited field of each line in "file", discard consecutive duplicates, and search "file" for first matching occurrence of that field. </s> cut -d, -f1 file | uniq | xargs -I{} grep -m 1 "{}" file
Print file name without the last two extensions assuming the file name doesn't contain any other dots. </s> echo "$FILE" | cut -d'.' --complement -f2-
Recursively find the latest modified file in the current directory and print the modification time and filename </s> find . -type f -printf '%TY-%Tm-%Td %TH:%TM: %Tz %p\n'| sort -n | tail -n1
Display an infinite number of lines consisting of "y", until the user presses the Q key. </s> yes | more
Recursively change the owner to "$USER" and group to "$GROUP" of "/var/log/cassandra" </s> sudo chown -R  $USER:$GROUP /var/log/cassandra
Calculate the md5 sum of the output of "du -csxb /path" and compare it against the md5 sum saved in "file" </s> du -csxb /path | md5sum -c file
display all symbolic links in the folder "myfiles" and follow them </s> find -L /myfiles
Find directories owned by user news with permissions 775 </s> find / -user news -type d -perm 775 -print
Recursively set all permissions under "../tools" to 777 </s> chmod -R 777 ../tools
display all the files in the current folder which do not belong to any user </s> find . -nouser
Print the 5th space separated fields in "file" as a comma separated list </s> cut -d' ' -f5 file | paste -d',' -s
Recursively removes all files and folders named '.svn' in a current folder. </s> find . -name .svn | xargs rm -fr
find all files in the current folder that end with ",txt" </s> find . -name "*,txt"
Make directories "a", "b", "c", "d", and "e" </s> mkdir a b c d e
Check if "\[$VLABEL\]" is mounted and save the result in variable "AMV" </s> AMV=$(mount -l | grep "\[$VLABEL\]")
Go to previous working directory. </s> cd -
split all files in directory "/dev/shm/split/" into pieces per 1000 lines </s> find /dev/shm/split/ -type f -exec split -l 1000 {} {} \;
Print the last 10 commands in history </s> history | tail -10
Print the names of all files from the /tmp/dir1 directory tree </s> find /tmp/dir1 -exec basename {} \;
Run 'make -e' with an environment variable 'HOSTNAME' set to the system hostname </s> HOSTNAME=$(hostname) make -e
Find all directories under current directory </s> find -type d
List directories under current directory </s> find . -type d
Find all 400 permission files under /data directory with null character as the delimiter </s> find /data -type f -perm 400 -print0
Find all *.m4a files/directories under /home/family/Music directory </s> find /home/family/Music -name *.m4a -print0
Find all *.p[lm] files under /users/tom directory that matches both the regex '->get(' and '#hyphenate' in their contents </s> find /users/tom -name '*.p[lm]' -exec grep -l -- '->get(' {} + | xargs grep -l '#hyphenate'
Numerically sort file "file.dat" by the second word of each line and output from greatest value to least value </s> sort -nrk 2,2 file.dat
Split "file.txt" into files of at most 20 lines each with a prefix "new" </s> split -l 20 file.txt new
Find all regular files that reside in the current directory tree and were last modified at least 1 day ago </s> find . -type f -mtime +0
Saves path to the $SCRIPT file in the SCRIPTPATH variable. </s> set SCRIPTPATH=`dirname "$SCRIPT"`
display all the regular files in the current folder that are modified after the file "file.log" </s> find . -type f -newer file.log
Find all files in the `sourceDir' directory </s> find sourceDir -mindepth 1 -maxdepth 1
Find all files in the current directory tree which do not belong to any user </s> find . -nouser
Output "testFile.txt.1" without the ".1" suffix. </s> basename testFile.txt.1 .1
Recursively change the group ownership to "laravel" in "./storage" </s> sudo chown -R :laravel ./storage
Run sed command "s#\(export\ PATH=\"\)\(.*\)#\1/home/$(whoami)/bin:~/\.local/bin:\2#" on "~/.zshrc" where "$(whoami)" is replaced with the current user name </s> sed -i "s#\(export\ PATH=\"\)\(.*\)#\1/home/$(whoami)/bin:~/\.local/bin:\2#" ~/.zshrc
Find all directories under 'A' directory tree excluding paths containing the directory 'a' </s> find A -type d \( ! -wholename "A/a/*" \)
find all executable files </s> find / -executable
Find regular files in the current directory tree that are called FindCommandExamples.txt and remove them </s> find . -type f -name "FindCommandExamples.txt" -exec rm -f {} \;
find all c, cpp files in current folder </s> find -name "*.cpp" -o -name "*.c"
Print a list of symbolic links reachable from the current directory that do not resolve to accessible files </s> find -L. -type l
Find regular files in the current directory tree that have any executable bits set </s> find -L . -type f \( -perm -u=x -o -perm -g=x -o -perm -o=x \)
Change directory to the basename of "$1" with ".tar.gz" removed </s> cd $(basename $1 .tar.gz)
Delete all files in the "${S}/bundled-libs" folder except "libbass.so" </s> find "${S}/bundled-libs" \! -name 'libbass.so' -delete
show all directories in the current folder excluding those that are present only in the paths ./media, ./images and ./backups </s> find . -path './media' -prune -o -path './images' -prune -o -path './backups' -prune -o -print
Find all executable symlinks or upvoter-* files under maximum 1 level down the {} directory </s> find {} -name 'upvoter-*' -type f -or -type l -maxdepth 1 -perm +111
Find all *.[ch] files under current directory </s> find . -name '*.[ch]'
Search /var/tmp for files larger than 30 MB modified 31 days ago </s> find /tmp /var/tmp -size +30M -mtime 31 -ls
Remove the last file extension from "filename.gz" </s> echo "filename.gz"     | sed 's/^/./' | rev | cut -d. -f2- | rev | cut -c2-
Display the entire contents of 'file', replacing only the very first instance of "old" with "new". </s> grep -E -m 1 -n 'old' file | sed 's/:.*$//' - | sed 's/$/s\/old\/new\//' - | sed -f - file
Output the standard input followed by the line number until line 786 </s> nl -ba | sed 786q | grep . | awk '{print $2$1}'
Recursively set all permissions under "/whatever/your/directory/is" to 755 </s> sudo chmod 755 -R /whatever/your/directory/is
Print "on" to standard output and to files matching "/sys/bus/usb/devices/usb*/power/level" </s> echo "on" | tee /sys/bus/usb/devices/usb*/power/level
Find all directories under minimum 1 level down the  $GIVEN_DIR directory </s> find "$GIVEN_DIR" -type d -mindepth 1
force delete all the temp files which are of size 0 bytes and which have not been accessed in the last 10 days </s> find /tmp -size 0 -atime +10 -exec rm -f {} \;
Find all regular files in the current directory tree that do not contain a whitespace </s> find . -type f \( -exec grep -q '[[:space:]]' {} \; -o -print \)
Find all SGID files in entire file system </s> find / -perm +g=s
display a long list of all regular/normal files in the file system which belong to the root and with suid bit set </s> find / -type f -user root -perm -4000 -exec ls -l {} \;
Find all files under media/ directory and change their permission to 600 </s> find media/ -type f -exec chmod 600 {} \;
Search for 'some string' in all *.axvw files under current directory and show the matched lines with line numbers </s> find . -name '*.axvw' -print0 | xargs -0 grep -n 'some string'
Change the file extension from '.txt' to '.bak' for all files/directories under current directory tree </s> find . -name "*.txt" | sed "s/\.txt$//" | xargs -i echo mv {}.txt {}.bak | sh
Recursively removes all files and folders like 'FILE-TO-FIND' from current folder. </s> find . -name "FILE-TO-FIND" -exec rm -rf {} +
Count total number of lines in all *.txt file in cuuent directory . </s> find .  -type f  -name '*.txt' -exec wc -l {} \; | awk '{total += $1} END{print total}'
Counts lines in each *.php file sorted by file path. </s> find . -name '*.php' -type f | sort | xargs wc -l
change the permission of all php files in current folder. Plus symbol at the end is used to give multiple files as input to the chmod command </s> find . -name "*.php" -exec chmod 755 {} +
Find all files/directories under $dir directory tree which have been modified in the last 3 days </s> find $dir -mtime -3
change the permissions of all regular/normal files in the current directory </s> find . -type f -exec chmod 664 {} \;
Sets 'globstar' shell option. </s> shopt -s globstar
replaces the last occurrence of 'a' with 'c' in file </s> tac file | awk '/a/ && !seen {sub(/a/, "c"); seen=1} 1' | tac
change permissions of files older than 30 days </s> find /path/to/directory -type f -mtime +30 -exec chmod 644 {} +
search for directories in the folder "test" which end with 5 digits using regular expressions </s> find ./test -regextype posix-egrep -type d -regex '.*/[0-9]{5}$'
Recursively removes all files like '*.xyz' in a current folder. </s> find . -name \*.xyz -exec rm {} \;
Print the current directory </s> find -mindepth 0 -maxdepth 0
Change the owner and group of "it" to "root" </s> chown root:root it
Print the list of 1st level subdirectories in /fss/fin </s> find /fss/fin -d 1 -type d -name "*" -print
search for all the regular/normal mp3 files in the file system and move them to the folder /mnt/mp3 </s> find / -iname "*.mp3" -type f | xargs -I '{}' mv {} /mnt/mp3
Search for all files owned by user www-data that are not larger than 100kb </s> find -user www-data -not -size +100k
display all the ".c" files in the current directory </s> find . -name \*.c -print
Returns the single most recent file in a directory </s> ls -t | head -n1
Look for directory `Cookbook' </s> find -name Cookbook -type d
Delete line 2 in numbered file "file" and renumber </s> grep -v '^2 ' file | cut -d' ' -f2- | nl -w1 -s' '
Find all files that were last accessed less than7 days ago under /home </s> find /home -mtime -7
find all files in the file system which have been accessed in the last 24 hours </s> find / -atime 0
Lists all paths to all subfolders in a current folder. </s> ls -mR * | sed -n 's/://p'
Archive "/path/to/files/source" to "user@remoteip:/path/to/files/destination" via ssh on port 2121 </s> rsync -azP -e "ssh -p 2121" /path/to/files/source user@remoteip:/path/to/files/destination
Locate files whose status was changed less than 1 day ago </s> find . -ctime -1 -print
Search  in current directory downwards all files whose size is 10 blocks . </s> find .  -size 10 print
Find all files/directories in level 2 down the current directory </s> find -mindepth 2 -maxdepth 2
Find all .gz archives in the current directory tree and check if they are valid </s> find . -name '*.gz' | xargs gunzip -vt
searches through the root filesystem ("/") for the file named Chapter1. </s> find / -name Chapter1 -type f -print
display all files in current folder which are bigger than 100KB but are less than 500KB </s> find . -size +100k -a -size -500k
Find all files/directories that were modified after February 1st under '/usr' directory tree </s> find /usr -newermt "Feb 1"
Remove the line matching "pattern to match" in "./infile" and print to standard output </s> sed '/pattern to match/d' ./infile
find all files in the current folder that are modified exactly 2 minutes ago </s> find -mmin 2 -print
Pass all the files from the current directory tree as arguments to a single 'echo' command </s> find . -exec echo {} +
search for the word "search-pattern" in all the regular/normal files in the current folder and display the matched file name </s> find . -type f | xargs grep -l "search-pattern"
find all files having certain word in its name in the current folder </s> find . -name "*bsd*" -print
find all files in the current folder which have been modified in the last 24 hours and whose file name is of length 1 </s> find . -name \? -mtime -1
Continuously print the seconds since Unix epoch and the ping time to "google.com" </s> ping google.com | awk -F'[ =]' 'NR>1{print system("echo -n $(date +%s)"), $11}'
display all the regular/normal files in current folder </s> find . -type f -name \*
Find all regular files under '/home/john' directory tree that start with 'landof' in their names </s> find /home/john -name "landof*" -type f -print
Convert standard input into a dump of octal bytes without the first 8 bytes of address and count the unique results </s> od | cut -b 8- | xargs -n 1 | sort | uniq | wc -l
Split "randn20M.csv" into files of at most 5000000 lines each with prefix "_tmp" </s> split -l5000000 randn20M.csv '_tmp';
Find all *company* (case-insensitive) files/directories under /basedir with null character as the delimiter </s> find /basedir/ -iname '*company*' -print0
Find all directories under 'test' directory tree whose paths match the regex '.*/course[0-9]\.[0-9]\.[0-9]\.[0-9]$' </s> find test -type d -regex '.*/course[0-9]\.[0-9]\.[0-9]\.[0-9]$'
Search the regular files of the current directory tree for string "stringYouWannaFind", ignoring the case </s> find ./ -type f -print -exec grep -n -i "stringYouWannaFind" {} \;
Count the number of the regular files residing under and below ./randfiles/ </s> find ./randfiles/ -type f | wc -l
Print only common strings in content of files 'file1.sorted' and 'file2.sorted' </s> comm -1 -2 file1.sorted file2.sorted
find files in the current directory and sub-directories, whose content was updated within the last hour </s> find . -mmin -60
Report file system containing path to the current working directory disk usage in kilobytes. </s> df -k .
Recursively copies all files in the current directory but ones with 'c' in name to the home directory. </s> cp -r `ls -A | grep -v "c"` $HOME/
Delete all lines matching "pattern" in "filename" </s> sed -i '/pattern/d' filename
find all the links in the current directory and print them in each line and display their names. </s> find . -type l -print | xargs ls -ld | awk '{print $10}'
Change directory to "$dir1" and resolve any symlinks in the resulting path </s> cd -P "$dir1"
Find all xml files under current directory </s> find . -name '*.xml'
Locate symbolic links in /usr and below </s> find /usr -type l
find all the files in the current folder which have not been modified in the last 90 days and force delete them </s> find . -mtime +90 -type f -exec rm -f {} \;
Find all files under $1 not matching the regex '.*/\..*' and execute hashmove on each of them with the file path as its argument </s> find $1 -type f -not -regex '.*/\..*' -exec $0 hashmove '{}' \;
Find files with 002 permission in entire file system and print them with the string 'has world write permissions' appended after every path </s> find / -type f -perm -002 -printf '%p has world write permissions\n'
find all files and directories under the current directory and display the inode of each one, using printf </s> find . -printf "%i \n"
Remove trailing white spaces from all *.rb files under current directory </s> find . -name '*.rb' | xargs -I{} sed -i '' 's/[[:space:]]*$//g' {}
Search the *.c files residing in the current directory tree for string "blash" </s> find . -name *.c -exec grep -n -e blash {} \;
Find all sample*_1.txt files/directories under current directory and print 'program  sample*-out sample*_1.txt sample*_2.txt' for each of them </s> find . -name "sample*_1.txt" | sed -n 's/_1\..*$//;h;s/$/_out/p;g;s/$/_1.txt/p;g;s/$/_2.txt/p' | xargs -L 3 echo program
Find all .tmp files under and below the /tmp/ directory and remove them </s> find /tmp -name "*.tmp"| xargs rm
Change permissions to 600 for all regular .rb files in the current directory tree </s> find . -name "*.rb" -type f -exec chmod 600 {} \;
Recursively prints paths to all text file in folder (ignores binary files). </s> grep -RIl "" .
search for all the files ending with "fits" in the folder "/store/01" </s> find /store/01 -name "*.fits"
Find all files in the current directory tree containing "foo" in their names </s> find . -print | grep -i foo
ssh into localhost on port 10022 </s> ssh -p 10022 localhost
Copy all .pdf files in the ./work/ directory tree with size bigger then 2 MB and modified more than 5 days ago to the ./backup/ directory </s> find ./work/ -type f -name "*.pdf" -mtime +5 -size +2M  | xargs -r cp -t ./backup/
Find all the files in entire file system which are greater than 50MB and less than 100MB. </s> find / -size +50M -size -100M
Search the /Path/bar* directories recursively for files matching pattern "file_name*" </s> find /Path/bar* -name "file_name*"
Find files under /usr that are the same age or older than file `FirstFile' </s> find /usr ! -newer /FirstFile -print
Print the list of regular files from the current directory that were last modified on November, 22 </s> find . -maxdepth 1 -type f -newermt "Nov 22" \! -newermt "Nov 23" -exec echo {} +
Find all directories starting from YOUR_STARTING_DIRECTORY that contain the string "99966" in their names </s> find YOUR_STARTING_DIRECTORY -type d -name "*99966*" -print
Print the file content of command "f" </s> cat `which f`
Print the grand total disk usage of all files listed in "files.txt" </s> cat files.txt | xargs du -c | tail -1
Find all 15MB files </s> find / -size 15M
Move all *.pdf.marker files and their corresponding *.pdf files under ${INPUT} to ${OUTPUT} </s> find ${INPUT}/ -name "*.pdf" -exec mv '{}' '{}'.marker ${OUTPUT} \;
Recursively changes group ownership of every file in '/var/tmp/jinfo' to 'www-data'. </s> chgrp -R www-data /var/tmp/jinfo
Checks that 'monit' user is in 'www-data' group. </s> groups monit |grep www-data
Count the total number of lines in all HTML files under /usr/src that contain string "foo" </s> find /usr/src -name "*.html" -execdir /usr/bin/grep -H "foo" {} ';' | wc -l
Remove all empty regular files under the current directory and below </s> find ./ -type f -size 0c -print | xargs rm
find in the entire file system for the file mysql </s> sudo find / -name mysql -print
Print file type of the executable file of command "file" </s> file `which file`
Numerically sort file "file.dat" by the second word of each line and output from greatest value to least value </s> sort -nk 2,2 file.dat | tac
Calculate the md5 sum of all files in the current directory with the filename printed first </s> find -maxdepth 1 -type f -exec md5sum {} \; | awk '{s=$2; $2=$1; $1=s;}1'
Find all 777 permission files and use chmod command to set permissions to 644 </s> find / -type f -perm 0777 -print -exec chmod 644 {} \;
Find files named tecmint.txt  of owner root in the entire file system </s> find / -user root -name tecmint.txt
display all the files in the current folder which have been modified in the last 5*24 hours </s> find . -mtime -5
prune all the files in the current directory, only current directory (.) is the output </s> find . -prune
Gets MAC address of 'eth0' network interface. </s> ifconfig eth0 | grep -Eo ..\(\:..\){5}
display all the files in the home folder which belong to the suer "bruno" and end with ".sxw" and have been accessed in the last 3*24 hours </s> find /home -type f -name *.sxw -atime -3 -user bruno
Execute awk script "script.awk" with 2 arguments both "file.txt" and format the output as a table </s> awk -f script.awk file.txt{,} | column -t
Find recursively all regular files in the current directory tree ending in .dll or .exe </s> find . -type f | grep -P "\.dll$|\.exe$"
Print A record for domain 'domain.' from 'ns1.newnameserver' nameserver </s> dig @ns1.newnameserver domain. a
Search the /usr/bin directory tree for regular files modified or created less than 10 days ago </s> find /usr/bin -type f -mtime -10
Find all files with the SUID bit set, starting from / </s> find / -perm -u+s
Split "file.txt" into files of at most 1 MiB in size with a numeric suffix, prefix "file", and additional suffix ".txt" </s> split -b 1M -d  file.txt file --additional-suffix=.txt
Print percentage of the space used on the $FILESYSTEM. </s> df -k $FILESYSTEM | tail -1 | awk '{print $5}'
Move all the .c files from the current directory tree to temp/ </s> find . -name "*.c" -print0 | xargs -0 -n1  -I '{}' mv '{}' temp
Find all directories named "0" in the current directory tree and create a tar archive of their RS* subdirectories </s> find . -type d -name "0" -execdir tar -cvf filename.tar RS* \;
display the count of all the directories present in a folder </s> find /mount/point -type d | wc -l
Search the current directory tree for regular files whose names end in ".shtml" or ".css" </s> find . -type f \( -name "*.shtml" -o -name "*.css" \) -print
Display system information: kernel name, hostname, kernel release and version, machine architecture, processor type, hardware platform, and operating system type. </s> uname -a
Recursively change owner and group to "$JBOSS_AS_USER" of "$JBOSS_AS_DIR" </s> chown -R $JBOSS_AS_USER:$JBOSS_AS_USER $JBOSS_AS_DIR
Truncate all non-empty regular files under the current directory </s> find . -type f -maxdepth 1 -not -empty -print0 | xargs -0i cp /dev/null {}
Change onwer to "root" and group to "wheel" of "com.xxxx.adbind.plist" </s> sudo chown root:wheel com.xxxx.adbind.plist
Print the boot time in standard date format </s> who -b | awk '{$1=""; $2=""; print $0}' | date -f -
Show all of the .conf files in Pat's user folder and subdirectories using the less pager </s> find /home/pat -iname "*.conf" | less
Set permissions to ug=rw,o= for files under the $d directory tree </s> find $d -type f -exec chmod ug=rw,o= '{}' \;
Print unique lines of sorted file "f1" compared to sorted file "f2" </s> comm -2 -3 f1 f2
Prints process tree of a process having id $ID with parent processes. </s> pstree -s $ID
Finds recursively all folders in current folder which path not contains "NameToExclude" string and removes only ones without files and another folders within. </s> find . -type 'd' | grep -v "NameToExclude" | xargs rmdir
find all the header files in /usr/include which have been modified in the last 400 days </s> find /usr/include -type f -mtime -400 -name "*.h"
Disable exiting the shell on error </s> set +e
Move all files/directories under current directory to ~/play </s> find . -exec mv '{}' ~/play/ \;
Find only number of hard link & name of files from long list </s> find -type f -iname "*.txt" -exec ls -lrt {} \;|awk -F' ' '{print $1 $2  $9}'
Find all files that are set group ID to staff </s> find . -group staff -perm -2000 -print
search for "some_function" in all the python files in the current directory </s> find . -name \*.py | xargs grep some_function
Save the network node hostname append with '-', the current date and '.txt' into variable 'filename' </s> filename="$(uname -n)-$(date +%F).txt"
Find the files that have "644" permissions and modify them to have "664" permissions </s> find . -type f -perm 644 -exec chmod 664 {} \;
Non-recursively finds all '*.pdf' files in a current folder and removes them. </s> find . -maxdepth 1 -name "*.pdf" -print0 | xargs -0 rm
Format and print the time string @133986838 according to the default time format </s> date --date @120024000
Get a recursive file list of directory $dir </s> find "$dir" -type f
Find all files/directories named 'foo' under current directory tree without descending into directories named 'foo' </s> find . -name foo -type d -prune -o -name foo
Archive file 'file' with bzip2 tool, store compressed data to a file 'logfile' and also print to screen </s> bzip2 -c file | tee -a logfile
find all files in the current folder which have been modified in the last 24 hours </s> find . -mtime -1 -print
Print each character in "orange" on a new line </s> echo orange | fold -w 1
Copy file linked to by "file" to "file" </s> cp --remove-destination `readlink file` file
copy all the regular files in the current directory to the temporary diectory. </s> find . -type f -exec cp {} /tmp +
Gets IP addresses of all active network interfaces. </s> ifconfig  | grep 'inet addr:'| grep -v '127.0.0.1' | cut -d: -f2 | awk '{ print $1}'
Mount all filesystems in /etc/fstab </s> sudo mount -a
Unzip all ".gz" files in the current directory tree to their respective directories </s> find . -name "*.gz" -execdir gunzip '{}' \;
Gets IP address of 'en0' network interface. </s> ifconfig en0 | awk '$1 == "inet" {print $2}'
Get the list of regular files in the current directory </s> find . -mindepth 1 -maxdepth 1 -type f -print0 | xargs -0 -I {} echo "{}"
List and sort all leaf directories (directories which don't contain any sub-directory) under current directory </s> find . -type d | sort | awk '$0 !~ last "/" {print last} {last=$0} END {print last}'
Enables shell options 'expand_aliases', 'extglob', 'xpg_echo'. </s> shopt -s expand_aliases extglob xpg_echo
Moves file '$2' to the folder where '$1' file is located. </s> mv "$2" "`dirname $1`"
Finds recursively all folders named 'a' within current folder and removes only ones without files and another folders within. </s> find -type d -name a -exec rmdir {} \;
Find all files matching the pattern "${pattern}" in their name and execute ${my_command} for each of them with the file path as argument </s> find ${directory} -name "${pattern}" -print0 | xargs -0 ${my_command}
Find all hidden files </s> find /tmp -type f -name ".*"
Rename file ~/junk/cart1 to ~/junk/A </s> find ~/junk  -name 'cart1' -exec mv {} ~/junk/A \;
Set permission of "file" to read only for the owner </s> chmod 600 file
Update timestamps of all files (not directories) under current directory. Also works on older Unix systems with obsolete 'find' command. </s> find . -print -exec touch {} \;
find StringBuffer in all *.java files, ignoring case </s> find . -type f -name "*.java" -exec grep -il string {} \;
find all the foo.txt files in the current folder and move them to another directory </s> find . -name "foo.txt" | awk '{ print "mv "$0" ~/bar/" | "sh" }'
list *.pdf, *.bmp and *.txt files under the /home/user/Desktop directory. </s> find /home/user/Desktop -name '*.pdf' -o -name '*.txt' -o -name '*.bmp'
Print source of the file system containing $path. </s> df -P $path | tail -1 | cut -d' ' -f 1
Find all 777 permission directories and use chmod command to set permissions to 755 </s> find / -type d -perm 777 -print -exec chmod 755 {} \;
display all regular/normal files in the folder /Users/david/Desktop/ </s> find /Users/david/Desktop/-type f
Opens menu item 'Basic Shell Features' -> 'Shell Expansions' -> 'Filename Expansion' -> 'Pattern Matching' in the 'bash' manual. </s> info bash 'Basic Shell Features' 'Shell Expansions' 'Filename Expansion' 'Pattern Matching'
Find all *.txt and *.json files </s> find . -type f \( -name "*.txt" -o -name "*.json" \)
Print the text file paths that match 'needle text' in their contents under 'my_folder' recursively </s> grep -rl "needle text" my_folder | tr '\n' '\0' | xargs -r -0 file | grep -e ':[^:]*text[^:]*$' | grep -v -e 'executable'
List all the emptry files in thecurrent directory only. </s> find . -maxdepth 1 -empty
find all the files in the current directory ending with ".i" </s> find . -name ".*\.i"
Find all files/directories under /myfiles that were modified 2 days ago </s> find /myfiles -mtime 2
Write standard input to standard output and file "/tmp/arjhaiX4" </s> tee /tmp/arjhaiX4
List all files in the /var directory tree whose size is greater than 10 megabytes </s> find /var/ -size +10M -ls
Find all regular files in the current directory tree, except GIT files </s> find .  -name .git -prune -o -type f -print
Search everywhere for hidden file `.profile' </s> find / -name .profile
Display the contents of variable "a" converted to lowercase. </s> echo "$a" | awk '{print tolower($0)}'
display a long listing of all the log files in the current folder which are bigger than 1MB </s> find . -size +1000k -name *.log -print0 | xargs -0 ls –lSh
extracts text between pattern1 and pattern2 if and only if the pattern1 is followed by pattern2 </s> tac infile | sed -ne '/pattern2/,/pattern1/ p' | tac -
Print percents of the space used on the file system containing path to the current working directory. </s> df . -B MB | tail -1 | awk {'print substr($5, 1, length($5)-1)'}
Change permissions of ".git/hooks/prepare-commit-msg" to 777 </s> sudo chmod 777 .git/hooks/prepare-commit-msg
Copy "*.cc", "*.h", and "SConstruct" to "rsync://localhost:40001/bledge_ce" using blocking IO </s> rsync --blocking-io *.cc *.h SConstruct rsync://localhost:40001/bledge_ce
Delete all __temp__* files/directories under current directory tree </s> find . -name __temp__* -exec rm -rf '{}' \;
Find all .js files in the $d directory tree whose pathnames do not contain whitespaces </s> find $d -name '*.js' | grep -v " "
Copy all files and directories under the current directory into "../new" preserving relative paths </s> find -print0 | sort -z | cpio -pdv0 ../new
Delete files in /var/tmp/stuff and below that have not been modified in over 90 days </s> find /var/tmp/stuff -mtime +90 -exec /bin/rm {} \+
Print all matching commands in $PATH for command "python" </s> which -a python
Prints long listing of content in the current folder with C-style escapes for nongraphic characters </s> ls -lb
Search the home directory tree for all .txt files </s> find ~/ -name '*.txt'
Prints top-ten biggest top-level folders within a 'var' folder. </s> sudo du -hDaxd1 /var | sort -h | tail -n10
find files which full path name is /tmp/foo/bar under foo directory and print </s> find /tmp/foo -path /tmp/foo/bar -print
Prints long listing of directories '/tmp', '/tnt' themselves bordered with '<--' and '--->'. </s> ls -ld /tmp /tnt | sed 's/^.*$/<-- & --->/'
display all file names in current folder </s> find . -printf '%p '
Find all files/directories under minimum 1 level down the $FOLDER directory and sort them </s> find "$FOLDER" -mindepth 1 | sort
Remount "/mnt/mountpoint" with read and write permission </s> mount /mnt/mountpoint -oremount,rw
Search the /dir directory tree for files whose names match regular expression '.*2015.*\(album.*\|picture.*\)' </s> find /dir -regex '.*2015.*\(album.*\|picture.*\)'
Print a minimal set of differences between files in directories "a" and "b", ignore differences in whitespace, and print 0 lines of unified context </s> diff -dbU0 a b
display all the ip addresses in all the files that are present in /etc folder </s> find /etc -exec grep '[0-9][0-9]*[.][0-9][0-9]*[.][0-9][0-9]*[.][0-9][0-9]*' {} \;
List current user's crontab. </s> crontab -l
Find files modified more recently than file poop </s> find . -newer poop
Saves exit statuses of piped commands in a system variable PIPESTATUS='([0]="1" [1]="2") </s> false | true
returns a list of  files modification newer than poop </s> find . -mnewer poop
Prints groups list that user 'el' belongs to. </s> groups el                                     //see that el is part of www-data
Search in the current directory and all sub-directories except ./D for the file named hi.dat </s> find -path ./D -prune -o -name hi.dat -print
List all files in the current directory tree invoking xargs only once </s> find . -type f -print | xargs ls -l
Format the date represented by time string @1267619929 according to default format and print it </s> date -ud @1267619929
display all the symbolic links in the current folder </s> find ./ -type l
Read standard input until a null character is found and save the result in variable "line" </s> read -d '' line
Gets back to the foreground a job with number 2. </s> fg 2
display all the text files in the current folder which have been modified in the last half minute ( 30 seconds ) </s> find . -mmin 0.5
Find all regular files under $DIR/tmp/daily/, sort them in reverse numerical order and copy the first two files to $DIR/tmp/weekly/ </s> find $DIR/tmp/daily/ -type f -printf "%p\n" | sort -rn | head -n 2 | xargs -I{} cp {} $DIR/tmp/weekly/
Find all files under ./lib/app and sort them </s> find ./lib/app -type f | sort
List all directories and subdirectories </s> find . -type d
Print and delete all directories named 'work' under '/usr/ports/' directory tree </s> find /usr/ports/ -name work -type d -print -exec rm -rf {} \;
Get the total sizes of all files under current directory </s> find path -type f -printf '%s\n' | awk '{sum += $1} END {print sum}'
Save the greater version number of "$1" and "$2" into variable "ver" </s> ver=`echo -ne "$1\n$2" |sort -Vr |head -n1`
Recursively print all files and directories in the current directory tree including hidden files </s> tree -a .
Execute /usr/bin/find with $* arguments </s> /usr/bin/find $*
Print a list of all regular files residing in the current directory </s> find . -maxdepth 1 -type f -print0
Search for *pattern* in and below current directory </s> find -name "*pattern*"
Gets list of IP addresses of all network interfaces. </s> ifconfig | grep -Eo 'inet (addr:)?([0-9]*\.){3}[0-9]*' | grep -Eo '([0-9]*\.){3}[0-9]*' | grep -v '127.0.0.1'
Counts lines in each *.cpp, *.c, *.h file. </s> wc -l `find . -type f \( -name "*.cpp" -o -name "*.c" -o -name "*.h" \) -print`
Print unique lines of sorted file "b" compared with sorted file "a" </s> comm -13 a b
Extract the contents of "Input.txt.gz", list the unique first comma separated field prefixed by the number of occurrences </s> zcat Input.txt.gz | cut -d , -f 1 | sort | uniq -c
Find the 5 largest regular files in the Downloads folder of tecmint's home directory. </s> find /home/tecmint/Downloads/ -type f -exec du -Sh {} + | sort -rh | head -n 5
display all normal/regular files in current directory </s> find . -type f -print0
Prints all business days in a current month. </s> cal -h | cut -c 4-17
extract 'archive.tar.gz' to /destination </s> gzip -dc archive.tar.gz | tar -xf - -C /destination
Prints process tree of user 'user' processes. </s> pstree -p user
find all the regular/normal files in the current folder which belong to the users with the user id's between 500 and 1000 </s> find . -uid +500 -uid -1000 -type f
lines.txt contains a list of line numbers, one entry per line - output only these lines from text.txt omitting the rest of the file. </s> cat -n text.txt | join -o2.2 lines.txt -
Remove all files whose names end with "~" in the /home/peter directory tree </s> find /home/peter -name *~ |xargs rm
Print the path names of all regular .rb files prefixing them with string "Hello, " </s> find . -name "*.rb" -type f | xargs -I {} echo Hello, {} !
Print the contents of "${SPOOL_FILE}" file to the console and append to "${LOG_FILE}" file </s> cat ${SPOOL_FILE}                   | tee -a ${LOG_FILE}
display a long listing of all the files in the current folder that have been accessed in today from the start of the day </s> find -daystart   -atime 0 -ls
prints the last non-empty line of a file </s> tac FILE |egrep -m 1 .
Print information of the root mount point </s> mount -v | grep " on / "
Search the current directory tree for files whose name is ".note", case insensitive </s> find . -iname '.note' | sort -r
change the owner of all the regular/normal files which belong to the root user to "tom" in the current folder </s> find .-type f -user root -exec chown tom {} \;
Search all files in the current directory tree whose names end in "1" for string "1" </s> find . -name "*1" -exec grep "1" {} \;
Use awk command 'FNR==NR { array[$1,$2]=$8; next } ($1,$2) in array { print $0 ";" array[$1,$2] }' on compressed files "input1.vcf.gz" and "input2.vcf.gz" </s> gzip -dc input1.vcf.gz input2.vcf.gz | awk 'FNR==NR { array[$1,$2]=$8; next } ($1,$2) in array { print $0 ";" array[$1,$2] }'
create directory temp into home directory </s> mkdir ~/temp
Print the first 32 hexadecimal characters from "/dev/urandom" </s> cat /dev/urandom | tr -cd 'a-f0-9' | head -c 32
Show all values (without the names) of variables whose name or value contains "VARIABLE_NAME" </s> myVariable=$(env  | grep VARIABLE_NAME | grep -oe '[^=]*$');
Find all files named 'aaa.txt' under current directory tree and display their contents </s> cat `find . -name aaa.txt`
Find all files, folders, symlinks, etc matching pattern "*.php" in the current directory recursively </s> find . -name \*.php
display a long listing of all the directories in the entire file system </s> find / -print0 -type d | xargs -0 ls -al
show all the ".flac" files in the current folder and do not search in the sub directories </s> find . -maxdepth 1 -type f -name '*.flac'
find all the files that have been modified exactly yesterday (from 00:00 to 23:59 yesterday) </s> find . -type f -daystart -mtime 1
Display the 5 smallest files in the current directory and its sub-directories ignoring any empty files. </s> find . -not -empty -type f -exec ls -s {} \; | sort -n  | head -5
Print all files in the current directory tree as a comma separated list </s> find . -type f | paste -d, -s
add read permission to others for the files in the current folder having the name "rc.conf" in their name. </s> find . -name "*rc.conf" -exec chmod o+r '{}' \;
Find all files more than 700 megabytes </s> find / -size +700M
Replace all occurrences of 'subdomainA.example.com' with 'subdomainB.example.com' in all regular files under '/home/www' directory tree </s> find /home/www -type f -print0 | xargs -0 sed -i 's/subdomainA.example.com/subdomainB.example.com/g'
Find all the files which are accessed in last 1 hour </s> find / -amin -60
Lookup information of the current user </s> finger `whoami`
Display non-hidden files in the current directory with the given output format </s> find . -maxdepth 1 -name '[!.]*' -printf 'Name: %16f Size: %6s\n'
Find all files/directories named 'Waldo' under 'Books' directory tree that is located in user's home directory </s> find ~/Books -name Waldo
Find all .js files in the current directory tree that do not contain a whitespace </s> find . -type f -name '*.js' \( -exec grep -q '[[:space:]]' {} \; -o -print \)
List all directories in current directory, works even if they have weird names or names starting with a dash. </s> find -maxdepth 1 -type d | awk -F"./" '{print $2}'
display all the details of empty files in current folder </s> find . -size 0 -printf '%M %n %u %g %s %Tb\n \b%Td %Tk:%TM %p\n'
Find the directory with least modification time under current directory </s> find -type d -printf '%T+ %p\n' | sort | head -1
locate large files (> 100 MB) in /home/ for 'cleaning' </s> find /home -type f -size +100M -print0 |xargs -0 rm
Request IP address for each domain name received on the command input </s> dig +short -f - | uniq
Connect to host "$USER_AT_HOST" in master mode in the background without executing any commands and set the ControlPath to "$SSHSOCKET" </s> ssh -M -f -N -o ControlPath="$SSHSOCKET" "$USER_AT_HOST"
forcibly and verbosely create symbolic links in directory "~/Library/LaunchAgents" to all files located in /usr/local/opt/mongodb/ and that have filename extension ".plist" </s> ln -sfv /usr/local/opt/mongodb/*.plist ~/Library/LaunchAgents
List all files in /home/bozo/projects directory tree that were modified exactly one day ago. </s> find /home/bozo/projects -mtime 1
Print numbers from 1 to 10 with 2 values per line </s> seq 10 | sed '2~2G' | awk -v RS='' '{$1=$1; print}'
Create a table containing all information from S43.txt and S44.txt, merging lines where the first field of both files matches, and keeping the line that starts with "Gene" at the start of the file. </s> join -a1 -a2 <(sed s/^Gene/00ne/ S43.txt | sort) <(sed s/^Gene/00ne/ S44.txt | sort) | column -t | sed s/^00ne/Gene/
Search all directories starting from the root directory for "filename" </s> find / -iname "filename"
Replace all occurrence of "subdomainA.example.com" with "subdomainB.example.com" in all files under /home/www and below </s> find /home/www -type f -print0 | xargs -0 sed -i 's/subdomainA.example.com/subdomainB.example.com/g'
Find .jpg files owned by user daniel in the current directory and its sub-directories. </s> find . -user daniel -type f -name *.jpg
display a long list of the files in the current folder which have the word fuddel in all the files in the current folder and then search for the word fiddel in the previously matched files </s> find -exec grep -q fuddel {} ";" -exec grep -q fiddel {} ";" -ls
Takes path list from '.exportfiles.text' file, cuts off first two path segments and last one. </s> cut -d / -f 4- .exportfiles.text | xargs -n 1 dirname
display all sqlite files in the current directory along with their timestamp </s> find ./ -name "*.sqlite" -printf '%Tc %p\n'
show all the files in the current folder excluding those from the directories whose name starts with "git" </s> find . -type d -name '.git*' -prune -o -type f -print
Display who is logged on and what they are doing </s> w
Find all files/directories named 'my.txt' in the entire filesystem </s> find / -name "my.txt"
List only the non-hidden empty files only in the current directory. </s> find . -maxdepth 1 -empty -not -name ".*"
Find all files/directories in entire file system that are owned by "syslog" user </s> find / -user syslog
Print the physical current working directory </s> echo "`pwd -P`"
Find empty files under test directory </s> find test -empty
Find all *.txt files/directories under current directory </s> find . -name *.txt -print
Receive pattern to search for on the standard input and print only matching part of lines from file 'f.html' </s> cat f.html | grep -o \
Change the ownership to the user daisy for all directories under current directory that are owned by harry </s> find . -type d -user harry -exec chown daisy {} \;
search for all the regular/normal files  in the /etc folder which have been modified in the last 24 hours </s> find /etc/ -type f -mtime -1
search for text files in the current folder which do not have write access to others </s> find . -type f \( -iname "*.txt" ! -perm -o=w \)
Append history lines from this session to the history list </s> history -a
Count the number of equal lines in "file1.txt" and "file2.txt" </s> comm -12 <(sort file1.txt) <(sort file2.txt) | wc -l
Print a space separated list of numbers from 1 to 10 </s> seq 10 | xargs
Find all files under current directory and replace the match of the regex '^.*/S' with 'S' in every line of the output </s> find . -type f -print | sed 's|^.*/S|S|'
find all the html, javascript and text files in the current folder </s> find . -type f -name "*.htm*" -o -name "*.js*" -o -name "*.txt"
Find all the files in the current directory with “linkin park” in their names </s> find . -maxdepth 1 -iname "*linkin park*"
Make directory and parents as needed for each unique mime type in the current directory </s> mkdir -p `file -b --mime-type *|uniq`
Run the find command with all shell positional arguments </s> `which find` "$@" -print0;
search for all the files in current folder and display all the file names separated by space </s> find . | paste -sd " "
find all the files in the home folder which end with ".tex" </s> find ~ -iname '*.tex'
Recursively finds all '*.pdf' files in a current folder and removes them. </s> find . -name "*.pdf" -exec rm {} \;
Set the variable "me" to the name of the running script. </s> me=`basename "$0"`
Find all the regular files under directory 'dir1' that are at least N levels deep </s> find dir1 -mindepth N -type f
Find all *.php (case insensitive) files and *.js files/directories (case insensitive) under /home/jul/here excluding $EXCLUDE/* paths </s> find /home/jul/here -type f -iname "*.php" ! -path "$EXCLUDE/*" -o -iname "*.js" ! -path "$EXCLUDE/*"
Search the current directory tree for files containing "string" in their path names </s> find | egrep string
display all the regular/normal files in the /root folder which are bigger than 500MB </s> find /root -type f -size +500M -printf "The %p file is greater than 500MB\n"
Find a 400 permission file under /data directory </s> find /data -type f -perm 400 -print -quit
Print file information of command "studio" </s> ls -l "$( which studio )"
find all the files in the current directory which have the size 40 bytes in the current disk partition. </s> find . -size -40 -xdev -print
SSH into $1 with login name 'pete' </s> ssh "$1" -l pete
find all files that do not have execute permission to all </s> find . -type d ! -perm -111
Make a copy of the entire contents of SRCFOLDER called "DESTFOLDER", if DESTFOLDER exists, the copy will be placed within it. </s> cp -R SRCFOLDER DESTFOLDER/
Remove all "CVS" directories from the current directory tree, ignoring the case </s> find . -iname CVS -type d | xargs rm -rf
Search "file1" for lines matching regex patterns listed in "file2" and list the unique results (sorted alphabetically) </s> grep -f file2 file1 | sort -u
search for the file foo.txt in the entire file system </s> find / -name foo.txt
Search the file hierarchy for files larger than 100000 KB without searching any mounted removable media </s> find / -path /media -prune -o -size +200000 -print
Find all regular files in /usr/bin accessed more than 20 days ago </s> find /usr/bin -type f -atime +20
Find files on the system accessed during the last 24 hours but not within the last hour </s> find / -atime -1 -amin +60
Print lines unique and common to sorted files "file1" and  "file2" </s> comm file1 file2
Mount "ext4" filesystem "/dev/xvdf1" on "/vol" </s> sudo mount /dev/xvdf1 /vol -t ext4
Show the subdirectories of the current directory </s> find . -maxdepth 1 -type d -print | xargs echo Directories:
find all files in the file system whose size is exactly 2KB </s> find / -size 2048c
Recursively finds all files with any cased text "Text" in a current folder, and precedes found string with its number in file. </s> grep -inr "Text" folder/to/be/searched/
Recursively removes all files like '_*' and '.DS_Store' from /var/www/html/ folder. </s> rm /var/www/html/**/_* /var/www/html/**/.DS_Store
Find directories in the current directory tree that were modified within the last 24 hours and move them to /path/to/target-dir </s> find . -type d -mtime -0 -exec mv -t /path/to/target-dir {} +
delete all the regular files in the temp folder which have not been modified in the last 24 hours + at the end gives bulk input to the rm command </s> find /tmp/ -type f -mtime +1 -exec rm {} +
Search the current directory tree for regular files lacking read permissions for user, group, or others </s> find . -type f ! -perm -444
Find all *.tar.gz files/directories under /directory/whatever which were modified more than $DAYS ago </s> find /directory/whatever -name '*.tar.gz' -mtime +$DAYS
Find directories that are directly under $workspace_ts directory (no-subdirectories) and were modified more than 30 days ago </s> find $workspace_ts -mindepth 1 -maxdepth 1 -type d -mtime +30 -print
Find all file1 and file9 files/directories under current directory </s> find . -name file1 -or -name file9
Recursively change owner to "amzadm" and group to "root" of all files in "/usr/lib/python2.6/site-packages/" </s> chown amzadm.root -R /usr/lib/python2.6/site-packages/
Display all environment variables, functions, and aliases, pausing for user interaction after each page of output. </s> set | more
Finds string beginning with 'IFS' in a 'set' output. </s> set | grep ^IFS=
This will remove all files (type f) modified longer than 14 days ago under /root/Maildir/ recursively from there and deeper (mindepth 1 </s> find /root/Maildir/ -mindepth 1 -type f -mtime +14 | xargs rm
Print the IP addresses for the current host name </s> hostname -I | awk '{print $1}'
Print 'huzzah' if /some/dir/ is empty </s> find /some/dir/ -maxdepth 0 -empty -exec echo "huzzah" \;
find all the files in the current folder which do not belong to any user </s> find . -nouser -ls
Remove all "core" regular files in the /tmp/ directory tree </s> find /tmp -name core -type f -print | xargs /bin/rm -f
List all directories in maximum 1 level down the current directory </s> find . -type d -maxdepth 1 -exec ls -dlrt {} \;
search for the file "file1" in the entire file system </s> find / -name file1
Replace 'company' with 'newcompany' in all files under current directory </s> find ./ -type f -exec sed -i 's/company/newcompany/' {} \;
Find all files/directories with space in their names under  /tmp/ directory and rename them by replacing all spaces with _ </s> find /tmp/ -depth -name "* *" -execdir rename " " "_" "{}" ";"
Rename all "thumbs" directories to "thumb" in the current directory tree </s> find . -type d | awk -F'/' '{print NF, $0}' | sort -k 1 -n -r | awk '{print $2}' | sed 'p;s/\(.*\)thumbs/\1thumb/' | xargs -n2 mv
Search for '/usr/bin/perl' in all regular files under current dirctory tree and also show a long listing of them </s> find . -type f -exec grep "/usr/bin/perl" {} \; -ls
Print the contents of "numbers.txt" </s> cat numbers.txt
Save the directory name of the canonical path to the current script in variable "MY_DIR" </s> MY_DIR=$(dirname $(readlink -f $0))
Remove all regular files from the current directory tree except textfile.txt, backup.tar.gz, script.php, database.sql, info.txt </s> find . -type f ! -regex ".*/\(textfile.txt\|backup.tar.gz\|script.php\|database.sql\|info.txt\)" -delete
Prints strings with MAC address configuration of each network interface in system. </s> ifconfig | grep HW
Print the second line of output of "ls -l" </s> ls -l | head -2 | tail -1
Create an empty file in each directory named "mydir" under current directory. </s> find . -type d -name "mydir" -exec touch '{}/abc.txt' \;
Duplicate directory tree under /mnt/usr/lib to /usr but creating symlinks to files instead of copying them. </s> cp -rs /mnt/usr/lib /usr/
Save the directory of the full path to the current script in variable "dir" </s> dir=$(dirname $(readlink /proc/$$/fd/255))
Output lines 16224 to 16482 of 'file', not recommended with large files that contain many lines after the ones needed. </s> awk 'NR==16224, NR==16482' file
Find all Read Only files in the file system </s> find / -perm /u=r
For every cron job with a comment "change-enabled" at the end of its crontab entry, change the scheduled hour to 7. </s> crontab -l | sed -re '/# *change-enabled *$/s/^([^ ]+) [^ ]+/\1 7/' | crontab -
Find all regular files named 'Chapter1' under current directory tree </s> find . -name Chapter1 -type f -print
Print all filenames under /proc and below </s> find /proc | xargs
Remove the last file extension from standard input </s> sed 's/^/./' | rev | cut -d. -f2- | rev | cut -c2-
find all the ".jpg" files in current folder and display their count </s> find ./ -name '*.jpg' -type f | wc -l
Delete all directories found in $LOGDIR that are more than a work-week old </s> find $LOGDIR -type d -mtime +5 -exec rm -rf {} \;
Find all the files that were modified more than one day ago </s> find . -mtime +1
find all the empty directories in current folder and delete them </s> find ./ -empty -type d -delete
Recursively change the ownership of all files in "/Users/xxx/Library/Developer/Xcode/Templates" to "xxx" </s> sudo chown -R xxx /Users/xxx/Library/Developer/Xcode/Templates
Find all *.java files under current directory </s> find . -name "*.java"
Lists all files in a current folder, separating names with comma. </s> ls -m
Create symbolic links in the current directory for all files located in directory "/path/with/files" with a name containing "txt" </s> find /path/with/files -type f -name "*txt*" -exec ln -s {} . ';'
Remove all vmware-*.log files under current directory </s> find . -name vmware-*.log -delete
Search the current directory tree for all .java files newer than the file build.xml </s> find . -name '*.java' -newer build.xml -print
search for the word "nameserver" in all the regular/normal files in the /etc directory and display the name of the file along with the matched line </s> find /etc/ -iname "*" -type f -print0 | xargs -0 grep -H "nameserver"
Print the current directory tree with file sizes </s> tree -s
Create master SSH control socket "my-ctrl-socket" in the background with no terminal or command execution with connection forwarding from localhost port 50000 to localhost port 3306 via "jm@sampledomani.com" </s> ssh -M -S my-ctrl-socket -fnNT -L 50000:localhost:3306 jm@sampledomain.com
Print a 2 byte hexadecimal value, printable character, and octal value of "$1" </s> echo "$1" | od -xcb
find all PDFs owned by user “seamstress” </s> find / -user seamstress -iname “*.pdf”
create a link to all the html or htm files in the current folder which have been changed in the last 30*24 hours </s> find \( -name "*.htm" -o -name "*.html" \) -a -ctime -30 -exec ln {} /var/www/obsolete \;
search for all non empty regular/normal files in the current folder and empty them ie., delete the content not the file </s> find . -type f -maxdepth 1 -not -empty -print0 | xargs -0i cp /dev/null {}
Print the file 'text1;text2;text3' replacing each space(" ") with a newline </s> cat "text1;text2;text3" | sed -e 's/ /\n/g'
Changes group ownership of 'public' and 'private' to 'god'. </s> chgrp god public private
Find all files on the system whose names are 'composer.json' and search them for "drush" </s> find / -name composer.json -exec grep -n drush {} /dev/null \;
find all the text files in the current folder and display their Permissions and size along with their name </s> find . -name "*.txt" -printf "%M %f \t %s bytes \t%y\n"
Search the home directory tree for files owned by sam </s> find /home -user sam
Find files modified in the last 5 minutes starting from the current directory </s> find . -mmin -5
simulate a full login of user root </s> su -
Archive "somedir/./foo/bar/baz.c" to "remote:/tmp/" preserving the relative path of "foo/bar/baz.c" </s> rsync -avR somedir/./foo/bar/baz.c remote:/tmp/
display all the ".c" files in the folder "/home/david" which have been accessed in the last 48 hours </s> find /home/david -atime -2 -name '*.c'
Find all files beneath the current directory that end with the extension .java and contain the characters StringBuffer.  Print the name of the file where a match is found. </s> find . -type f -name "*.java" -exec grep -l StringBuffer {} \;
search all the files in the folder "myfiles" which have the word "blue" in their name </s> find /myfiles -name '*blue*'
Find files/directories writable by group and others under the /path directory </s> find /path -perm -go+w
Finds file 'Subscription.java' and changes to containing folder. </s> cd `find . -name Subscription.java | xargs dirname`
Replace the occurrences of "HOGE" with "MOGA" once per each line of the .yaml files from the current directory tree </s> find . -type f -name "*.yaml" -print0 | xargs -0 sed -i -e "s/HOGE/MOGA/"
Print file name without the last two extensions assuming the file name doesn't contain any other dots. </s> echo "$FILE"|rev|cut -d"." -f3-|rev
Calculate the total disk usage for each ".jpg" file on the system and prepend the system host name to the output </s> find "$PWD" / -iname '*.jpg' -exec du -s {} + | sed "s/^/$(hostname): /"
find all the files in the current folder that have not been modified in the last 24*3 hours </s> find ./ -mtime +3
find all the files in the file system that belong to the user www </s> find / -user www -print
List all files in the /myfiles directory tree </s> find /myfiles -exec ls -l {} ;
Create tar.gz files older than one day logs </s> find /home/testuser/log/ -mtime +1 | xargs  tar -czvPf  /opt/older_log_$(date +%F).tar.gz
Archive "foo/bar/baz.c" to "remote:/tmp/" preserving the relative path of "foo/bar/baz.c" </s> rsync -avR foo/bar/baz.c remote:/tmp/
Copies all files under the current directory but ones with '*/not-from-here/*' in path to the '/dest/' directory. </s> find . -type f -not -iname '*/not-from-here/*' -exec cp '{}' '/dest/{}' ';'
Find file `foo.bar' and delete it </s> find /home -name foo.bar -type f -exec rm -f "{}" ';'
find all the directories  with the name "c" in the current folder which are at least 3 levels deep and which are not present in the path "/p/". </s> find -mindepth 3 -type d ! -path '*/p/*' -name c -print
delete all the empty in the current folder do not search in sub directories </s> find . -maxdepth 1 -type d -empty -exec rm {} \;
change the permissions of all regular/normal files in the current directory, print0 is used for handling files with newlines in their file name </s> find . -type f -print0 | xargs -0 chmod 664
search for the pattern "tgt/etc/file1" in the files tgt/etc/file2, tgt/etc/file3 </s> find . -type f -name \* | grep tgt/etc/file1 tgt/etc/file2 tgt/etc/file3
Create an empty file with a carriage return character in its name. </s> echo -e "Icon\\r" | xargs touch
Finds all logged in users. </s> w | awk '{print $1}'
create directory foo </s> mkdir foo
find all files in the current folder that are not modified in the last 240 hours </s> find . -mtime +10 -print
Lists all directories in '/home/alice/Documents/'. </s> ls -d /home/alice/Documents/*/
display all the files in the file system which are changed a minute ago </s> find / -newerct '1 minute ago' -print
Print "This is a sentence." by replacing all consecutive space characters with a single newline character </s> echo "This is   a sentence." | tr -s " " "\012"
Use awk command '{ ... }' on compressed files "input1.vcf.gz" and "input2.vcf.gz" </s> awk '{ ... }' <(gzip -dc input1.vcf.gz) <(gzip -dc input2.vcf.gz)
find all the ogg files in the current directory which have the word "monfichier" in their name </s> find -name *monfichier*.ogg
Disables overwriting existing files </s> set -o noclobber
searches through the root filesystem ("/") for the file named Chapter1, and prints the location </s> find / -name Chapter1 -type f -print
List all regular files in and below the home directory that have been modified in the last 90 minutes </s> find ~ -type f -mmin -90 | xargs ls -l
Find all files in the current directory tree whose size is greater than 1MB </s> find . -size +1M
Find all directories under /home/username/public_html/sites/default/files and set their permission to 770 </s> find /home/username/public_html/sites/default/files -type d -exec chmod 770 {} +
list all files in /home/bozo/projects directory tree that were modified within the last day </s> find /home/bozo/projects -mtime -1
Print only first line of 'file' content, formatted as 29-symbol wide column </s> cat file | fold -w29 | head -1
Copy file in current directory of local host to host "remote", connecting as ssh user matching current local username, and copying the file in home directory on remote host - enable compression during transfer. </s> scp -C file remote:
Find all *.xml.bz2 files under current directory </s> find . | grep ".xml.bz2$"
Cut all remote paths from HTTP URLs received from standard input (one per line) keeping only the protocol identifier and host name, of the form http://example.com </s> sed -n 's;\(http://[^/]*\)/.*;\1;p'
Search the `research' directory and one level below for directories that are not owned by group `ian' </s> find -L research -maxdepth 2 -type d ! -group ian
Change directory to the real path of the current working directory of process "$PID" </s> cd $(readlink /proc/$PID/cwd)
Find all *.err files under current directory that are larger than 5120 bytes in size </s> find . -type f -size +10 -name "*.err"
Find all files/directories named modules under current directory and list them twice </s> find . -name modules \! -exec sh -c 'find -name modules' \;
Find all *.mp3 (case insensitive) files/directories under /tmp and remove them </s> find /tmp -iname '*.mp3' -print0 | xargs -0 rm
Changes group ownership of '/home/www-user/php_user.sh'  to 'www-data'. </s> chgrp www-data /home/www-user/php_user.sh
Prints long listing of ${0} file. </s> ls -l ${0}
search for *.log files starting from / </s> find / -name "*.log"
Print the output of history without line numbers </s> history | cut -d' ' -f4- | sed 's/^ \(.*$\)/\1/g'
Compresses all '*.xml' files under current directory with 'bzip2' utility. </s> find -name \*.xml -print0 | xargs -0 -n 1 -P 3 bzip2
Find all *.* directories under /home/feeds/data directory </s> find /home/feeds/data -type d \( -name 'def/incoming' -o -name '456/incoming' -o -name arkona \) -prune -o -name '*.*' -print
Print each logged in user's full name </s> finger -l | grep "Name:" | cut -d ":" -f 3 | cut -c 2- | sort | uniq
search for all the files in the current folder which are bigger than 10KB and display them biggest file </s> find . -size +10k -exec ls -ls {} \+ | sort -n | tail -1
Create intermediate directories foo and bar as required and directory foo/bar/baz </s> mkdir -p foo/bar/baz
Changes group ownership of 'shared' to 'Workers'. </s> chgrp Workers shared
Save the FQDN host name of the system in variable "hnd" </s> hnd=$(hostname -f)
Print "*Checking Partition Permission* Hostname=$(hostname) LastChecked=" followed by the current date </s> echo -n *Checking Partition Permission* Hostname=$(hostname) LastChecked=$(date)
Removes all files from current folder but 5 newest ones. </s> ls -C1 -t| awk 'NR>5'|xargs rm
Print the login time and user of the first person who logged in </s> who | awk '{print $3 " " $4 " "$1}' | sort | head -1
Copy all files (not directories) in "/path/to/local/storage" to "/path/to/copy" on host "remote.host" authenticating as user "user" </s> rsync /path/to/local/storage user@remote.host:/path/to/copy
Make a list of all files in the current directory tree, except *.png and *.class, and view it in the vim editor </s> find . | grep -v "\.png$" | grep -v "\.class$" | vim -
Search all the regular files in the current directory for "example" </s> find -maxdepth 1 -type f | xargs grep -F 'example'
Get a recursive file list of directory $dir </s> find $dir -type f
delete all the normal files in the current directory whcih have the word "gui" in their content. </s> find / -type f -print0 | xargs -0 grep -liwZ GUI | xargs -0 rm -f
List the files from the current directory tree that contain lines matching regular expression  '^Subject:.*unique subject' </s> find . -type f -print0 | xargs -0 grep -il '^Subject:.*unique subject'
Create a symbolc link named "latest" to the last modified file or directory in "target-directory" </s> ln -s target-directory/`ls -rt target-directory | tail -n1` latest
Search the *.code files from the current directory tree for string 'pattern' </s> find . -name '*.code' -exec grep -H 'pattern' {} +
find all symbolic links under /usr </s> find /usr -type l
Display the content of file "f" in home directory if it exists and is executable </s> cat `which ~/f`
List all IPV4 addresses found in all files under /etc directory </s> find /etc -type f -exec cat '{}' \; | tr -c '.[:digit:]' '\n'  | grep '^[^.][^.]*\.[^.][^.]*\.[^.][^.]*\.[^.][^.]*$'
Find '.java' files with checksum 0bee89b07a248e27c83fc3d5951213c1 in the current directory </s> md5sum *.java | grep 0bee89b07a248e27c83fc3d5951213c1
Find all *.rpm files/directories under current directory </s> find . -name '*.rpm'
Find all top-level files in the current folder but ones with name like '*Music*' to the 'dest/' folder. </s> find . -maxdepth 1 -name '*Music*' -prune -o -print0 | xargs -0 -i cp {} dest/
Find all broken symlinks under current directory </s> find -type l -xtype l
display all mp3 files in the file system which have not been accessed in the last 24 hours </s> find / -name “*.mp3” -atime +01 -type f
Print linux group names on multiple lines instead of single line output </s> groups | tr \  \\n
search for mp3 files in the folder /mp3collection which are smaller than 5MB </s> find /mp3collection -name '*.mp3' -size -5000k
Replace all colons (':') with newlines in $list and search for the first match to the regex "^$removepat\$" where $removepat is a variable and save the result to variable 'removestr' </s> removestr=$(echo "$list" | tr ":" "\n" | grep -m 1 "^$removepat\$")
Replace all newlines from standard input except the last with spaces </s> sed ':a;N;$!ba;s/\n/ /g'
Read yesterday's date with format "%a %d/%m/%Y" into variable "dt" in a subshell </s> date --date yesterday "+%a %d/%m/%Y" | read dt
Set permissions for all direcotries under /var/www to 755 </s> find /var/www -type d -print0 | xargs -0 chmod 755
Request that the master ssh connection "officefirewall" exits </s> ssh -O exit officefirewall
Search the current directory tree for directories </s> find "$PWD" -type d
Print the empty directories and files under current directory </s> find -empty
Prints folder where current script is located </s> echo "dirname: `dirname $0`"
Find files in the current directory recursively that are not readable by all </s> find -type f ! -perm -444
Force create a symbolic link named "mylink" with target "/apps/myapps/new/link/target" </s> ln -f -s /apps/myapps/new/link/target mylink
Copy and always overwrite all files in "/zzz/zzz" to "/xxx/xxx" </s> yes | cp -rf /zzz/zzz/* /xxx/xxx
Find all files under the current directory whose pathnames do not end with "Video", ignoring the case </s> find . -maxdepth 1 -not -iwholename '*Video'
Find all files/directores that are newer than /etc/motd and conain the string 'top' at the beginning of their names under user's home directory tree </s> find ~ -name 'top*' -newer /etc/motd
Find command will display top 10 Big files from current directory . </s> find . -type f -exec ls -s {} \; |sort -n -r |head
display the number of lines in all the files in the current folder </s> find . -exec wc -l {} \;
Print the day at 1 day ago in 2 months from now </s> date -d "$(date -d "2 months" +%Y-%m-1) -1 day" +%a
Get the total size of all files under dir1 directory </s> find dir1 ! -type d -printf "%s\n" | awk '{sum += $1} END{print sum}'
Find all files that were last accessed more than 7 days ago under /home </s> find /home -atime +7
List each file or directory in the current directory prefixed by its human readable filesize and sorted from largest to smallest </s> du -h --max-depth=0 * | sort -hr
delete all the tmp files ( files with the extension tmp ) in the /tmp folder. Print0 is used to display all those files which have newline in their names or files whose name is only spaces. </s> find /tmp -name "*.tmp" -print0 | xargs -0 rm   find /tmp -name "*.tmp" -print0 | xargs -0 rm
find the file "MyCProgram.c" in the current folder </s> find -iname "MyCProgram.c"
Move all files and directories in the current directory to "somewhere/" </s> mv `ls` somewhere/
Display summary of each specified file in human readable form </s> du -sh *
Find all files and directories last modified less than a day ago and copy to "../changeset" creating directories as needed </s> find * -mtime -1 -daystart -print0 | cpio -pd0 ../changeset
Find broken symlinks in current directory </s> find . -type l -xtype l
change the permissions of the directories from 777 to 755 in the folder "/var/www/html" </s> find /var/www/html -type d -perm 777 -print -exec chmod 755 {} \;
Output the variable "filename" without the last dot-separated section. </s> echo ${filename%.*}
display a list of all the files in the file system which do not belong to any group and search only in jfs and jfs2 file systems </s> find / -nogroup \( -fstype jfs -o -fstype jfs2 \) -ls
Rename "original.filename" to "new.original.filename" </s> mv original.filename new.original.filename
display list of all the hidden regular/normal files in the directory "/dir/to/search/" </s> find /dir/to/search/ -type f -iname ".*" -ls
Prints path location of $BASH_SOURCE file. </s> echo this dir: `dirname $BASH_SOURCE`
Move all *.emlx files/directories under /path/to/folders/ to ./Messages/ directory </s> find /path/to/folders/ -name \*.emlx -print0 | xargs -0 -I {} mv {} ./Messages/
Recursively changes group ownership of every folder in a current directory to the name of that folder. </s> find . -type d | sed -e 's/^\.\///g' | awk '{print $1, $1}' | xargs chgrp
Find all *.txt files that reside under and below /home/wsuNID/ </s> find /home/wsuNID/ -name "*.txt"
Find files named "needle" ignoring the case </s> find . -iname "needle"
Find all regular files with permissions 777 under and below /home/user/demo/ </s> find /home/user/demo -type f -perm 777 -print
Find all directories under htdocs directory and set their permission to 775 </s> find htdocs -type d -exec chmod 775 {} +
Find all regular files with space in their names under current directory and rename them by replacing all spaces with _ </s> find -name "* *" -type f | rename 's/ /_/g'
Create intermediate directories "full", "path" as required and directory "to" </s> mkdir -p `dirname /full/path/to/file.txt`
Print a sorted list of all .jpg files in the current directory and below </s> find -name '*.jpg' | sort -n
Sort file "foo.txt" by line to standard output </s> sort foo.txt
Print only name and login columns of the currently logged in users </s> finger -s | awk '{printf("%s %s\n", $1, $2);}'
Find all files with '.conf' extension under '/etc' directory tree that have been modified in the last 30 minutes </s> find /etc -name "*.conf" -mmin -30
Find all files with '.conf' extension under '/etc' directory going into at most 2 level deep and show the last 10 of them </s> find /etc -maxdepth 2 -name "*.conf" | tail
display all the files in the folders mydir1, mydir2 which are bigger than 2KB and have not been accessed in the last 30*24 hours </s> find /mydir1 /mydir2 -size +2000 -atime +30 -print
Change owner to "$1" and group to "httpd" of ".htaccess" </s> chown $1:httpd .htaccess
Search /usr/local for subdirectories whose names end with a number 0-9 </s> find /usr/local -maxdepth 1 -type d -name '*[0-9]'
Find recursively all empty directories in the current directory </s> find . -type d -empty
Print lines in "foo.txt" that are found only once </s> sort foo.txt | uniq
List all files in the current directory tree except for those in the ./src/emacs directory </s> find . -path './src/emacs' -prune -o -print
Disables shell option 'dotglob'. </s> shopt -u dotglob
Search the current directory recursively for regular files last accessed 2 days ago </s> find . type -f -atime 2
Change the ownership of "/home/bob" to "root" </s> sudo chown root /home/bob
Find all regular files under '/home/john/scripts' directory tree excluding files with '.ksh' extension </s> find /home/john/scripts -type f -not -name "*.ksh" -print
Find all *.swp files/directories under current directory </s> find . -name "*.swp"
Calculate md5 checksum of the list of all files/dirs in /path recursively including dot files and excluding the patterns 'run', 'sys', 'tmp' and 'proc', then check the checksum against the checksum saved in /tmp/file </s> ls -alR -I dev -I run -I sys -I tmp -I proc /path | md5sum -c /tmp/file
Find all regular files that reside in the current directory tree and were last modified more than 3 days ago </s> find . -type f -mtime +3
Recursively finds all '*.pdf' files and folders in a current folder and removes them without prompting. </s> find . -name "*.pdf" -print0 | xargs -0 rm -rf
Change the permission to 0644 for all files under current directory </s> find . -type f -exec chmod 0644 {} +
find all data files in current folder which have not been changed in the last 60 minutes and display their name without extension </s> find . -name "*.dat" -type f -cmin +60 | grep "^./[^/]\+dat" | sed "s/^.\///"
Find all .core files on the system starting from / and delete them </s> find / -name "*.core" | xargs rm
Compress all files in the "$FILE" directory tree that were last modified 30 days ago and have not already been compressed with gzip </s> find $FILE -type f -not -name '*.gz' -mtime 30 -exec gzip {} \;
display a long listing of all the files in the current directory </s> find . -name  * -exec ls -a {} \;
display long listing of all the files in the root folder which are bigger than 3KB </s> find / -dev -size +3000 -exec ls -l {} ;
Merge lines from files "file1", "file2", "file3", "file4", "file5", replace "\t" with " \t", and format the "\t" delimited result as a table </s> paste file{1,2,3,4} | sed -e 's/\t/ \t/g' | column -t -s$'\t'
Find all file.ext files/directories under present working directory and print . for each of them </s> find `pwd` -name "file.ext" -exec echo $(dirname {}) \;
display all empty files in the current folder </s> find . -size 0k
Prints only unique strings of those stored in variables $COMMANDS and $ALIASES. </s> echo "$COMMANDS"$'\n'"$ALIASES" | sort -u
Copy all files from the current directory tree to /path/to/destination/dir preserving their times, permissions, and ownership </s> find . | cpio -pdumv /path/to/destination/dir
read all history lines not already read from the history file </s> history -n
find files which full path name like '*/*config' at current directory and print </s> find .  -path '*/*config'
Report total size of the root filesystem disk usage in powers of 1000. </s> df -H --total /
Find all thumb.png files in the temps/ directory tree </s> find temps/ -name "thumb.png"
find all the files in the current folder which have been modified in the last 60 minutes, which are atleast 1 level deep and display a long listing of these files </s> find . -mindepth 1 -mmin -60 | xargs -r ls -ld
Remove file with inode number 31246 </s> find . -inum 31246 -exec rm [] ';'
Split "$FILENAME" into files with at most 20 lines each with a prefix "xyz" </s> split -l 20 $FILENAME xyz
Display standard input as a table with "${tab}" separators </s> column -s"${tab}" -t
Scan every file in /etc for IPV4 addresses while trying to elminate false positives. </s> find /etc -type f -exec cat '{}' \; | tr -c '.[:digit:]' '\n' | grep '^[^.][^.]*\.[^.][^.]*\.[^.][^.]*\.[^.][^.]*$'
Remove the files from the home directory tree that were last accessed more than 100 days ago, with confirmation </s> find ~/ -atime +100 -exec rm -i {} ;
Synchronize "xxx-files" to "different-stuff/xxx-files" recursively preserving metadata with a bandwidth limit of 2000 KiB/s </s> rsync -pogtEtvr --progress --bwlimit=2000 xxx-files different-stuff
Select everything selected by * without descending into any directories </s> find * -maxdepth 0
Perform white space safe deletion of files named core under /tmp </s> find /tmp -name core -type f -print0 | xargs -0 /bin/rm -f
Find *.java files under current directory and compress them to myfile.tar </s> find . -type f -name "*.java" | xargs    tar rvf myfile.tar
Find regular files in the current directory that are writable by their owner </s> find -maxdepth 1 -type f -perm /200
Print the names of the directories from the paths expanded by the glob pattern /path/to/directory/* </s> find /path/to/directory/* -maxdepth 0 -type d -printf '%f\n'
display all scala files in the directory "src/main" </s> find . -path "*src/main*" -type f -iname "*\.scala*"
Archive "./htmlguide" to "~/src/" with resolved symbolic links and delete any extraneous files from "~/src/" not found in "./htmlguide" </s> rsync -av --copy-dirlinks --delete ../htmlguide ~/src/
Remove the "123_" prefix from all filenames of .txt files in current directory. </s> rename 's/^123_//' *.txt
Overwrites file 'filename' with random content 35 times, finally writes it with zeros, truncates and deletes. </s> shred -uzn 35 filename
Compress all *.img files using bzip2 </s> find ./ -name "*.img" -exec bzip2 -v {} \;
change group of the file /var/lib/php/session  to group lighttpd </s> chown -R :lighttpd /var/lib/php/session
recursively change owner and group of the directory  /opt/antoniod/ to user and group antoniod </s> chown -R antoniod:antoniod /opt/antoniod/
search for files which are writable by both their owner and their group </s> find . -perm -220
search for files which are writable by either their owner or their group </s> find . -perm /u+w,g+w
Check if the contents of file "subset" is a subset of file "set" </s> comm -23 <(sort subset | uniq) <(sort set | uniq) | head -1
Compare "file1" and "file2" line by line with 3 lines of unified context </s> diff -u file1 file2
Find all directories named "D" in the "A" directory tree </s> find A -type d -name 'D'
Find all executable upvoter-* files/symlinks under maximum 1 level down the {} directory </s> find {} -name 'upvoter-*' \( -type f -or -type l \) -maxdepth 1 -perm +111
Find files not matching the patterns 'Image*-70x70*' and 'Image*-100x100*' in their names under Folder1 and copy them to Folder2 </s> find Folder1 \( ! -name 'Image*-70x70*' -a ! -name 'Image*-100x100*' \) | xargs -i% cp -p % Folder2
Find and uncompress all files in the current directory tree ending in ".csv.gz" </s> find . -name '*.csv.gz' -exec gzip -d {} \;
Determine if /full/path exists on a mounted file system. </s> df /full/path | grep -q /full/path
Display the last colon-separated field of variable 'var' </s> echo "$var" | rev | cut -d: -f1 | rev
display all the files in the kat folder </s> find kat -printf "%f\n"
Compress files excluding *.Z files </s> find . \! -name "*.Z" -exec compress -f {} \;
replaces the last occurrence of 'a' with 'c' in file </s> tac file | sed '/a/ {s//c/; :loop; n; b loop}' | tac
Create intermediate directories as required and directory /tmp/test/blah/oops/something </s> mkdir -p /tmp/test/blah/oops/something
Find SGID files </s> find / -perm +2000
Find all the files in entire file system with the extensions txt or doc, as well as any file larger than 5MB in size </s> find / \( -name '*.txt' -o -name '*.doc' -o -size +5M \)
Get domain name with 'google' from address $1 </s> dig -x "$1" | grep PTR | cut -d ' ' -f 2 | grep google | cut -f 5
Execute "ls -l" every 0.5 seconds </s> watch -n 0.5 ls -l
Recursively copies everything from '/zzz/zzz/' to the '/xxx/xxx' overwriting the existing files and answering 'yes' on each request for overwriting. </s> yes | cp -rf /zzz/zzz/* /xxx/xxx
Mount "/dev/shm" using /etc/fstab entry </s> mount /dev/shm
Find all files/directories under current directory tree whose paths match the regex 'filename-regex.\*\.html' </s> find . -regex filename-regex.\*\.html
Finds users with X session in system and puts the result into USERS variable </s> USERS=$(awk '/\/X/ {print $1}' <(w))
Finds pattern text ignoring letter case in all .js files, prints matched strings and name of file with that strings. </s> find . -name '*.js' -exec grep -i 'string to search for' {} \; -print
Find all symbolic links under current directory that are not hard links </s> find . -type f -links 1 -print
Search /var/log for logs larger than 10 megabytes </s> find /var/log -size +10M -ls
Save the directory of the full path to the current script in variable "dir" </s> dir=$(dirname $(readlink -m $BASH_SOURCE))
Search the current directory tree for regular files that were modified $FTIME days ago </s> find . -type f -mtime $FTIME
Find all files under current directory with their size and paths, reverse sort them numerically, then print first 4 entries </s> find -type f -printf "%s %p\n" | sort -nr | head -n 4
Copy all files that match 'FooBar' in their paths under current directory tree to the '~/foo/bar' directory </s> find . | grep "FooBar" | tr \\n \\0 | xargs -0 -I{} cp "{}" ~/foo/bar
Print the current directory tree with the date of last modification for each file or directory </s> tree -D
find all the files that have been modified today(from the strart of the day) </s> find . -type f -daystart -mtime 0
Save all entries that are wrapped around with opening and closing square brackets in file 'FILENAME' to variable 'var' </s> var=`egrep -o '\[.*\]' FILENAME | tr -d ][`
Find all files under and below the current working directory with the word California in the file, and count the number of lines in the output </s> find . -type f -exec grep California {} \; -print | wc -l
Print summary of files present only in dir1. </s> diff -rq dir1 dir2 | grep 'Only in dir1/'
display all files in the entire file system </s> find /
Find all files/directories containing 'farm' in their names under '/usr/share' directory tree </s> find /usr/share -name '*farm*'
Print groups of all users logged in </s> groups $(who | cut -d' ' -f 1)
find all the files in the current folder that are modified after the modification date of a file </s> find . -newer document -print
search for a word in all the files in the current directory (case insensitive search) </s> find . -type f -exec grep 'needle' {} \;
Archive all filepattern-*2009* files/directories under data/ into 2009.tar </s> find data/ -name filepattern-*2009* -print0 | xargs -0 tar uf 2009.tar
Prompt user to type a list of cron jobs directly at the terminal, then use these replacing previously existing cron jobs. </s> crontab
Set 644 permission to all regular files under current directory </s> find . -type f -exec chmod 644 {} \;
Changes the group of defined file. </s> chgrp
display top 11 files along with the last access date for all the files in the file system </s> find / -type f -printf "\n%AD %AT %p" | head -n 11
Ungzip and untar all files matching "www-backup.tar.*" </s> cat www-backup.tar.*|gunzip -c |tar xvf -
Print all filenames under /proc and below </s> find /proc -print0 | xargs -0
Find and remove the .rhosts file in the /home directory tree </s> find /home -name .rhosts -print0 | xargs -0 rm
Remove leading and trailing spaces or tabs from "$string" </s> echo "$string" | sed -e 's/^[ \t]*//' | sed -e 's/[ \t]*$//'
Find all files/directores under '/usr/local' directory tree that case insensitively contain the word 'blast' in their names </s> find /usr/local -iname "*blast*"
Print a list of each file with the full path prefix in the current directory tree excluding symbolic links </s> tree -fi |grep -v \>
Print the last 10 commands in history </s> history | tail
display all files ending with ".ext" in current folder and append the file contents of list.txt and sort them based on name and display only uniq items </s> find . -name \*.ext | cat - list.txt | sort | uniq -u
List file contents of compressed file $i </s> gzip -l $i
Find <fileName> files/directories under current directory </s> find -name "<fileName>"
Find all directories named 'octave' under current directory tree </s> find . -name "octave" -type d
display all the files in the current folder which have been modified in the last 24 hours excluding all directories </s> find . \( -type d ! -name . -prune \) -o \( -mtime -1 -print \)
Find all files named 'Makefile' in the /usr/ports directory tree and count the number of lines in them matching regular expression '^MASTER_SITE_SUBDIR.*\.\./.*authors' </s> find /usr/ports/ -name Makefile -exec grep '^MASTER_SITE_SUBDIR.*\.\./.*authors' '{}' '+' | wc -l
Append the current date in '%d%m%Y-%H-%M' format, '_' and the current username, then save it in 'name' variable </s> name="$(date +'%d%m%Y-%H-%M')_$(whoami)"
Unzip and untar "file.tar.gz" </s> zcat file.tar.gz |tar x
Delete all .svn files/directories under current directory </s> find . -name .svn -exec rm -rf {} \;
Find all target files outside the current working directory with symbolic links in the current working directory </s> find . -type l -exec readlink -f '{}' \; | grep -v "^`readlink -f ${PWD}`"
Prints a random number between 2000 and 65000 </s> seq 2000 65000 | sort -R | head -n 1
Make directories for each line in "folder_list.txt" </s> cat folder_list.txt | xargs mkdir
Find all files/directories named 'java' under /usr directory </s> find /usr -name java
Change the permissions of every directory in the current directory and all files and directories within them to 700 </s> find . -maxdepth 1 -type d -exec chmod -R 700 {} \;
Print  "Cannot acquire lock - already locked by " followed by content of $lockfile file </s> echo "Cannot acquire lock - already locked by $(cat "$lockfile")"
Remove all *.bak files under current directory </s> find . -type f -name \*.bak -print0 | xargs -0 rm -v
Find all "YourProgramName" regular files in the current directory tree and print the full paths to the directories containing them </s> find . -type f -name YourProgramName -execdir pwd \;
create symbolic links in directory "/your/dest/dir/" to all files located in "/your/source/dir/" and have filename extension "txt.mrg" </s> find /your/source/dir/ -iname '*.txt.mrg' -exec ln -s '{}' /your/dest/dir/ \;
find the regular js files which path does not contains '*/test/*'  and name does not contains '*-min-*' or '*console*' </s> find . ! -path "*/test/*" -type f -name "*.js" ! -name "*-min-*" ! -name "*console*"
Recursively lists all files in a current folder in long format, sorting by modification time. </s> ls -ldt $(find .)
Find all files/directories under 'A' directory tree excluding directory 'A/a' and all of it's contents </s> find A \! -path "A/a/*" -a \! -path "A/a"
Write "error" to standard output </s> echo "error" | tee
Display each line in file.txt backwards </s> rev file.txt
Search for all zero-byte files and move them to the /tmp/zerobyte folder </s> find test -type f  -size 0 -exec mv {} /tmp/zerobyte \;
Gets IP address of 'eth0' network interface. </s> ifconfig eth0 | awk '/inet addr/{sub("addr:",""); print $2}'
search for the directory with the name aa in the current folder </s> find . -type d -name aa
Gets IP address of eth0 network interface. </s> ifconfig eth0 | grep addr: | awk '{ print $2 }' | cut -d: -f2
Save the FQDN host name of the system in variable "fhost" </s> fhost=`hostname -f`
Find files/directories writable by group and others under the /path directory </s> find /path -perm -022
Find all symbolic links starting from the current directory and list them </s> find . -type l -ls
Join lines in file "aa" with lines in file "bb" if the lines share a common first word and sort the result numerically </s> join <(sort aa) <(sort bb) | sort -k1,1n
Prints Kb size of all top-level files and folders in a current folder in descending order. </s> du -ks * | sort -n -r
Move all *.mp4 files from directory /foo/bar and its subdirectories to /some/path </s> find /foo/bar -name '*.mp4' -exec mv -t /some/path {} +
perform a case insensitive search </s> find  / -type d -iname "apt" -ls
Prints random line from file $FILE. </s> sort --random-sort $FILE | head -n 1
Add line numbers to each non-blank line in "file" starting with number 1000001 </s> nl -v1000001 file
Count the number of files named 'job.history' under '/data/SpoolIn' directory tree that match 'FAIL' in their contents </s> find /data/SpoolIn -name job.history -exec grep -l FAIL {} \; | wc -l
Search for all files in the current directory recursively whose names end with "Linkin Park" </s> find . -name "*Linkin Park"
Set the shell prompt to "host:pwd>" </s> PS1=`hostname`':\W> '
force delete all the regular files with the name "test.txt" </s> find /home -type f -name test.txt -exec rm -f {} \
Find all regular files starting from level 3 of directory tree ~/container and move them one level up </s> find ~/container  -mindepth 3 -type f  -execdir mv "{}" $(dirname "{}")/.. \;
Set the executable bit for all users on all regular files from directories arch/x86/usr/sbin, arch/x86/usr/X11R6/bin, usr/sbin/ </s> find arch/x86/usr/sbin arch/x86/usr/X11R6/bin usr/sbin/ -type f | xargs chmod a+x
Search the current directory tree for TXT files skipping hidden ones </s> find . -type f \( -iname "*.txt" ! -iname ".*" \)
SSH into "$NAME" as user "${USERNAME}" using key file "${KEYDIR}/${KEY}.pem", automatically add the host to list of known hosts and execute "${COMMANDS}" </s> ssh -o "StrictHostKeyChecking no" -i ${KEYDIR}/${KEY}.pem ${USERNAME}@$NAME "${COMMANDS}"
Archive "_vimrc" to "~/.vimrc" suppressing non-error messages and compressing data during transmission </s> rsync -aqz _vimrc ~/.vimrc
Print last 10 commands in history </s> history 10
Find all files under current directory that were modified in the last 24 hours and also include the files that were modified in less than 1 day ago </s> find -mtime +0
display all the empty files in current folder </s> find . -empty
Recursively copies '../include/gtest' directory to '~/usr/gtest/include/'. </s> cp -r ../include/gtest ~/usr/gtest/include/
Change to the directory containing the "oracle" executable </s> cd "$(dirname "$(which oracle)")"
find and image in current folder (case insensitive search) </s> find . -iname "Articles.jpg"
Compare the files in 'FOLDER1' and 'FOLDER2' and show which ones are indentical and which ones differ </s> find FOLDER1 -type f -print0 | xargs -0 -I % find FOLDER2 -type f -exec diff -qs --from-file="%" '{}' \+
List all regular files in the current directory tree modified within the last 24 hours </s> find . -mtime 0 -type f -ls
Find all the files in the current directory recursively whose permissions are not 777 </s> find . -type f ! -perm 777 | head
get the git user access </s> su git
Find all files/directories under current directory and sort them </s> find | sort
displays all the files in the current folder </s> find .
Find all regular files under $DIR directory tree with ".$TYPE" extension (case insensitive) where $TYPE expands in the current shell </s> find $DIR -type f -iname "*.$TYPE"
find ".flac" files in current folder using regular expressions </s> find ./ -regex "./cmn-.\.flac"
Create intermediate directories "tmp" as required and directories real_dir1 and real_dir2 </s> mkdir -p tmp/real_dir1 tmp/real_dir2
find all the files within your home folder accessed more than 100 days ago </s> find ~ -atime 100
display all the regular/normal files in a folder </s> find $FILES_PATH -type f
Search all .java files residing in the current directory tree and modified at least 7 days ago for string "swt" </s> find . -name '*.java' -mtime +7 -print0 | xargs -0 grep 'swt'
list regular files under the current directory </s> find . -type f
Search the current working directory tree for files whose names start with "fileA_" or "fileB_" </s> find . -name 'fileA_*' -o -name 'fileB_*'
Move all files in the current directory tree that match "some_pattern" to "target_location" </s> find . -name some_pattern -print0 | xargs -0 -I % mv % target_location
Print all unique strings in $1.tmp file. </s> cat $1.tmp | sort -u
Removes all empty folders that ends with any-cased '*.bak' under '/Users/' path. </s> find /Users -type d -iname '*.bak' -print0 | xargs -0 rmdir
Print the sorted uniqe list of folders in compressed archive nginx-1.0.0.tar.gz </s> tar tf nginx-1.0.0.tar.gz | xargs dirname | sort | uniq
Print "hello" followed by the current user name </s> echo hello `whoami`
Change file owner and group of "/path/to/yourapp" to root and print a diagnostic </s> chown -v root:root /path/to/yourapp
Execute "ls -l data.temp" every 2 seconds </s> watch ls -l data.temp
Find all *.txt files/directories under current directory </s> find . -name '*.txt'
Move all directories from the `sourceDir' directory tree to the `destDir' directory </s> find sourceDir -mindepth 1 -type d  -print0 | xargs -0 mv --target-directory=destDir
Find all executable symlinks or upvoter-* files under maximum 1 level down the {} directory </s> find {} -name 'upvoter-*' -type f -or \( -type l \) -maxdepth 1 -perm +111
Search for all files in the /home directory tree that have the same inode number </s> find /home -xdev -inum 2655341
Search for the wp-config.php file in /var/www and one level below </s> find /var/www/ -name wp-config.php -maxdepth 2
Print the difference between line 2 and 3 in file "$f" </s> diff <(fold -w1 <(sed '2q;d' $f)) <(fold -w1 <(sed '3q;d' $f)) | awk '/[<>]/{printf $2}'
Read a line from standard input with prompt "Enter your choice: ", arrow keys enabled, and "yes" as the default input, and save the response to variable "choice" </s> read -e -i "yes" -p "Enter your choice: " choice
Check if process ID 1 exists (init or systemd) and current user has permission to send it signals. </s> kill -0 1
Search the current user's home directory and its sub-directories for any file that was modified less than 2 days ago or was modified after filename was last modified. </s> find ~/ -mtime -2 -o -newer filename
Find all regular files under $DIR directory tree whose paths match the regex ".*\.${TYPES_RE}" where ${TYPES_RE} expands as a variable </s> find ${DIR} -type f -regex ".*\.${TYPES_RE}"
Print the ping time of a single request to "8.8.8.8" </s> ping -c 1 8.8.8.8 |  awk 'FNR == 2 { print $(NF-1) }'
Print all files in the current directory tree as a comma separated list </s> find . -type f -print0 | tr '\0' ','
find all the ".sh" files in the current folder ( case insensitive search) </s> find -iname *.SH
Archive "blanktest/" to "test/" deleting any files in the destination not found in the source </s> rsync -a --delete blanktest/ test/
Find recursively the latest modified file in the current directory </s> find . -type f | sed 's/.*/"&"/' | xargs ls -E | awk '{ print $6," ",$7," ",$9 }' | sort | tail -1
find all the files that are modified in the last 7 days </s> find -daystart -mtime -7
Print the path to the pipe created for process substitution </s> echo <(true)
Executes 'cd /' in a subshell created by a pipeline of built-in function 'true'. </s> true | cd /
Remove sequence like '\xEF\xBB\xBF' from first string of every '*.js' file in a current folder and subfolders, creating backup file with .bak extension for every changed file, and removing backup on success. </s> find . -iname *.js -type f -exec sed 's/^\xEF\xBB\xBF//' -i.bak {} \; -exec rm {}.bak \;
Output the file name "file.txt' from the path "some/unknown/amount/of/sub/folder/file.txt" </s> basename "some/unknown/amount/of/sub/folder/file.txt"
Find all files whose names end with "~" in the /home/peter directory tree, following symlinks, and delete them </s> find -L /home/peter -name *~ |xargs rm
Start 'top' to monitor all processes with the default settings. </s> top
display all files in the current folder which are not empty </s> find . ! -size 0k
find all the normal/regular files in the current folder which have been modified two days ago and display a long listing of them </s> find . -type f -mtime 2 -mtime -3 -daystart -exec ls -l {} \;
Delete all regular files under current directory </s> find . -type f -print0 | xargs -0 /bin/rm
Find all .rb and .yml files in the /some/path directory tree and replace "some_phrase" with "replacement_phrase" in them </s> find /some/path -name "*rb" -o -name "*yml" | xargs grep -sl "some_phrase" | xargs sed -i -e 's/some_phrase/replacement_phrase/g'
List all regular files from the current directory tree that were modified less than 60 days ago </s> find -type f -mtime -60
Disables shell option 'nocasematch'. </s> shopt -u nocasematch
Find files/directories that does not have write permssion for group or others </s> find /path ! -perm -022
Find all test.txt files/directories under current directory </s> find . -name test.txt
Save full path of command "rm" to variable "RM" </s> RM=`which rm`
Find all empty directories in the current one and delete them </s> find . -type d -maxdepth 1 -empty -print0 | xargs -0 /bin/rmdir
Set the host name to "myServersHostname" </s> hostname myServersHostname
Recursively copies /mnt/usr/lib to the '/usr/' directory, creating symbolic links on each file instead of real copying them. </s> cp -rs /mnt/usr/lib /usr/
Find files with group write permission and remove the permission </s> find . -perm -20 -print | xargs chmod g-w
Find the passwd file under root and one level down. </s> find -maxdepth 2 -name passwd
Find all *.log files under current directory that contain the string "Exception" </s> find . -name '*.log' -mtime -2 -exec grep -Hc Exception {} \; | grep -v :0$
search for a files "cart1" in the folder junk which is in home folder and move the folder to ~/junk/A. </s> find ~/junk  -name 'cart1' -exec mv {} ~/junk/A \;
Find the empty directories and files under current directory </s> find -empty
Find all the Sticky Bit set files whose permission are 551 in the file system </s> find / -perm 1551
find all files in current folder which are more than 300MB </s> find . -size +300M
Find all the regular files in $DIR directory tree which have not been modified in the last 15 days and delete them </s> find "$DIR" -type f -mtime +15 -exec rm {} \;
find all the directories with the name "some-dir" in the current folder and move them to another folder and do not search in subfolders </s> find ./ -maxdepth 1 -name "some-dir" -type d -print0 | xargs -0r mv -t x/
Search for 'some string' in all *js files under current directory and show the matched lines with line numbers </s> find . -name '*js' -exec grep -n 'some string' {} \;
list *.pdf files under the /home/user/Desktop directory. </s> find /home/user/Desktop -name '*.pdf'
Find all directories under '.cache/chromium/Default/Cache' that are bigger than 100 MB in size excluding single letter directory names </s> find .cache/chromium/Default/Cache/ -type d -print0 | du -h | grep '[0-9]\{3\}M' | cut -f2 | grep -v '^.$'
Search for first match of the case insensitive regex 'oyss' in all *.txt files under current directory and print the file paths along with the matches </s> find . -name '*.txt'|xargs grep -m1 -ri 'oyss'
display all the files in the current folder excluding those which are in the path of ".git" </s> find . ! -path  "*.git*" -type f -print
find all the text files in the home folder </s> find ~ -name "*.txt" — print
change the directory to the last found folder in the directory 'a' </s> cd `find a |sed '$!d'`
Calculate md5 sum of file $ecriv </s> md5sum "$ecriv"
Reads content of bzip2 compressed files and processes it with awk utility. </s> bzip2 -dc input1.vcf.bz2 input2.vcf.bz2 | awk 'FNR==NR { array[$1,$2]=$8; next } ($1,$2) in array { print $0 ";" array[$1,$2] }'
Removes all files from current folder but 5 newest ones. </s> ls -tr | head -n -5 | xargs rm
Find executable files </s> find . -perm -100 -print
create directory aaa </s> mkdir aaa
Display what flags mount points are mounted with </s> mount -l
Find the first file/directory named 'something' under current directory and quit </s> find . -name something -print -quit
Find a hostname that resolves to IP '173.194.33.71' </s> dig +short -x 173.194.33.71
Search the current directory tree for regular files whose names match pattern $x </s> find . -type f -name $x
display all the files in the folder /home which do not belong to the group test </s> find /home ! -group test
replace the word foo to bar in the current folder in all the regular/normal files which have execute permission  (does not update the file) </s> find . -type f -executable -exec sed -i 's/foo/bar/g' {} +
Search recursively through /mydir, outputting only the base (leaf) name of each file, directory, symlink etc. without any containing directories, that is the part following the last slash. </s> find /mydir | xargs -I{} basename {}
Find all *.java files under current directory and archive them to myfile.tar </s> find . -type f -name "*.java" | xargs tar rvf myfile.tar
Search the specified group for the given "filename </s> find / -group users -iname "filename"
Search the current directory tree for regular files omitting directory `omit-directory' </s> find . \( -name omit-directory -prune -o -type f \) -print
Print lines of 'file' reverted order, and reverted characterwise </s> tac file | rev
Decompress and extract 'libxml2-sources-2.7.7.tar.gz' </s> gzip -dc libxml2-sources-2.7.7.tar.gz | tar xvf -
Make directory "new_dir" </s> mkdir new_dir
search for a word in all the files in the current directory and display the list of matched files. </s> find . -type f -exec grep -l 'needle' {} \;
Look for *log files in directories at least three levels down the directory tree </s> find / -mindepth 3  -name "*log"
find all the perl files in the current folder and search for a pattern </s> find . -name '*.pl' | xargs grep -L '^use strict'
Archive "/media/Incoming/music/" to "/media/10001/music/" on host "server" and skip files that are newer in the destination, delete any files in the destination not in the source, and compress data during transmission </s> rsync -avzru --delete-excluded /media/Incoming/music/ server:/media/10001/music/
find all files in the file system which belong to the group users and having the word "filename" in their name. </s> find / -group users -iname "filename"
Print "$PATH" variable as input to awk script "rem_dup.awk" and concatenate the result with ":" </s> echo $PATH | awk -F: -f rem_dup.awk | paste -sd:
Make directories in "/TARGET_FOLDER_ROOT/" for each ".mov" file in the current directory tree </s> find . -type f -iname \*.mov -printf '%h\n' | sort | uniq | xargs -n 1 -d '\n' -I '{}' mkdir -vp "/TARGET_FOLDER_ROOT/{}"
Calculate md5 checksum of $line and save to variable 'md5' </s> md5=$(echo "$line"|md5sum)
Query SRV records for domain '_kerberos._udp.foo.com' </s> dig -t SRV _kerberos._udp.foo.com
Copy "some_file_name" to "destination_directory" and change ownership to "someuser:somegroup" </s> echo 'some_file_name' | cpio -p --owner someuser:somegroup destination_directory
Search the current directory recursively for text files containing at least one character </s> find . -type f -exec grep -Iq . {} \; -and -print
Find recursively all Emacs backup files in the current directory and remove them </s> find . -name '*~' | xargs rm
List all files/folders in current directory by separating them with spaces </s> ls | tr  "\n" " "
Remove all .txt files in and below the current directory </s> find . -name "*.txt" -exec rm {} +
Find all regular non-hidden files in the current directory and its subdirectories </s> find . -not -path '*/\.*' -type f \( ! -iname ".*" \)
Set permissions to ug=rw,o= for files inside the ./default/files tree </s> find ./default/files -type f -exec chmod ug=rw,o= '{}' \;
Save a list of all 755 permission files/directories under $dir directory tree to the variable 'files' </s> files="$(find $dir -perm 755)"
Merge content of decompressed files "$part0", "$part1", and so on </s> sort -m <(zcat $part0 | sort) <(zcat $part1 | sort) ...
Print the first two bytes of "my_driver" in octal </s> od --read-bytes=2 my_driver
Prints week day of a 31 day in a current month. </s> cal | awk 'NR==2 {split($0,a)} {for (i=1;i<=NF;i++) if ($i==date) print a[i]}' FIELDWIDTHS="3 3 3 3 3 3 3 3" date=31
Find all the SGID bit files whose permissions set to 644 </s> find / -perm 2644
Print the first word followed by the rest of the line formatted to fit in 100 characters for every line in "input" </s> sed 's/\([^ ]*\) /\1\n/' input | fold -w 100
remove all the regular/normal files in the temp folder and do not delete in the sub folders </s> find /tmp -maxdepth 1 -type f -delete
Create symlinks to all  /home/folder1/*.txt files with the same name in current directory </s> find /home/folder1/*.txt -type f -exec ln -s {} \;
Prefix all files and folders in the current directory with "PRE_" </s> find * -maxdepth 0 ! -path . -exec mv {} PRE_{} \;
Search the current directory recursively for regular files last accessed 2 minutes ago </s> find . type -f -amin 2
Report file system containing /tmp disk usage in kilobytes. </s> df -k /tmp
Sort file "a.csv" by the first comma separated value of each line and print only unique entries </s> tac a.csv | sort -u -t, -r -k1,1 |tac
Find all files/directories ignoring *~ files/directories without descending into .snapshot directory with null character as the delimiter </s> find . -name .snapshot -prune -o \( \! -name *~ -print0 \)
Send reverse requests to get domain name for each address in 'my_ips' list </s> cat my_ips | xargs -i dig -x {} +short
Replace any blank character from standard input with a tab </s> tr '[:blank:]' \\t
Run an awk program on every TXT file found in the current directory tree </s> find . -name "*.txt" -print -exec awk '$9 != "" && n < 10 {print; n++}' {} \;
create directory foo </s> mkdir -p foo
Forward port 8000 bound on localhost to port 22 in 'clusternode' via 'user@bridge' </s> ssh -L localhost:8000:clusternode:22 user@bridge
find all the files in current directory of size exactly 6MB. </s> find . -size 6M
find all the files in the current folder which have the word cache in them and do not search in the sub directories of the folder. </s> find . -name 'cache*' -depth -exec rm {} \;
Replace all instances of "STRING_TO_REPLACE" with "STRING_TO_REPLACE_IT" in "index.html" </s> sed -i 's/STRING_TO_REPLACE/STRING_TO_REPLACE_IT/g' index.html
Search the current directory tree for all regular non-hidden files except *.o </s> find ./ -type f -name "*" -not -name "*.o"
find files in current folder ending with ".c" or ".h" or ".ch" and search for a word in these files and enable color highlighting of the matched text </s> find . -name "*.[ch]" -exec grep --color -aHn "e" {} \;
Find recursively the files named "file" in the current directory ignoring the .git subdirectory </s> find . -path ./.git  -prune -o -name file  -print
Find all files under maximum 1 level down the ./subfolder and ./subfolder/*/  paths </s> find ./subfolder ./subfolder/*/ -maxdepth 1 -type f
find all the regular/normal files in the current folder and replace everything expect the extension of the file and display unique file extensions </s> find . -type f | sed -e 's#.*\(\.[a-zA-Z]*\)$#\1#' | sort | uniq
Opens gcc info manual and goes to a node pointed by index entry "funroll-loops". </s> info gcc --index-search=funroll-loops
Find files/directories with inode number '212042' under '/var' directory tree without traversing other devices/partitions </s> find -x /var -inum 212042
Recursively copy directory or file /something on host "myServer" to current directory on local host, connecting as ssh user matching username on local host. </s> scp -r myServer:/something
search for regular/normal file with the name "myfile" in the entire file system </s> find / -name myfile -type f -print
split content of the file file.txt started from second line into pieces per 4 lines named as split_NNN </s> tail -n +2 file.txt | split -l 4 - split_
List all files under and below the directory given as variable $FULFILLMENT </s> find $FULFILLMENT -ls
find the file with the name "esxcfg-firewall" in the current folder </s> find -print | grep esxcfg-firewall
Prints last modified file in a current folder with modification time. </s> find . -type f -printf '%TY-%Tm-%Td %TH:%TM: %Tz %p\n'| sort -n | tail -n1
List all files under the current working directory with name ".htaccess" </s> find `pwd` -name .htaccess
Check all .txt files whether they contain "needle" </s> find . -type f -iname "*.txt" -print | xargs grep "needle"
Print lines in the sorted contents of "a.txt" that are not in the sorted contents of "b.txt" </s> comm -23 <(sort a.txt) <(sort b.txt)
Find directories starting from /TBD that were modified more than 1 day ago </s> find /TBD -mtime +1 -type d
Remove all *.txt files, except robots.txt, under the given directory modified more than 5 minutes ago </s> find /home/u20806/public_html -maxdepth 1 -mmin +5 -type f -name "*.txt" ! -name "robots.txt" -delete
Print "huge-file.log" starting at line 1000001 </s> tail -n +1000001 huge-file.log
List empty directories in the current directory tree </s> find . -depth -empty -type d
Remove files that are less than 1MB in size under current directory </s> find . -size -1M -exec rm {} \;
Print numbers from 1 to the number in variable "$1" </s> seq $1
Saves list of currently logged in users in 'userlist' variable. </s> userlist=$(w|awk 'BEGIN{ORS=","}NR>2{print $1}'|sed 's/,$//' )
Send SIGHUP (hangup) signal to nginx master process, causing it to re-read its configuration and restart child processes if necessary. </s> kill -HUP $( cat /var/run/nginx.pid )
Find files and directories newer than CompareFile under current directory </s> find . -newer CompareFile -print
Print a single line of numbers from "001" to "100" </s> yes | head -n 100 | awk '{printf( "%03d ", NR )}'
Counts lines in file $file ignoring '//' commented lines, lines with spaces only and empty lines. </s> cat $file | sed '/\/\//d' | sed '/^\s*$/d' | wc -l
Backup all PHP files under the current directory tree </s> find -name "*.php" –exec cp {} {}.bak \;
Display infinite scroll of random ASCII art </s> yes 'printf \\u$[2571+RANDOM%2]'|bash
find files in home directory which are modified yesterday </s> find ~/ -daystart -type f -mtime 1
Search for "LOG" in jsmith's home directory tree </s> find ~jsmith -exec grep LOG '{}' /dev/null \; -print
Remove all .txt files from the /full/path/dir directory tree </s> find /full/path/dir -name '*.txt' -exec /bin/rm {} \;
Counts lines in file $file and prints number only. </s> wc -l $file | awk '{print $1}';
Find all files of the user with UID=1000 </s> find -uid 1000
display all the directories in the current folder which are atleast one level deep </s> find . -mindepth 1 -type d -print0
Change permissions to 644 for all files in the current directory tree </s> find . -type f | xargs chmod -v 644
Find all your text files and page through them </s> find . -name "*.txt" -print | less
Print the sorted unique column of usernames of users who are currently logged in without the header </s> finger | cut -d ' ' -f1 | sort -u | grep -iv login
Convert all characters in "$a" to upper case and save to variable "b" </s> b=`echo "$a" | sed 's/./\U&/g'`
Search for all files with the same inode number 41525360 </s> find . -follow -inum 41525360
create directories a b c d e </s> mkdir a b c d e
Execute `echo' for each file found </s> find . | xargs -n 1 echo
Delete all directories under '.cache/chromium/Default/Cache/' directory tree that are bigger than 100MB and are at least 1 level deep </s> find .cache/chromium/Default/Cache/ -mindepth 1 -type d -size +100M -exec rm -rf {} \;
Find all directories and for each of them, print an mv command to move it to /new/location </s> find . -type d   -execdir echo /bin/mv {} /new/location \;
long list al the files in the current directory which have only read permission to the group </s> find . -perm 040 -type f -exec ls -l {} \;
Delete all hidden files under $some_directory </s> find "$some_directory" -type f -name '.*' | xargs rm
Grab a gzipped text file from the web and display its decompressed content, interactively paging through the output. </s> curl -s 'http://archive.ubuntu.com/ubuntu/pool/universe/s/splint/splint_3.1.2.dfsg1-2.diff.gz' | gunzip -dc | less
search for the word foo in all the js files in the current folder </s> grep -iH foo `find . -name "*.js"`
find all the text files that have modified in the last 2 days and not modified today </s> find . -name "*.txt" -type f -daystart -mtime +0 -mtime -2
Display environment variable "_" of the current shell </s> set | grep "^_="
List all directories under current directory </s> find . -type d -exec ls -dlrt {} \;
prints the last occurrence of text between two tags </s> tac file | sed -n '0,/<tag>\(.*\)<\/tag>/s//\1/p'
List files in the current directory and below </s> find -ls
Retrieve only build number of current kernel, ie. #104 </s> uname -v | grep -o '#[0-9]\+'
Find all 777 permission regular files and use chmod command to set permissions to 644 </s> find / -type f -perm 0777 -print -exec chmod 644 {} \;
Find all files/directories under current directory tree that are owned by 'root' </s> find . -uid 0 -print
Find all regular .abc files under and below /the/path and rename them prefixing their names with "version_1" </s> find /the/path -type f -name '*.abc' -execdir rename 's/\.\/(.+)\.abc$/version1_$1.abc/' {} \;
Find all files/directories under current directory with 'FooBar' in their paths and copy them to ~/foo/bar </s> find . | grep FooBar | xargs -I{} cp {} ~/foo/bar
Find root's Ruby files accessed in the last two minutes </s> find /apps/ -user root -type f -amin -2 -name *.rb
Force create a symbolic link in "/usr/bin/" for each file matching "$javaUsrLib/jdk1*/bin/*" </s> sudo ln -f -s $javaUsrLib/jdk1*/bin/* /usr/bin/
Search the `images' directory tree for regular files </s> find images/ -type f
display all the empty files in the folder /opt (file size 0 bytes) </s> find /opt -type f -empty
Find all *FooBar* files/directories under current directory and copy them to ~/foo/bar </s> find -name '*FooBar*' -print0 | xargs -0 cp -t ~/foo/bar
display all the files only in the path "./sr*sc" </s> find . -path "./sr*sc"
Recursively copies all files in the current directory but ones that names match pattern "dirToExclude|targetDir" to the 'targetDir' directory, printing info message on each operation. </s> cp -rv `ls -A | grep -vE "dirToExclude|targetDir"` targetDir
Copy a file xyz.c to all the directories below the current one whose names begin with "temp" </s> find . -type d -name "temp*" | xargs -n1 cp xyz.c
Print the list of regular files from the current directory tree that were modified less than 2 days ago </s> find . -type f -mtime -2 -exec echo {} +
find all the video files in the home folder </s> find ~ -type f -exec file -i {} + | grep video
display all the regular/normal files in the current folder which are modified after a file </s> find . -type f -newer "$FILE"
Delete all files in the current directory tree whose names end with ~ </s> find . -name "*~" -exec rm {} \;
Verbosely compresses all files on fourth and fifth depth level keeping original files in place. </s> bzip2 -kv */*/*/*/*
Print the names of all files and directories in the current directory tree </s> find .
Take a file path from standard input and remove it. </s> xargs -I '{}' rm '{}'
Recursively copy "emptydir" to "destination/newdir" </s> rsync --recursive emptydir/ destination/newdir
Gets IP address of 'en1' network interface. </s> ifconfig en1 | sed -n '/inet addr/s/.*addr.\([^ ]*\) .*/\1/p'
Find all files in the /var/tmp directory tree with uid=1000 </s> find /var/tmp -uid 1000
display all jpg files in the current folder </s> find -iname "*.jpg"
Uncompress and unarchive "data.tar.gz" </s> gzip -dc data.tar.gz | tar -xvf -
Print the names of the directories from the paths expanded by the glob pattern /path/to/directory/* </s> find /path/to/directory/* -maxdepth 0 -type d -exec basename -a {} +
Create a symbolic link named "$tmpdir/bam" to the full path of command "bam2" found in "$PATH" </s> ln -s "$(which bam2)" "$tmpdir"/bam
Print all user names and terminals of users who are logged in </s> who | cut -d " " -f1,2
Archive current directory to "/some/path" on localhost, using ssh to authentify as user "me", only update files that are newer in the source directory. </s> rsync -auve "ssh -p 2222" . me@localhost:/some/path
Print DISPLAY of "orschiro" user </s> who | sed -e '/orschiro/! d; /pts/! d; s/^.*\(:[0-9.]\+\).*$/\1/p;d' | head -n1
Set the executable bit for all users on all .sh scripts from directory trees lib, etc, debian </s> find lib etc debian -name "*.sh" -type f | xargs chmod +x
find all files in the current folder and search for a word in them. </s> find . -type f -exec grep "applicationX" {} \;
Find file names *blast* in specfied directory, case insensitive </s> find /usr/local -iname "*blast*"
Find broken links </s> find / -type l -print0 | xargs -0 file | grep broken
Delete all regular files that reside in directory $OUTPUTDIR and below, and were last modified more than 7 days ago </s> find $OUTPUTDIR -type f -mtime +7 -delete
Find all file which have more the 2 hard link </s> find .  -type f -links +2 -exec ls -lrt {} \;
Change every file under "/var/www/html/" to have permissions 664 </s> sudo  find /var/www/html/ -type f -exec chmod 664 {} \;
change the permissions of all the directories in the folder "/path/to/someDirectory" to 755 </s> sudo find /path/to/someDirectory -type d -print0 | xargs -0 sudo chmod 755
Find all files that are exactly 50 bytes </s> find / -size 50c
change the group to "new_group" and permissions to 770 for all the files in the current folder </s> find . -name "*" \( -exec chgrp -v new_group {} \; -o -exec chmod -v 770 {} \; \)
Prints date of first Tuesday in January, 2015 </s> cal 01 2015 | sed -n '1,2b;/^.\{6\} \{0,1\}\([0-9]\{1,2\}\) .*/ {s//0\1/;s/.*\([0-9]\{2\}\)$/\1/p;q;}'
Copy all directories recursively from "source/" to "destination/" excluding all files </s> rsync -a --include='*/' --exclude='*' source/ destination/
Remove all .txt files from the /full/path/dir directory tree </s> find /full/path/dir -name '*.txt' -print0 | xargs -0 rm
Counts non-empty lines in file fileName. </s> cat fileName | grep -v ^$ | wc -l
Create intermediate directories as required directory{1..3} and subdirectory{1..3} and directories subsubdirectory1 and subsubdirectory2 </s> mkdir -p directory{1..3}/subdirectory{1..3}/subsubdirectory{1..2}
Recursively change the owner to "${JBOSS_USER}" of "$JBOSS_LOG_DIR" </s> chown -R ${JBOSS_USER}: $JBOSS_LOG_DIR
Find directories that are directly under $workspace_ts directory (no-subdirectories) and were modified less than 30 days ago </s> find $workspace_ts -mindepth 1 -maxdepth 1 -type d -mtime -30
Gets MAC address of eth0 network interface. </s> ifconfig eth0 | grep -Eoi [:0-9A-F:]{2}\(\:[:0-9A-F:]{2}\){5}
Find and print the names of all files found in the current directory and all of its sub-directories </s> find . -print
Search the current directory tree for regular files whose names end in ".shtml" or ".css" </s> find -type f -regex ".*/.*\.\(shtml\|css\)"
Search directory tree `MyApp.app' for directories whose name is 'Headers' and delete them </s> find MyApp.app -name Headers -type d -exec rm -rf "{}" \;
Save the short system host name to variable "hostname" </s> hostname=`hostname -s`
Remove files matching pattern '*-*x*.*' from the current directory tree </s> find  -name '*-*x*.*' | xargs rm -f
Delete all files (files, directories, links, pipes...) named 'core' under current directory </s> find . -name "core" -exec rm -f {} \;
Print all directories under $root appending a : (colon) at the end of each path without descending into directories matching the pattern .[a-z]* </s> find "$root" -name ".[a-z]*" -prune -o -type d -printf '%p:'
Print file information of command "bash" </s> echo $(ls -l $(which bash))
Save the full path of command "oracle" to variable "path" </s> path=`which oracle`
Find all files under /home that belong to user tecmint </s> find /home -user tecmint
Find regular files under '/somefolder' directory tree satisfying the options/conditions/operations provided in ${ARGS[@]} array with find command </s> find /somefolder -type f '(' "${ARGS[@]}" ')'
Print login name and full name of all users currently logged in </s> finger -l | awk '/^Login/'
Finds more than 5 days old files in two directories  and compresses them. </s> find /home/folder1 /home/folder2 -type f -mtime +5 -exec compress {} \;
print number of jobs </s> n_jobs=$( jobs -p | awk '{print NR}' )
Delete all files/directories named 'FILE-TO-FIND' under current directory tree </s> find . -name "FILE-TO-FIND" -exec rm -rf {} \;
Search the system for files whose names begin with letters 'a', 'b', or 'c' </s> find  / -name '[a-c]*'
Find all regular files under $dir </s> find $dir -type f
Write "foo" to the real path of the current command's standard output </s> echo foo | readlink /proc/self/fd/0
Find all files/directories with case insensitive name pattern $TARGET that are located in minimum 10 level down the current directory </s> find -mindepth 10 -iname $TARGET
Kill all processes matching the string "myProcessName" </s> ps -ef | grep myProcessName | grep -v grep | awk '{print $2}' | xargs kill -9
find all the files in the /usr folder that have been modified after the file /usr/FirstFile. </s> find /usr -newer /usr/FirstFile -print
list regular files under the user's home directory that are over 100KB and have not been accessed in over 30 days. </s> find $HOME -type f -atime +30 -size 100k
Find all foo.mp4 files in the current directory tree and print the pathnames of their parent directories </s> find ./ -name "foo.mp4" -printf "%h\n"
List the unique file extensions of all files under the current directory </s> find . -type f | grep -o -E '\.[^\.]+$' | sort -u
Find and delete all hard links in the /home directory tree to file1 </s> find /home -xdev -samefile file1 | xargs rm
Reverse the text in $input by taking each 4 characters as each units and save the result in variable 'output' </s> output=$(echo $input | fold -w4 | tac | tr -d \\n)
Print the contents of "filename" </s> cat filename
Counts the number of lines in *.php and *.inc files in a current folder and subfolders. </s> find . -name '*.php' -o -name '*.inc' | xargs wc -l
Find all *.txt (case insensitive) files of user root under / directory and show a few lines of output from the beginning </s> find / -user root -iname "*.txt" | head
Report file system containing the current directory disk usage in kilobytes. </s> df -k .
Find all files under and below the current working directory with the word California in the file </s> find . -type f -exec grep California {} \; -print
display all the files in the entire file system </s> find / -type f -exec echo {} \;
find  symbolic link file that name match  '*sysdep.c' </s> find . -lname '*sysdep.c'
Find all pdf files excluding *_signed.pdf files under /some/dir with null character as the delimiter </s> find /some/dir -name "*.pdf" ! -name "*_signed.pdf" -print0
find all the normal/regular files in the current folder which are present in the pattern file "file_list.txt" </s> find . type f -print | fgrep -f file_list.txt
Print pathname of a file that is connected to the standard output of the command "yes" </s> echo <(yes)
List all directories found in the current directory and below. </s> find . -type d
Find any files in the current directory and its sub-directories that were last accessed more than 7 days and are larger than 20480 blocks in size. </s> find . -atime +7 -size +20480 -print
Find all files/directories under current directory tree that belong to user 'john' </s> find . -user john
Find files under current directory that contains the string '/bin/ksh' </s> find . -type f -exec grep -iH '/bin/ksh' {} \;
Find all *.ogg and *.mp3 (case insensitive) files/directories under your home directory </s> find $HOME -iname '*.ogg' -o -iname '*.mp3'
Merge the first "$lc" lines of "current.txt" and the last "$lc" lines of "current.txt" and display the result as a comma separated table </s> paste <(head -"$lc" current.txt) <(tail -"$lc" current.txt) | column -t -o,
Creates temporary folder in /tmp/ (by default) with 10-letter suffux. </s> mktemp -d -t
find all the files that are modified in the last 1 day </s> find -mtime +0 -mtime -1
Archive preserving permissions and ownership files in "/var/www/" on host "user@10.1.1.2" to local "/var/www/" </s> sudo rsync -az user@10.1.1.2:/var/www/ /var/www/
Check that the master SSH control socket "my-ctrl-socket" to "jm@sampledomain.com" is running </s> ssh -S my-ctrl-socket -O check jm@sampledomain.com
Perform case-insensitive search for file `TeSt123.txt' on the system </s> find / -iname TeSt123.txt
Find all *.py files under current directory and search for regular expressions taken from the search_terms.txt file </s> find . -name '*.py' -exec grep -n -f search_terms.txt '{}' \;
Search the current directory tree for regular files whose names end with "keep.${SUFFIX}", where $SUFFIX is a shell variable </s> find . -type f -name "*keep.${SUFFIX}"
Mount the "vboxsf" filesystem "myFileName" on "~/destination" </s> sudo mount -t vboxsf myFileName ~/destination
Find directories named `doc' in /usr and below </s> find /usr -name doc -type d
Split the sorted and unique lines in files "emails_*.txt" into files with at most 200 lines each with numeric suffixes of length 4 </s> sort --unique emails_*.txt | split --numeric-suffixes --lines=200 --suffix-length=4 --verbose
Search for a line starting with 'use strict' in all files with '.pl' extension under current directory tree and show the unmatched files only </s> find . -name '*.pl' | xargs grep -L '^use strict'
SSH into "hostname" on port 22 as user "myName" </s> ssh -p 22 myName@hostname
delete recursively, without prompting, any files or directories under the current directory that case insensitively match the filename ".svn" </s> find . -iname .svn -print | xargs rm -rf
Prints only first ten characters of each string of file $file. </s> cat $file | cut -c 1-10
Convert "595a" into characters and then print the hexadecimal and printable characters of each byte </s> echo 595a | awk -niord '$0=chr("0x"RT)' RS=.. ORS= | od -tx1c
Find files that match the executable bit for owner or group </s> find -type f -perm /110
Split "infile" into 2 files of about equal size </s> split -n2 infile
Create a symbolic link in the current directory for each .jpg file under "dir" </s> ln -s "$(find dir -name '*.jpg')" .
change the permission of all php files in current folder </s> find . -name "*.php" -exec chmod 755 {} \;
Append "& Bytes" to the end of every line in "$TEMPFILE" and format the result as a table </s> sed 's/.*/& Bytes/' "$TEMPFILE" | column -t
List the drive of each "/dev/" disk mount point </s> mount | grep '^/dev/' | sed -E 's/([^ ]*) on ([^ ]*) .*/"\2" is located on "\1"/'
Find all regular files under '/usr/bin' directory tree that are less than 50 bytes in size </s> find /usr/bin -type f -size -50c
Format space separated fields in "filename" as a table </s> column -t -s' ' filename
Print common characters in variable "$a" and "$b" </s> comm -12 <(echo $a|awk -F"\0" '{for (i=1; i<=NF; i++) print $i}') <(echo $b|awk -F"\0" '{for (i=1; i<=NF; i++) print $i}')|tr -d '\n'
Find the top 5 biggest files </s> find . -type f -exec ls -s {} \; | sort -n -r | head -5
display all the c files and the header files in the path /some/dir and do not search in sub directories </s> find /some/dir -maxdepth 1 \( -name '*.c' -o -name '*.h' \) -print
Copy the standard output of a "bash" session to "/var/log/bash.out.log" </s> bash | tee /var/log/bash.out.log
Exit the shell immediately if an error is encountered, treat references to unset variables as errors, disable overwriting existing files, and use the first non-zero exit code of a set of piped commands as the exit code of the full set of commands </s> set -o errexit -o nounset -o noclobber -o pipefail
Sort and compare files "$def.out" and "$def-new.out" </s> diff <(sort $def.out) <(sort $def-new.out)
Split "file.txt" excluding the first line into files of at most 4 lines each and with a prefix "split_" </s> tail -n +2 file.txt | split -l 4 - split_
rename all the svg.png files to png files in the current fodler </s> find . -name "*.svg.png" -print0 | sed 's/.svg.png//g' | xargs -0 -I namePrefix mv namePrefix.svg.png namePrefix.png
find all the perl files in /var/www </s> find /var/www/ -type f -name "*.pl" -print
Search the /Applications directory tree for *.app directories </s> find /Applications -type d -name "*.app"
Print a sorted list of directories from the ~/Music tree containing files whose names begin with "cover." </s> find ~/Music/ -iname 'cover.*' -printf '%h\n' | sort -u
find all the files in current folder ending with "ini" and search for a word in all these files </s> find . -name *.ini -exec grep -w PROJECT_A {} \; -print | grep ini
Delete all regular files with '.txt' extension that were modified in more than 25 minutes ago in maximum 1 level down the directory '/home/u20806/public_html' </s> find /home/u20806/public_html -daystart -maxdepth 1 -mmin +25 -type f -name "*.txt" \ -exec rm -f {} \;
Read a single character from standard input into variable "ans" </s> read -n1 ans
recursively delete, without prompting, directories under /data/bin/test, that are older than 10 days and where the name starts with a number </s> find /data/bin/test -type d -mtime +10 -name '[0-9]*' -print | xargs rm -rf ;
Find all files/directories containing 'foo' in their names under current directory tree </s> find . -name '*foo*'
Prepend the reverse history number as negative values to the output of the history command with arguments "$@" </s> history "$@" | tac | nl | tac | sed 's/^\( *\)\([0-9]\)/\1-\2/'
Find all *.mp3 files under current directory </s> find . -name *.mp3
display a long listing of all the files in the current folder </s> find . — type f -exec ls -1 {} \;
find all the config(.conf files) files in the folder /home/pat </s> find /home/pat -iname "*.conf"
display all the java script files in a folder </s> find src/js -name '*.js'
Counts lines in each *.php file. </s> wc -l $(find . -name "*.php")
Go to first directory specified in PATH which contains the command 'oracle' </s> cd $(dirname $(which ls))
List the names of the directories in current directory without going into sub-directories </s> find . -mindepth 1 -maxdepth 1 -type d -printf "%P\n"
Report total file systems disk usage. </s> df --total | tail -n 1
Replace all newlines from standard input except the last with spaces </s> sed 'x;G;1!h;s/\n/ /g;$!d'
Execute "ls -l" every 2 seconds </s> watch 'ls -l'
Find files under /some/path that are not executable by the owner </s> find /some/path -type f ! -perm -100 -ls
reverse input with comma deliminators </s> echo "a,b,c" | tr '\n' ',' | tac -s "," | sed 's/,$/\n/'
Report total file systems disk usage estimated in terabytes </s> df --total -BT | tail -n 1
Find all files/directories in level 1 down the $queue directory with all positional parameters appended with the find command </s> echo "$queue" | xargs -I'{}' find {} -mindepth 1 -maxdepth 1 $*
Print line, word and byte counts for each .php files in current directory tree and also show the total counts </s> wc `find | grep .php$`
Print only common strings in sorted content of files 'file1' and 'file2' </s> comm -1 -2 <(sort file1) <(sort file2)
Delete files "*doc copoy" in directory tree /mnt/zip </s> find /mnt/zip -name "*doc copy" -execdir rm "{}" \;
Find files by type </s> find -type type_descriptor
Display current system's kernel name, kernel release and version, and machine architecture </s> uname -srvm
Find all the .c files in the current directory tree that contain the string ‘stdlib.h’ </s> find . -name '*.c' | xargs grep 'stdlib.h'
Search the current directory tree for files whose names contain "TextForRename" </s> find ./ -name "*TextForRename*"
search for the word LOG in all the files in the folder ~/jsmith </s> find ~jsmith -exec grep LOG '{}' /dev/null \; -print
Sources script incl.sh in the folder where current script is located. </s> source $(dirname $0)/incl.sh
Search all the *.pl files in the current directory and subdirectories, and print the names of any that don't have a line starting with 'use strict' </s> find . -name '*.pl' | xargs grep -L '^use strict'
Finds out what groups a given user has. </s> groups user
Compare "current.log" and "previous.log" line by line and print lines containing regex pattern ">\|<" </s> diff current.log previous.log | grep ">\|<" #comparring users lists
Search the entire file hierarchy for files ending in '.old' and delete them. </s> find / -name "*.old" -exec /bin/rm {} \
Search the /path directory tree for files having permissions 777 </s> find /path -perm ugo+rwx
Find all files under current directory excluding hidden files </s> find . -depth -path './.*' -prune -o -print
Search for 'example' in all regular files under current directory tree </s> find . -type f -print | xargs grep "example"
List all files in a current folder, separating names with semicolon </s> ls -1b | tr '\n' ';'
Copies file 'file.dat' to each top-level directory in the current directory. </s> ls | xargs -n 1 cp -i file.dat
Print the base name of the current working directory </s> basename "`pwd`"
Create a copy of index.html in all directories in current directory whose name contains Va, pausing for confirmation before overwriting any existing files - names may not contain spaces. </s> find . -mindepth 1 -maxdepth 1 -type d| grep \/a |xargs -n 1 cp -i index.html
Create an empty index.html, or update its timestamp if it already exists. </s> touch index.html
Search for " 840" in history </s> history | grep " 840"
Find all subdirectories of the current directory except hidden ones </s> find -maxdepth 1 -type d ! -name ".*"
Move all files and directories in the current directory to "$TARGET" excluding files matching "$EXCLUDE" </s> ls -1 | grep -v ^$EXCLUDE | xargs -I{} mv {} $TARGET
print the names of all of the unstripped binaries in the /usr/local directory tree. Builtin tests avoid running file on files that are not regular files or are not executable </s> find /usr/local -type f -perm /a=x | xargs file |  grep 'not stripped' | cut -d: -f1
Find files on the system created during the last 50 days </s> find / -ctime -50
Create symlinks to all  /home/folder1/*.txt files and 'folder1_' directory with the same name in a target directory named '+' </s> find /home/folder1/*.txt -type f -exec ln -s {} "folder1_" +\;
List first 5 files named 'something' that are found under current directory </s> find . -name something -print | head -n 5
Print calendar for February, March and April of year 2009 side-by-side </s> paste <(cal 2 2009) <(cal 3 2009) <(cal 4 2009)
forcibly create a symbolic link named "linkname" to file "new_destination" </s> ln -sf new_destination linkname
Find all files/directories named 'pattern' under current directory tree </s> find . -name "pattern" -print
Print the full path of executable "lshw" </s> which lshw
Convert "1199092913" to dotted decimal IPv4 address </s> ping -c1 1199092913 | head -n1 | grep -Eow "[0-9]+[.][0-9]+[.][0-9]+[.][0-9]+"
search the word "MySearchStr" in all the regular/normal files in the current folder and display the line number and the file name </s> find . -type f -print0 | xargs -0 -e grep -nH -e MySearchStr
dispaly all the empty regular/normal files in the current folder </s> find . -type f -empty
Lists all subdirectories in a current folder, removing trailing slash. </s> ls -d */ | cut -f1 -d'/'
search for the word "slrn" in all the files in the current folder </s> find ./ -exec grep -q 'slrn' '{}' \; -print
Change permissions to 644 for *.html files under /usr/local </s> find /usr/local -name "*.html" -type f -exec chmod 644 {} \;
Remove all white space from "infile.txt" and wrap each line to 80 characters </s> cat infile.txt | tr -d "[:space:]" | fold -80
Find all *.txt files under current directory, change their permission to 666 and copy them to /dst/ directory </s> find . -name \*.txt -exec chmod 666 {} \; -exec cp {} /dst/ \;
Find all files in the current directory and its sub-directories that have not been assessed in more than 30 days. </s> find . -atime +30 -print
display all the directories in the current folder excluding those that are present in the aa directory tree </s> find . -type d -name aa -prune
Save the system host name to variable "myHostName" </s> myHostName=`hostname`
Correct permissions for files in the web directory </s> find /your/webdir -type f | xargs chmod 644
Remove all files named `junk' and `dummy' </s> find . \( -name junk -o -name dummy \) -exec rm '{}' \;
Find a single file called FindCommandExamples.txt under current directory and remove it </s> find . -type f -name "FindCommandExamples.txt" -exec rm -f {} \;
find all the files that have not been modified in the last 2 days </s> find -mtime +2
find all the normal/regular files in the folder "pathfolder" excluding all hidden files and display the count </s> find pathfolder -maxdepth 1 -type f -not -path '*/\.*' | wc -l
List all files in entire file system owned by the user wnj and are newer than the file ttt </s> find / -newer ttt -user wnj -print
Change all cron jobs running "anm.sh" to be run every 10 minutes instead of 5 minutes. </s> crontab -l | sed '/anm\.sh/s,^\*/5,*/10,' | crontab -
Find files whose content was modified at least 1 minute ago </s> find ./ -mmin +1
Save actual working directory in variable "target_PWD" </s> target_PWD=$(readlink -f .)
find all text files in current folder and delete all the files that have the word foo in their name </s> find . -name ".txt" | grep "foo" | xargs rm
Move the directory named "some-dir" and residing under the current one to x/ </s> find ./ -maxdepth 1 -name "some-dir" -type d -print0 | xargs -0r mv -t x/
Find recursively all regular files in the current directory whose names contain "." </s> find . -type f -a -name '*.*'
Change the permissions of the current directory and all its subdirectories to 755. </s> find . -type d -exec chmod 755 {} \;
Find all regular files in the current directory tree last modified between 1 and 3 days ago and list them using format '%Tc %p\n' </s> find ./ -daystart -mtime -3 -type f  ! -mtime -1  -printf '%Tc %p\n'
Print the hexadecimal bytes and printable characters of "Hello world" </s> echo Hello world | od -t x1 -t c
Calculate the md5sum of all the files with name "MyCProgram.c", ignoring case </s> find -iname "MyCProgram.c" -exec md5sum {} \;
Find all *.sh files owned by user vivek </s> find / -user vivek -name "*.sh"
Archive "/var/www/test/" to "/var/www/test" on host "231.210.24.48" as user "ubuntu" via ssh using identity file "/home/test/pkey_new.pem" </s> rsync -rave "ssh -i /home/test/pkey_new.pem" /var/www/test/ ubuntu@231.210.24.48:/var/www/test
Print all files with a '-' after their name if they are regular files, and a '+' otherwise </s> find / -type f -exec echo {} - ';' -o -exec echo {} + ';'
Gets domain name from dig reverse lookup and save in variable 'go'. </s> go=$(dig -x 8.8.8.8| awk '/PTR[[:space:]]/{print $NF}')
search for files that are readable for everybody, have at least on write bit set but are not executable for anybody </s> find . -perm -444 -perm /222 ! -perm /111
List all files in entire file system that are newer than the file $newerthan and older than the file $olderthan and sort them according to file modification time </s> find / -type f -name "*" -newermt "$newerthan" ! -newermt "$olderthan"  -printf '%T@ %p\n' | sort -k 1 -n | sed 's/^[^ ]* //'
Search the current directory tree for all image files </s> find . -type f -regex ".*\.\(jpg\|jpeg\|gif\|png\|JPG\|JPEG\|GIF\|PNG\)"
Search the /home/www directory tree for regular files </s> find /home/www -type f
Print mount point of the file system containing $path. </s> df -P "/tmp" | awk 'BEGIN {FS="[ ]*[0-9]+%?[ ]+"}; NR==2 {print $NF}'
List all files under current directory that are greater than 10000000x512 bytes in size </s> find . -type f -size +10000000 -print|xargs ls -ld|more
count lines of C or C++ or Obj-C code under the current directory </s> find . \( -name "*.c" -or -name "*.cpp" -or -name "*.h" -or -name "*.m" \) -print0 | xargs -0 wc
Find all directories under current directory and change their permission to 755 </s> find . -type d -exec chmod 755 {} \;
Remove the passphrase from user's ssh key without prompting. </s> echo | ssh-keygen -P ''
Print characters in variable "$a" that exist in variable "$b" </s> echo "$(comm -12 <(echo "$a" | fold -w1 | sort | uniq) <(echo "$b" | fold -w1 | sort | uniq) | tr -d '\n')"
Find all files under /path/to/Dir and set their permission to 644 </s> sudo find /path/to/Dir -type f -print0 | xargs -0 sudo chmod 644
Convert the first 16 characters in "/dev/random" to a single hexadecimal value </s> head /dev/random -c16 | od -tx1 -w16 | head -n1 | cut -d' ' -f2- | tr -d ' '
Find all files in your home directory and below that are larger than 100M. </s> find ~ -size +100M
recursively look for files ending in either .py or .py.server </s> find . \( -name "*.py" -o -name "*.py.server" \)
Print history with the first field removed </s> history | awk '{sub($1, "", $0); sub(/^[ \t]+/, "", $0); print}'
Find all files/directories that belong to the group 'staff' under '/usr' directory tree </s> find /usr -group staff
List all cron jobs for current user. </s> crontab -l
Find the total size of *.jpg files within the current directory tree </s> find . -type f -iname '*.jpg' -print0 | xargs -r0 du -a| awk '{sum+=$1} END {print sum}'
Display an infinite number of lines consisting of "y", until the user presses the Q key. </s> yes | cat | more
Finds recursively all files in '/path/' that contain 'pattern', and prints matched strings with string number and file name. </s> grep -rnw '/path/' -e 'pattern'
search for the file "process.txt" in the entire file system (case insensitive search) </s> find / -iname 'process.txt' -print
list all .c or .sh regular files. </s> find . -type f \( -name "*.c" -o -name "*.sh" \)
Clean directories and subdirectories of the temporary files generated during normal use </s> find . \( -name a.out -o -name '*.o' -o -name 'core' \) -exec rm {} \;
Find all files that have been modified in the last seven days. </s> find . -mtime -7 -type f
find all the files in the folder "myfiles" which have not been accessed in the last 30 days </s> find /myfiles -atime +30
Rename "/usr/bin/php" to "/usr/bin/~php" </s> sudo mv /usr/bin/php /usr/bin/~php
Find all files/directories under current directory </s> find .
Delete all hidden files under $some_directory </s> find "$some_directory" -type f -name '.*' -delete
Find all directories named essbase under /fss/fin </s> find /fss/fin -type d -name  "essbase" -print
Find all $2 files in $1 path excluding /proc and search for the regex expanded by $3 in those files </s> find $1 -path /proc -prune -o -name "$2" -print -exec grep -Hn "$3" {} \;
Find all regular files under test directory </s> find test -type f
Find all the files which were modified more than 50 days but less than 100 days ago </s> find / -mtime +50 -mtime -100
Find regular files that are bigger than 500 MB in size under current directoryt tree </s> find . -type f -size +500M
Recursively change ownership of "/usr/local" to the current user </s> sudo chown -R `whoami` /usr/local
Rename all files and directories under current directory tree by converting the names to small letters without descending into 'CVS' directory </s> find . -name CVS -prune -o -exec mv '{}' `echo {} | tr '[A-Z]' '[a-z]'` \; -print
Search the current directory tree for regular files that can be read by noone </s> find -type f ! -perm -444
Find all IP addresses in /etc directory files </s> find /etc -exec grep '[0-9][0-9]*[.][0-9][0-9]*[.][0-9][0-9]*[.][0-9][0-9]*' {} \;
Ensure all 5 of UEDP0{1..5}_20120821.csv files exist, creating empty files for any missing ones (updates the file's timestamps) </s> touch -a UEDP0{1..5}_20120821.csv
Extract host name part from URL. </s> echo "$url" | cut -d'/' -f3
Write output of "ls -a" to standard output and to "output.file" </s> ls -a | tee output.file
Find all build* directories under /var/www/html/ and print all but first 5 appending with the string 'rf ' </s> find /var/www/html/ -type d -name "build*" | sort | tail -n +5 | xargs -I % echo -rf %
Search for 'stuff' in all *,txt files under current directory </s> find . -name "*.txt" -print0 | xargs -0 egrep 'stuff'
Rename '.mkv' extension to '.avi' for all files/directories under '/volume1/uploads' directory tree </s> find /volume1/uploads -name "*.mkv" -exec rename 's/\.mkv$/.avi/' \{\} \;
Find all links to path/to/file </s> find -L -samefile path/to/file
Search for all files named foo, FOO, or any other combination of uppercase and lowercase characters beneath the current directory. </s> find . -iname foo -type f
Find all files named 'file' in 1 level down the current directory whose status were changed more than 1 hour ago </s> find . -maxdepth 1 -cmin +60 -name file
find all the configuration or text files in current directory </s> find . -type f \( -name "*.conf" -or -name "*.txt" \) -print
Decompress 'file.gz' </s> gzip -d file.gz
Find all *.foo files under current directory and print their contents </s> find . -name '*.foo' -exec cat {} \;
Recursively removes $TMPDIR folder, prompting user on each deletion. </s> rm -r $TMPDIR
Search /etc for files modified within the last day </s> find /etc -type f -ctime -1
Delete all empty directories in minimum 2 levels down the root directory </s> find root -mindepth 2 -type d -empty -delete
Find the "erl" executable in $PATH and read the "RELEASES" file to extract the erlang release number </s> awk -F, 'NR==1 {gsub(/"/,"",$3);print $3}' "$(dirname $(readlink -f $(which erl)))/../releases/RELEASES"
Recursively copy "/path/to/data/myappdata/*.txt" to "user@host:/remote/path/to/data/myappdata/" </s> rsync -rvv /path/to/data/myappdata/*.txt user@host:/remote/path/to/data/myappdata/
Find all regular files in the home directory tree that were modified in the last 24 hours </s> find ~ -type f -mtime 0
Find all *.txt files/directories under current directory </s> find . -name "*.txt" -print
Creates temporary file with appended suffix '.cmd' and saves path to it in 'LGT_TEMP_FILE' variable. </s> LGT_TEMP_FILE="$(mktemp --suffix .cmd)"
Find all files/directories under current directory </s> find ./
List the directory paths of all file.ext files under present working directory </s> find `pwd` -name file.ext |xargs -l1 dirname
create and list contents of the archive </s> tar cf - $PWD|tar tvf -
Read a line from standard input into variable "password" without echoing the input </s> read -s password
find all the files in the current folder which have been modified in the last one day </s> find . -daystart -mtime -1 -ls
find all the files ending with ".coffee" in the current folder and search for the first occurence of the word "re" in each line </s> find . -name '*.coffee' -exec awk '/re/ {print;exit}' {} \;
search for the file test2 in the current folder </s> find -name test2
Find all files/directories that are owned by user 'wnj' and are newer than 'ttt' by modification time in the entire filesystem </s> find / -newer ttt -user wnj -print
Change permissions for all PHP files under the current directory tree to 755 and print the number of files changed </s> find . -name "*.php" -exec chmod 755 {} + -printf '.' | wc -c
Find all *FooBar* files/directories under current directory and copy them to ~/foo/bar </s> find . -name '*FoooBar*' | sed 's/.*/"&"/' | xargs cp ~/foo/bar
Print the list of regular files in the current directory and all subdirectories </s> find . -type f
Search the current directory tree for files modified less than 5 days ago </s> find . -mtime -5
find files in home directory that names are game </s> find ~ -name game
Search directory tree `MyApp.app' for directories whose name is 'Headers' and delete them in an optimized way </s> find -d MyApp.app -name Headers -type d -exec rm -rf {} +
Find all the *.pl files (Perl files) beneath the current directory. </s> find . -name "*.pl"
Save standard input to variable "myVar" </s> myVar=$(tee)
delete all the regular files in the temp folder which have not been modified in the last 24 hours </s> find /tmp/ -type f -mtime +1 -exec rm {} \;
Compresses all files in the directory 'PATH_TO_FOLDER' without recursion and keeps uncompressed files from deletion. </s> find PATH_TO_FOLDER -maxdepth 1 -type f -exec bzip2 -zk {} \;
Use "$BYTES" amount of RAM for "$SECONDS" seconds with no output </s> cat <(yes | tr \\n x | head -c $BYTES) <(sleep $SECONDS) | grep n
Exclude directory from find . command </s> find ! -path "dir1" -iname "*.mp3"
create directory public_html into home directory </s> mkdir ~/public_html
Search the /etc/apache-perl directory tree for files newer than /etc/apache-perl/httpd.conf </s> find /etc/apache-perl -newer /etc/apache-perl/httpd.conf
Find files named "ppp.conf" in the /etc directory tree </s> find /etc -name ppp.conf
display all the directories in the current folder and create a skeleton of make directory commands with all these folders </s> find -type d|sed -r '/^.$/{s:.:#!/bin/bash:};{s/^\./mkdir -p &/}'
Find all files named 'test' in the current directory tree, not descending into "test" directories </s> find . -name test -prune
find all the files in current directory of size smaller than 10KB. </s> find . -size -10k
Remove all a.out, *.o, and core files under the current directory </s> find . \( -name a.out -o -name '*.o' -o -name 'core' \) -exec rm {} \;
Find all foo.mp4 files in the current directory tree and print the pathnames of their parent directories </s> find . -name foo.mp4 -printf '%h\n'
Find all files under current directory that are read less than 1 minute ago </s> find . -amin -1
Remove all *.sql files in the $backup_path directory that were last modified more than 5 days ago </s> find $backup_path/*.sql -mtime +5 -exec rm -f {} \;
search for text files in the current folder which do not have write access to others </s> find . -type f \( -iname "*.txt" -not -perm -o=w \)
Find all *-* files under current directory </s> find . -type f -name '*-*'
find foo, Foo, FOo, FOO, etc. </s> find . -iname foo
Md5sum the last 5 files in /directory1/directory2/ </s> find /directory1/directory2/ -maxdepth 1 -type f | sort | tail -n 5 | xargs md5sum
Move each of the directories in /path/to/folders/* to another directory whose name is constituted by appending .mbox to each directory name and create a directory named Messages in this directory </s> find /path/to/folders/* -type d -exec mv {} {}.mbox \; -exec mkdir {}.mbox/Messages \;
Search the file system for regular files whose names are shorter than 25 characters </s> find / -type f -regextype posix-extended -regex '.*/.{1,24}$'
Find all files/directories under $1 which have at least read permission for their owner and set read permission for group for these files/directories </s> find $1 -perm -u+r -exec chmod g+r {} \;
Delete all files with indoe number $inum under current directory tree </s> find . -inum $inum -exec rm {} \;
Set 644 permission to all regular files under /home/my/special/folder directory </s> chmod 644 `find /home/my/special/folder -type f`
Set permissions for directories in `foldername' and its subdirectories to 755 </s> find foldername -type d -exec chmod 755 {} ";"
Search the current directory recursively for the largest files </s> find . -type f -printf '%20s %p\n' | sort -n | cut -b22- | tr '\n' '\000' | xargs -0 ls -laSr
Print the basename from a colon separated path 'a:b:c:d:e' </s> basename $(echo "a:b:c:d:e" | tr ':' '/')
Counts lines of 'file' file. </s> wc -l file
Save absolute path of the script filename in variable "SCRIPT" </s> SCRIPT="$(readlink --canonicalize-existing "$0")"
Find all directories under maximum 1 level down the current directory and set their permission to 700 recursively </s> find . -maxdepth 1 -type d -exec chmod -R 700 {} \;
Print 3 newline separated "y"s </s> yes | head -3
find all teh script files in a directory </s> find /home/john -name "*.sh" -type f -print
Search for "ifconfig" in the output of "history" and print 5 lines that precede and follow </s> history | grep -C 5 ifconfig
Calculate md5 sum of empty string </s> echo -n "" | md5sum
Find all the files named 'vimrc' anywhere on the system </s> find / -name vimrc
Find all directories under current directory excluding  directories (along with their contents) that start with a . (dot) in their names </s> find . -type d -a ! -name '.?*' -o -name '.?*' -a ! -prune
Set variable value to current kernel release name. </s> value=$(uname -r)
List all files from the current directory tree that were modified less than 60 minutes ago </s> find . -mmin -60 | xargs -r ls -ld
Print URL "http://www.blabla.bla/forum-detail/?ft=72260&fid=34&&pgr=" followed by a number ranging from 1 to 786 </s> yes 'http://www.blabla.bla/forum-detail/?ft=72260&fid=34&&pgr=' | nl -ba | sed 786q | grep . | awk '{print $2$1}'
Remove files modified at least five days ago in directory trees /path/to/files* </s> find /path/to/files* -mtime +5 -exec rm {} \;
Remove empty directories from directory tree /srv/abc </s> find /srv/abc/ -type d -empty -exec rmdir {} \;
Find links to any file that happens to be named `foo.txt' </s> find . -lname \*foo.txt
Compare text "hello" and "goodbye" line by line </s> diff <(echo hello) <(echo goodbye)
Creates file by template 'aws-sync-XXXXX' in a current folder and stores file name in a 'dir' variable. </s> dir="$(mktemp aws-sync-XXXXX)"
Find all files/directories under current directory and print their paths </s> find . -exec echo {} ";"
find all the files in the file system which have been changed in the last 24 hours. </s> find / -ctime -1
Change the permission to 644 for all files under current directory </s> find . -type f | xargs chmod -v 644
Unzip all files that match "*.gz" in the current directory and subdirectories to stdout and search for "test" </s> find . -name "*.gz" -exec zcat "{}" + |grep "test"
List the names of the directories in current directory without going into sub-directories </s> find . -maxdepth 1 -mindepth 1 -type d -printf '%f\n'
Find all *.gz files/directories under asia and emea directory </s> find asia emea -name \*.gz -print0 | xargs -0
Search the current directory tree for regular files whose names match regular expression ".+-[0-9]+x[0-9]+\.jpg" </s> find . -type f -regex ".+-[0-9]+x[0-9]+\.jpg"
Find all OGG files in the home directory that are at most 20 megabytes in size </s> find $HOME -iname '*.ogg' ! -size +20M
Send SIGKILL signal to process ID 16085, killing it instantly. </s> kill -9 16085
Find all *company* files/directories under /root/of/where/files/are directory </s> find /root/of/where/files/are -name *company*
Set 644 permission to all regular files under current directory </s> chmod 644 `find -type f`
Find all *.rb (regular) files under current directory and count their line numbers </s> find . -name "*.rb" -type f | xargs wc -l
find all the file that have been modified exactly 3 days ago ( considers day starting not 24 hours ) </s> find ./ -daystart -mtime -3
Prints long listing of directories "./my dir" and "./anotherdir" sorted from oldest to newest, with appended indicators. </s> $ ls -Fltr "./my dir" "./anotherdir"
Find users whose names begin with "ab" or whose terminal from which they are logged in ends with "1" </s> who | grep -e '^ab' -e '1$'
Recursively finds all "file_pattern_name" files and folders and prints strings with "pattern", searching through found folders recursively. </s> find ./ -name "file_pattern_name"  -exec grep -r "pattern" {} \;
Make directory "/tmp/googleTestMock" </s> mkdir /tmp/googleTestMock
Find files which were changed in the past 1 hour </s> find . -cmin -60
Print second section of space-separated data from text file "a". </s> cut "-d " -f2 a
display all the regular files in the current folder which dont not have the permission 777 </s> find . -type f ! -perm 777
Find all files in the current directory tree except .html, ignoring .svn directories </s> find . \( -type d -name '.svn' -o -type f -name '*.html' \) -prune -o -print0
ask user confirmation and delete all the files in the directory /mydir which have not been accessed in the last 100*24 hours </s> find /mydir -atime +100 -ok rm {} \;
Find all .txt files under the current directory and below </s> find . -name "*.txt"
display all regular files in current folder excluding search in the directories that are ending with "git,svn" </s> find . \( -type d -regex '^.*/\.\(git\|svn\)$' -prune -false \) -o -type f -print0
display all the files in the entire file system </s> find / -name "*" — print
Search directory /home/ABCD recursively, starting from one level below, for regular files </s> find /home/ABCD/ -mindepth 1 -type f -print
Pick up a list of variable:value pairs from msgs.config and add them to the current shell or script's environment. </s> source <( sed 's/:\(.*\)/="\1"/' msgs.config )
Print a single line of numbers from "001" to "010" </s> yes | head -n 10 | awk '{printf( "%03d ", NR )}'
Print the full path directory name of each "file.ext" found under the current directory </s> find . -name "file.ext" -execdir pwd ';'
Set variable "filename" to only the name of document specified by URL, in this case "pic.jpg" </s> filename="`basename "http://pics.sitename.com/images/191211/pic.jpg"`"
Find all regular files under $DIRECTORY_TO_PROCESS matching the case insensitive regex ".*\.$FILES_TO_PROCES" where $FILES_TO_PROCES is a variable and not matching the name pattern '$find_excludes' where $find_excludes is another variable, then print the files with null delimiter instead of newline </s> find "$DIRECTORY_TO_PROCESS" -type f -iregex ".*\.$FILES_TO_PROCES" ! -name "$find_excludes" -print0
search the file myfile.txt in the current folder </s> find . -name myfile.txt -print
search for a word in all the files with the extension "ch" in the current folder </s> find -name '*.[ch]' | xargs grep -E 'expr'
Delete all files/directories older than 48 hours in /path/to/files* paths </s> find /path/to/files* -mtime +2 -delete
search for text files in the directory "/home/user1" and copy them to the directory /home/backup </s> find /home/user1 -name '*.txt' | xargs cp -av --target-directory=/home/backup/ --parents
Find all file paths under current directory, perform a reverse numerical sort and show first 10 file paths with their status change time </s> find . -type f -printf "%C@ %p\n" | sort -rn | head -n 10
Show the last 10 .conf files found by `find' in the /etc directory and 1 level below </s> find /etc -maxdepth 2 -name "*.conf" | tail
Find a size of only the target directory in MB format </s> du -s --block-size=M /path/to/your/directory/
list all regular files which path is not dir1 or dir2 </s> find ! -path "dir1" ! -path "dir2" -type f
Log in using key file "./device_id.pem" as user "deviceuser" on host "middle.example.org" and port 2222 </s> ssh -i ./device_id.pem -p 2222 deviceuser@middle.example.org
Find and print the full pathname of all PDF files in the current directory and its sub-directories. </s> find . -name "*.pdf" -print
find all the php files in the current folder </s> find . -name “*.[php|PHP]” -print
find files with pattern` '*.h' and print comparison between file and /tmp/master directory </s> find . -name '*.h' -execdir diff -u '{}' /tmp/master ';'
Archive "/top/a/b/c/d" to host "remote" using relative path names </s> rsync -a --relative /top/a/b/c/d remote:/
Enables 'globstar' (recursive globbing) shell option. </s> shopt -s globstar
Find all files that are set user ID to root </s> find . -user 0 -perm -4000 -print
Wrap each line in "longline" to a maximum of 30 characters breaking at spaces </s> fold -w30 -s longline
Unzip and untar "4.56_release.tar.gz" to standard output </s> gunzip -c 4.56_release.tar.gz | tar xvf -
Copy local file "$1" to host "$2" into host directory "$3" </s> cat $1 | ssh $2 "mkdir $3;cat >> $3/$1"
Find all files that are set group ID to 10 </s> find . -group 10 -perm -2000 -print
Recursively changes group ownership on every file in the ${WP_ROOT}/wp-content directory to ${WS_GROUP} group. </s> find ${WP_ROOT}/wp-content -exec chgrp ${WS_GROUP} {} \;
Compare files 'file1' and 'file2' and print in three columns strings unique for first file, second file, and common ones </s> comm abc def
Change ownership of "/vol" to the current user </s> sudo chown `whoami` /vol
Search the entire file hierarchy for files ending with '~' and print all matches except for those with '/media' in their pathnames. </s> find / -name "*~" | grep -v "/media"
Prints long listing of the current directory, sorted from oldest to newest, with appended indicators. </s> $ ls -Fltr
Find all *fink* files/directories under current directory </s> find . -name "*fink*" -print
Search for files/directories named 'fileName.txt' under current directory tree without traversing into './ignored_directory' </s> find . -path ./ignored_directory -prune -o -name fileName.txt -print
Print the first 5 decompressed lines of compressed file "$line" </s> zcat "$line" | head -n5
Find files/directories that are bigger than 10000 KB in size uder '/usr/local' directory tree </s> find /usr/local -size +10000k
Remove the .jpg files from the current directory whose names match regular expression ".+-[0-9]+x[0-9]+\.jpg" </s> find . -type f -regex ".+-[0-9]+x[0-9]+\.jpg" | xargs rm
Remove filetype suffix (last dot and following characters if any) from filename </s> echo $filename | rev | cut -f 2- -d '.' | rev
find all the directories in the $LOGDIR folder which have been modified in the last 24 hours and compress them </s> find $LOGDIR -type d -mtime +0 -exec compress -r {} \;
Find smallest file in the current directory with find commad </s> find . -type f -printf "%s\t%p\n" | sort -n |head -1
find all the files which are of size 0 bytes. </s> find . -type f -empty
Check if $path_in_question is mount point of filesystem </s> df $path_in_question | grep " $path_in_question$"
find all the files in the folder /home which are bigger than 10MB and smaller than 50 MB </s> find /home -size +10M -size -50M
change owner of the file "file" to user user_name </s> chown user_name file
Find files newer than `tmpfile' starting from the current directory </s> find . -newer tmpfile
Mount "ntfs-3g" filesystem "/dev/mapper/myvolume" on "/media/volume" </s> mount -t ntfs-3g /dev/mapper/myvolume /media/volume
Read a line from standard input into variable "date" with prompt "BGC enter something", and storing typed backslash as backslash symbol </s> read -p 'BGG enter something:' -r data
split content of the files *.txt beginning with 1001st line into pieces per 1000 lines </s> cat *.txt | tail -n +1001 | split --lines=1000
Search the /tmp/ directory recursively for regular files </s> find /tmp -type f
display the count of all the normal/ regular files in the current directory </s> find . -type f |wc -l
Allow anyone to run command "Xvfb" as the owner of "Xvfb" </s> sudo chmod u+s `which Xvfb`
Saves folder path where target of symbolic link $file file is located in 'base' variable. </s> base=$(dirname $(readlink $file))
Print a list of regular files from directory tree sort_test/ sorted with LC_COLLATE=C </s> find sort_test/ -type f | env -i LC_COLLATE=C sort
Create symbolic links in the current directory for all files excluding "CONFIGFILE" located under "/your/project" directory tree </s> find /your/project -type f ! -name 'CONFIGFILE' -exec ln -s \{\} ./ \;
Search the current directory tree for regular files whose names begin with "orapw" </s> find . -name "orapw*" -type f
Move "file.txt" to docker container "$COUNTAINER_ID" in path "/var/lib/docker/aufs/mnt/$CONTAINER_ID/rootfs/root/file.txt" </s> mv -f file.txt /var/lib/docker/aufs/mnt/$CONTAINER_ID/rootfs/root/file.txt
Search for 'pattern_to_search' in all regular files with '.txt' extension under '/directory/containing/files' and show the matched lines along with filenames </s> find /directory/containing/files -type f -name "*.txt" -exec grep -H 'pattern_to_search' {} +
Kills all child process and process itself having id 24901. </s> kill `pstree -p 24901 | sed 's/(/\n(/g' | grep '(' | sed 's/(\(.*\)).*/\1/' | tr "\n" " "`
sort and display the unique lines display the contents of all the files that have been modified in the last 91 days and not in the last 2 days </s> find .  -name "*.txt" -type f -daystart -mtime -91 -mtime +2 | xargs cat | sort | uniq
split file /etc/gconf/schemas/gnome-terminal.schemas into pieces per 1000000 lines </s> split -n 1000000 /etc/gconf/schemas/gnome-terminal.schemas
Enables shell option 'lithist'. </s> shopt -s lithist
Find all *.php (case insensitive) files and *.js files/directories (case insensitive) under /home/jul/here excluding *.js files/directories under /home/jul/here/exclude/* paths </s> find /home/jul/here -type f -iname "*.php" -o -iname "*.js" ! -path "/home/jul/here/exclude/*"
Prints server name from SOA record for domain yahoo.com </s> dig +noall +answer soa yahoo.com | awk '{sub(/.$/,"",$5);print $5}'
find all the files in the current folder and display those that are not present in the list "file.lst" </s> find . | grep -vf file.lst
find all the files in current folder which have been updated in the last 60 minutes </s> find . -mmin -60
Find all regular files with case insensitive pattern '*$1*' ($1 expands to first positional parameter and falls back to empty string when not given) under current directory tree and execute a command given by $2 (falls back to 'file' command when $2 is not given) with each of those files as arguments </s> find . -type f -iname '*'"${1:-}"'*' -exec ${2:-file} {} \;
Find all directories under current directory and change their permission to 500 </s> find . -type d -exec chmod 500 {} \;
find all the normal/regular files in the current folder which have been modified in the last 24 hours and display a long listing of them </s> find . -type f -mtime -1 -exec ls -l {} \;
find all the regular/normal files in the current folder </s> find -type f
Print contents of "file" as space separated hexadecimal bytes on a single line </s> od -t x1 -An file |tr -d '\n '
Find all files/directories named 'document' in the entire filesystem </s> find / -name document -print
Find regular files under / that contain "stringtofind" and clear out their contents </s> find / -maxdepth 1 -xdev -type f -exec grep -i "stringtofind" -l {} \; -exec sed -i '/./d' {} \;
Add cron lists from "file1" and "file2" to list of cron jobs, giving errors for any lines that cannot be parsed by crontab. </s> cat file1 file2 | crontab
display all text files in the folder /user/directory which have been modified in today </s> find /user/directory/* -name "*txt" -mtime 0 -type f
Find how many directories are in a path (counts current directory) </s> find . -type d -exec basename {} \; | wc -l
Print argument "$1" "$number" times </s> yes $1 | head -$number
Print variable "$opt" with double quotes deleted </s> echo "$opt" | tr -d '"'
Count the number of differing lines in "file1" and "file2" </s> diff file1 file2 | grep ^[\>\<] | wc -l
Read a line from standard input and save each word in the bash array variable "arr" </s> read -a arr
display the list of all the normal files excluding hidden files which have been accessed in the last 500 days </s> find . -type f -not -name ‘.*’ -mtime +500 -exec ls {} \;
Read a single character from standard input into variable "REPLY" ignoring backslash escapes and using the prompt "${1:-Continue?} [y/n]: " </s> read -r -n 1 -p "${1:-Continue?} [y/n]: " REPLY
Search the regular files of the current directory tree for string "foo" </s> find . -type f -exec grep "foo" '{}' \;
Display differences in "/tmp/ksh-9725.log" when compared to "/tmp/ksh-9781.log" </s> diff /tmp/ksh-{9725,9781}.log | grep ^\<
Print the list of all files except files named BBB </s> find . \! -name BBB -print
Finds strings with text "searched-string" recursively in all files of current folder and prints names of files with matched strings. </s> grep -r -l "foo" .
display all the directories in the folder master- </s> find master -type d | sort
display a long listing of all files in the entire file system which are bigger than 1MB </s> find / -size +1000k -exec ls -l {} \; -print
Find all PHP files under current directory that contain only one non-blank line </s> find . -type f -name '*.php' -exec grep -Hcm2 '[^[:space:]]' {} + | sed -n '/:1$/{s///;p}'
Create a report of the contents of a USB drive mounted at find /path/to/drive </s> find /path/to/drive -type f -exec file -b '{}' \; -printf '%s\n' | awk -F , 'NR%2 {i=$1} NR%2==0 {a[i]+=$1} END {for (i in a) printf("%12u %s\n",a[i],i)}' | sort -nr
Find all regular files under $FILES_PATH directory tree and save the output to 'FILES' variable </s> FILES=$(find $FILES_PATH -type f -name "*")
searches through the /usr directory for the regular  file named 'Chapter1*' </s> find /usr -name "Chapter*" -type f
Rename "svnlog.py" to "svnlog" </s> mv svnlog.py svnlog
Remove all files from the current directory tree whose names do not end with ".tex" or ".bib" </s> find . | egrep -v "\.tex|\.bib" | xargs rm
Enables 'dotglob' shell option. </s> shopt -s dotglob
Print a summary of the command-line usage of find </s> find --help
Recursively copy all ".txt" files to "user@remote.machine:/tmp/newdir/" </s> rsync -rvv *.txt user@remote.machine:/tmp/newdir/
List all files and directories (including hidden) in the current working directory in a long list format sorted by the oldest modification time </s> ls -alrt `pwd`/*
print readline bindings that use key code '\\e\\C-k' </s> bind -P | grep '\\e\\C-k'
Remove empty directories </s> find -type d -exec rmdir --ignore-fail-on-non-empty {} + ;
Read a line from standard input into variable "REPLY" with prompt "$1 ([y]es or [N]o): " </s> read -p "$1 ([y]es or [N]o): "
Clean up all zombie processes by sending SIGTERM signal to their parent process, which requests them to terminate. </s> kill $(ps -A -ostat,ppid | awk '/[zZ]/{print $2}')
display all the files in the current folder which are bigger than 100MB and save the output list to the file /root/big.txt </s> find \( -size +100M -fprintf /root/big.txt %-10s %p\n \)
Archive "/path/to/files" to "/path" on host "user@targethost" with elevated permission on the remote host </s> rsync -av --rsync-path="sudo rsync" /path/to/files user@targethost:/path
Count lines that are neither blanks nor comments in a file 'foo.pl' </s> cat foo.pl | sed '/^\s*#/d;/^\s*$/d' | wc -l
Print a list of regular files from directory tree sort_test/ sorted with LC_COLLATE=en_US.utf8 </s> find sort_test/ -type f | env -i LC_COLLATE=en_US.utf8 sort
List each unique case insensitive character in "file" prefixed by number of occurrences </s> grep -o . file | sort -f | uniq -ic
Recursively finds in all folders but "./output/*" all files but *.o, *.swp and prints strings with 'soc_attach' text pattern and number of matched string. </s> find .  \( ! -path "./output/*" \) -a \( -type f \) -a \( ! -name '*.o' \) -a \( ! -name '*.swp' \) | xargs grep -n soc_attach
Archive "directory" preserving hard links from host "remote" to the current local directory and keep partial files, handle sparse files efficiently, and itemize changes made </s> rsync -aPSHiv remote:directory .
find file named foo.txt under current directory. </s> find . -name foo.txt
Creates temporary file with file name formatted like /tmp/gnuplot_cmd_$(basename "${0}").XXXXXX.gnuplot and saves path to it in a variable 'gnuplotscript'. </s> gnuplotscript=$(mktemp /tmp/gnuplot_cmd_$(basename "${0}").XXXXXX.gnuplot)
Save long listing of all running processes in the 'log' file, and save number of process strings that contain 'cntps' in the 'cnt' variable. </s> cnt=`ps -ef| tee log | grep "cntps"|grep -v "grep" | wc -l`
search for the file job.hostory in the folder "/data/Spoolln" </s> find /data/SpoolIn -name job.history
Change to folder where the oracle binary is. </s> cd $(dirname $(which oracle))
Find all files files under the current directory except *.txt </s> find . -maxdepth 1 -type f -not -regex '.*\.txt'
Count files accessed more than a month ago </s> find . -atime +30 -exec ls \; | wc -l
Make all directories in the current directory tree accessible to anybody </s> find . -type d -print0 | xargs -0 chmod go+rx
List all files in the current directory tree that were modified 60 minutes ago </s> find . -mmin 60 -print0 | xargs -0r ls -l
find all files in the current folder which have not been accessed in the last 30 days in the current folder </s> find . -atime +30 -print
Display last 100 lines of file-with-line-too-long.txt, waiting for user input after each page. </s> tail -1000 file-with-line-too-long.txt | more
Print the unique lines from standard input preserving the order they appear </s> nl -n ln | sort -u -k 2| sort -k 1n | cut -f 2-
find all the "passwd" files in the entire file system </s> find / -iname passwd
Save 'foo' into variable 'bar' in ksh </s> echo foo | read bar
Finds strings like "texthere" recursively in all files of a current folder regarding all symlinks. </s> grep -R "texthere" *
find all text files in current folder and trim the extra spaces in all lines in these files ( MAC version ) </s> find . -iname '*.txt' -type f -exec sed -i '' 's/[[:space:]]\{1,\}$//' {} \+
Finds name of a current month and saves it in a 'month' variable. </s> month=$(cal | head -1 | grep -oP "[A-Za-z]+")
Change directory to the directory containing the current script </s> cd $(dirname $(which $0) )
search for all the files in the current directory which have been modified in the last 24 hours. </s> find . -mtime -1
Move all Emacs backup files from the current directory tree to ~/backups/ </s> find . -name '*~' -print 0 | xargs -0 -I % cp % ~/backups
Look for files with the name 'search' under current directory </s> find . -name "search"
Gets IP address of first listed network interface in system. </s> ifconfig | grep -E "([0-9]{1,3}\.){3}[0-9]{1,3}" | grep -v 127.0.0.1 | awk '{ print $2 }' | cut -f2 -d:
Replace all occurrences of "StringA" with "StringB" in the *.php and *.html files residing in the current directory tree </s> find . \( -name "*.php" -or -name "*.html" \) | xargs grep -l StringA | xargs sed -i -e 's/StringA/StringB/g'
Search the current directory tree for files and directories whose names do not end in ".exe" and ".dll" </s> find . ! \( -name "*.exe" -o -name "*.dll" \)
Find all files in the current directory tree with size bigger than 5 MB and sort them by size </s> find ./ -size +5M -type f | xargs -r ls -Ssh
Split standard input into files of at most 3400000 lines each </s> split -l 3400000
Follow symbolic links for the full path of "lshw" </s> readlink -f $(which lshw)
Find all files/directories named 'photo.jpg' under current directory tree </s> find -name photo.jpg
Recursively changes group ownership of everything in 'files' to 'my_group'. </s> chgrp -R my_group files
Find all files starting from / whose names end with ".rpm" and change their permissions to 755 </s> find / -name *.rpm -exec chmod 755 '{}' \;
create a symbolic link with absolute path "/cygdrive/c/Program Files" to file "/cygdrive/c/ProgramFiles" </s> ln -s "/cygdrive/c/Program Files" /cygdrive/c/ProgramFiles
Recursively change the owner and group of "~/.ssh/" to "dev_user" </s> chown "dev_user"."dev_user" -R ~/.ssh/
Find all files/directories with space in their names under $1 directory </s> find $1 -name '* *'
Find all *fstab* files under and below /etc </s> find /etc -name *fstab*
display the files along with the size of all the files in the current which are bigger than 100MB </s> find . -size +100M -exec ls -s {} \;
Find all files with the name "MyProgram.c" in the current directory and its sub-directories while ignoring the case of the file name. </s> find -iname "MyCProgram.c"
find file end with  '.txt' in current directory. </s> find . -name "*.txt"
change owner and group of the file it to user and group root </s> chown root:root it
sleep for 500 seconds </s> sleep 500
Remove all vmware-*.log files under current directory ensuring white space safety in filename </s> find . -name vmware-*.log -print0 | xargs -0 rm
Find all files/directories with 644 permission in entire file system </s> find / -perm 644
Search for files specifying the minimum depth of the search </s> find -mindepth num -name query
Search for file names with "bad" characters in the current directory and delete the files. </s> find . -name '*[+{;"\\=?~()<>&*|$ ]*' -maxdepth 0 -exec rm -f '{}' \;
Delete all files under $INTRANETDESTINATION/weekly directory tree that were modified more than 32 days ago </s> find $INTRANETDESTINATION/weekly -mtime +32 -exec rm {} \;
Search for "pattern" in "file" and separate each line with '" "' </s> cat file | grep pattern | paste -sd'~' | sed -e 's/~/" "/g'
Find all files/directories with '.txt' extension under '/home' directory tree that are greater than 100KB in size </s> find /home -name "*.txt" -size +100k
Format file "list-of-entries.txt" as new-line separated columns </s> column -t -s $'\n' list-of-entries.txt
search for the word foo in all the js files in the current folder </s> find . -name "*.js" -exec grep -iH foo {} \;
Find all regular files under and below /home/admin/public_html/, and change their permissions to 644 </s> find . /home/admin/public_html/ -type f -exec chmod 644 {} \;
create an archive using 7zhelper.sh as a compress program </s> tar -I 7zhelper.sh -cf OUTPUT_FILE.tar.7z paths_to_archive
Print out the names and types of all files in the current directory tree </s> find . -printf "%y %p\n"
Find & replace broken symbolic links </s> find -L . -type l -delete -exec ln -s new_target {} \;
find all files that names are dir-name-here </s> find / -name "dir-name-here"
Search the current directory recursively for regular files that have been changed less than 3 days ago and print 5 of them. </s> find . -type f -ctime -3 | tail -n 5
Search for case insensitive pattern 'search for me' in all files that match the name pattern '*.[!r]*' under current directory tree </s> find . -name "*.[!r]*" -exec grep -i -l "search for me" {} \;
Locate all files named 'restore.php' in the current directory and 3 levels below </s> find . -maxdepth 4 -name 'restore.php'
Find all .bak files starting from the current directory and delete them </s> find . -iname "*.bak" -type f -print | xargs /bin/rm -f
Print all files on the system owned by group `name_of_group' </s> find / -group name_of_group
List all files/directories under current directory using comma (,) as the delimiter for different fields in the output </s> find . -ls | awk '{printf( "%s,%s,%s,%s,%s,%s,%s,%s %s %s,%s\n", $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11 )}'
Find all files throughout the entire file hierarchy with the optional constraints of опция_поиска, значение and/or опция_действия. </s> find / [опция_поиска] [значение] 	[опция_действия]
Create an empty file (or update timestamp of file) specified by variable "correctFilePathAndName" </s> touch "$correctFilePathAndName"
show a count of the number of filenames ending in .txt in the current directory, without descending into sub-directories </s> find . -maxdepth 1 -name \*.txt -print0 | grep -cz .
Search "input.txt" for regex patterns only matching those listed in "ignore.txt", list the unique lines and prefix with the number of occurrences </s> grep -of ignore.txt input.txt | sort | uniq -c
Find all files/directories named 'photo.jpg' (case insensitive) under current directory tree </s> find . -iname "photo.jpg"
Creates temporary folder relative to directory '/path/to/dir'. </s> mktemp -d -p /path/to/dir
Calculate md5 sum of file ${my_iso_file} and save it to variable 'md5' </s> md5=`md5sum ${my_iso_file} | cut -b-32`
Search /usr/bin for regular files that have been modified within the last 10 days </s> find /usr/bin -type f -mtime -10
Find all .php files in all directory trees matching pattern `/srv/www/*/htdocs/system/application/' and search those files for string "debug (" </s> find /srv/www/*/htdocs/system/application/ -name "*.php" -exec grep "debug (" {} \; -print
Report file system containing the current directory disk usage </s> df .
Search for the query "filename" in the current directory and any subdirectories </s> find -iname "filename"
search all the files in the current folder using regex </s> find . -regex ".*/my.*p.$"
Replace the occurrences of "HOGE" with "MOGA" once per each line of the files from the current directory tree </s> find . -type f -print0 | xargs -0 sed -i -e "s/HOGE/MOGA/"
Run 'top' in batch mode (don't accept user input) with delay of 1 second between updates, and duplicate the standard output to file 'output.log' in current directory. </s> top -b -d 1 | grep myprocess.exe | tee output.log
Rename all *.html files under and below the current directory to *.var </s> find -name '*.html' -print0 | xargs -0 rename 's/\.html$/.var/'
Print file information of the executable file of command "g++" </s> ls `which g++` -al
Change permissions to u=rw,g=r,o= for all files inside the current directory tree </s> find . -type f -exec chmod u=rw,g=r,o= '{}' \;
Find all files with the SUID bit set </s> find / -perm -u+s
Search for " 000" in the hex dump of "file-with-nulls" </s> od file-with-nulls | grep ' 000'
Find the largest files in a particular location </s> find /home/tecmint/Downloads/ -type f -exec du -Sh {} + | sort -rh | head -n 5
Print the contents of "~/.ssh/config" </s> cat ~/.ssh/config
remove all the core files from /usr folder which have not been accessed in the last 7*24 hours </s> find /usr -name core -atime +7 -exec rm "{}" \;
Prints number of days in a current month. </s> cal $(date +"%m %Y") | awk 'NF {DAYS = $NF}; END {print DAYS}'
find files in the current directory having name "filename" </s> find -iname "filename"
Find all files under /somefolder matching the pattern expanded by $FILE_PATTERN in thier names </s> find /somefolder -type f -name $FILE_PATTERN
display all the files in current folder </s> find .
Search for non-empty files </s> find . ! -size 0k
find all the cpp files in the current folder </s> find . -iname '*.cpp' -print
Find all files/directories named 'articles.jpg' under '/home/username/public_html/images' directory tree </s> find /home/username/public_html/images -name "articles.jpg"
Search the directory tree given as variable $dir for regular files </s> find $dir -type f
List all leaf directories of the current directory tree </s> find . -type d -links 2
Find all files named "filename" in the current directory tree, not descending into "FOLDER1" directories </s> find . '(' -name FOLDER1 -prune -o -name filename ')' -print
when using vi-insert keymap bind command "\C-v{}\ei" to key "{" </s> bind -m vi-insert '"{" "\C-v{}\ei"'
Print the largest 20 files under current directory </s> find . -type f -printf '%k %p\n' |sort -n |tail -n 20
Recursively change the owner and group of "subdir3" to "user3" </s> chown user3:user3 -R subdir3
Find all symbolic links under '/some/directory' tree </s> find /some/directory -type l -print
Print differences between files in directories folder1 and folder2 recursively, with unified context, ignoring changes in the amount of white space </s> diff -bur folder1/ folder2/
Find all Perl source code files </s> find . -name "*.pl"
Force create a symbolic link named "currentDir" to "newDir" without dereferencing "currentDir" </s> ln -sfn newDir currentDir
List each file or directory in the current directory prefixed with its filesize in bytes and sorted from smallest to largest </s> du -s * | sort -n
create directory dir </s> mkdir -p dir
Copy all files matching "*.sh" in "$from/*" to "root@$host:/home/tmp/" compressing data during transmission </s> rsync -zvr --include="*.sh" --exclude="*" $from/*  root@$host:/home/tmp/
Find all directories in /var/www/html/zip/data/*/*/*/*/* that are older than 90 days and print only unique paths </s> find /var/www/html/zip/data -type d -mtime +90 | uniq
List files in directory "one" that exist in directory "two" </s> sort <(ls one) <(ls two) | uniq -d
Find all regular files in the current directory tree and count them </s> find -type f -printf '.' | wc -c
Find x* files/directories under /tmp directory whose status was changed less than 1 day ago and move them to ~/play </s> find /tmp/ -ctime -1 -name "x*" | xargs -I '{}' mv '{}' ~/play/
Display the sizes and filepaths of all files/directories with '.undo' extension under current directory tree </s> find -name *.undo -print0 | du -hc --files0-from=-
Check if directory $some_dir is empty </s> find "`echo "$some_dir"`" -maxdepth 0 -empty
Make directories and parents as needed for each file path in "a.txt" excluding the basename for each path </s> cat a.txt | grep / | sed 's|/[^/]*$||' | sort -u | xargs -d $'\n' mkdir -p
Print first word of lines unique for 'file1' file </s> grep -o '^\S\+' <(comm file1 file2)
Gets domain name from dig reverse lookup. </s> dig -x 8.8.8.8 | grep PTR | cut -d ' ' -f 2 | grep google | cut -f 5
Compare *.csv files in the current directory tree with their analogs stored in /some/other/path/ prompting before running `diff' </s> find . -okdir diff {} /some/other/path/{} ";"
Archive directory "tata" to directory "tata2", compressing data during copy. </s> rsync -avz tata/ tata2/
count all the regular files that are present in a directory </s> find . -type f | wc -l
search for dbmsspool.sql file in the current folder </s> find . -print|grep ?i dbmspool.sql
Search the .VER files from the current directory tree for Perl regular expression "Model-Manufacturer:.\n." </s> find . -name "*.VER" -exec grep -P 'Model-Manufacturer:.\n.' '{}' ';' -print
Find files in the /var/log folder which were modified between 60 minutes and 10 minutes ago </s> find /var/log/ -mmin -60 -mmin +10
List absolute path of files in the current directory </s> ls -1 | xargs readlink -f
Replace "foo" with "bar" in all PHP files in the current directory tree </s> find . -name "*.php" -exec sed -i 's/foo/bar/g' {} \;
Locates Erlang distribution, and prints release number from 'RELEASES' file. </s> awk -F, 'NR==1 {gsub(/"/,"",$3);print $3}' "$(dirname $(readlink -f $(which erl)))/../releases/RELEASES"
Print the entire saved command history </s> history
Execute all commands in "commands-to-execute-remotely.sh" on server "blah_server" </s> cat commands-to-execute-remotely.sh | ssh blah_server
Copy all files with '.png' (case insensitive) extension under '/home/mine' directory tree to '/home/mine/pngcoppies/copy.' directory </s> find /home/mine -iname "*.png" -execdir cp {} /home/mine/pngcoppies/copy{} \;
Find the files in the current directory that match pattern '*.ISOLATE.*.txt' and move them to folder ./ISOLATE </s> find . -name '*.ISOLATE.*.txt' -maxdepth 1 -print0 | xargs -0 -IFILE mv FILE ./ISOLATE
Sort "$file" and output the result to "$file" </s> sort -o $file $file
Make directories "/tmp/A", "/tmp/B", "/tmp/C", and "/tmp/ dir with spaces" </s> mkdir /tmp/A /tmp/B /tmp/C "/tmp/ dir with spaces"
Remove trailing white spaces from all *.py files under dir directory (ignoring .git path) and keep backups of the originals </s> find dir -not -path '.git' -iname '*.py' -print0 | xargs -0 sed --in-place=.bak 's/[[:space:]]*$//'.
create directory /etc/cron.minute </s> mkdir /etc/cron.minute
Find all *.txt files/directories in entire file system </s> find / -name "*.txt"
Find all files in the current directory tree whose pathnames match pattern '*/1/lang/en.css' </s> find . -path ‘*/1/lang/en.css’ -print
search for the file "file" in the current folder excluding those in the sub directory ".git" </s> find . -path ./.git  -prune -o -name file  -print
find the MyCProgram.c (case insensitive find) under the current directory and run the md5sum command against it </s> find -iname "MyCProgram.c" -exec md5sum {} \;
Search the given $directory for files with permissions stored in $permissions </s> find "$directory" -perm "$permissions"
Convert all characters in "$a" to lower case and save to variable "b" </s> b=`echo "$a" | sed 's/./\L&/g'`
display all the regular/normal files in the current folder which have been modified in the last 24 hours </s> find . -mtime 0 -type f
display all files in the directory "dir" which have been changed in the last 60 minutes </s> find /dir -cmin -60
Force delete all the regular/normal files in the current folder and do not search in the sub folders   (print0 is used to handle files which have newlines in their names or files with the name only as spaces ) </s> find . -maxdepth 1 -type f -print0 | xargs rm -f
Find files that have been modified within the last month and copy them somewhere </s> find /etc/ -mtime -30 | xargs -0 cp /a/path
Create a symbolic link in directory "~/newlinks" for each file listed in "results2.txt" </s> cat results2.txt | xargs -I{} ln -s {} ~/newlinks
move all files in the current folder another folder and do not move the files in the sub folder </s> find . -name "*" -maxdepth 1 -exec mv -t /home/foo2/bulk2 {} +
Find out all files owned by user vivek </s> find / -user vivek
Recursively finds and compresses all files in a current folder with 4 parallel processes. </s> find . -type f -print0 | xargs -0 -n1 -P4 bzip2
For each line which has a common first field in test.1 and test.2, output the first 2 fields of test.2 and the field 2 and 3 of test.1 </s> join -j1 -o 2.1,2.2,1.2,1.3  <(sort test.1) <(sort test.2)
Compress and display the original filename of every file on the system that is greater than 100000 bytes and ends in ".log" </s> sudo find / -xdev -type f -size +100000 -name "*.log" -exec gzip {} \; -exec echo {} \;
View line 500 to line 500 + 501 in gzipped file "bigfile.z" </s> zcat bigfile.z | tail -n +500 | head -501
Enables shell option 'expand_aliases'. </s> shopt -s expand_aliases
Filter out current date in current time zone from the GMT+30 and GMT+20 representations of current date and show the last one </s> echo -e "$(TZ=GMT+30 date +%Y-%m-%d)\n$(TZ=GMT+20 date +%Y-%m-%d)" | grep -v $(date +%Y-%m-%d) | tail -1
Replace "foo" with "bar" in all PHP files in the current directory tree </s> find . -name "*.php" -print | xargs sed -i 's/foo/bar/g'
find all files in the file system which are modified after the file /tmp/checkpoint </s> find / -newer /tmp/checkpoint
Print paths to all subdirectories inside of a directory </s> du | awk '{print $2}'
Check if the directory tree whose name is given as variable $somedir contains no regular files </s> find "$somedir" -type f -exec echo Found unexpected file {} \;
Write output of "ls -hal /root/" to standard output and to "/root/test.out" </s> ls -hal /root/ | sudo tee /root/test.out
display all regular/normal files in the current folder that were accessed exactly 7*24 hours back </s> find . -type f -atime 7
Recursively finds all files in root folder and prints all strings with 'text-to-find-here' from that files, preceding matched string with filename. </s> find ~/ -type f -exec grep -H 'text-to-find-here' {} \;
See the word count of every *.txt file in the home directory </s> find ~/ -name '*.txt' -print0 | xargs -0 wc -w
Find all *.texi files in /usr/local/doc </s> find /usr/local/doc -name '*.texi'
Set permissions of command "node" to 755 </s> sudo chmod 755 $(which node)
display a list of all the files  in the home folder which have been modified today </s> find ~ -type f -mtime 0 -ls
Print the list of files and directories of the /etc directory </s> find /etc/. ! -name . -prune
Unzip every ".gz" file in the current directory </s> gunzip *.gz
Set prompt to the system host name and history number </s> PS1="`hostname`:\!>"
display all the directories in the current folder which start with processor followed by digit and ends with .1 or .2 </s> find . -type d -regextype posix-egrep -regex '\./processor[0-9]*/10\.(1|2)'
Print 10 space separated "x"s with at most 4 per line </s> yes x | head -10 | awk 'BEGIN { RS = "%%%%%%%" } { split($0,a,"\n"); for (i=1; i<length(a); i+=4) print a[i], a[i+1], a[i+2], a[i+3] }'
get the count of all the files that have been accessed in the last 30 days </s> find . -atime +30 -exec ls \; | wc -l
change the permissions of all the regular/normal files in the current folder </s> chmod 640 `find ./ -type f -print`
Find all files except files with '.gz' extension in the current directory non-recursively and compress them with gzip </s> find . -maxdepth 1 -type f ! -name '*.gz' -exec gzip "{}" \;
List all files/directories under current directory matching the posix-egrep type regex ".+\.(c|cpp|h)$" in their names excluding the files that contain 'generated' or 'deploy' in their paths </s> find . -regextype posix-egrep -regex '.+\.(c|cpp|h)$' -print0 | grep -vzZ generated | grep -vzZ deploy | xargs -0 ls -1Ld
find all files in /usr/bin and run the "file" command on them. </s> find /usr/bin | xargs file
Add the .abc suffix to the names of all *.txt regular files in the current directory tree </s> find . -type f -iname '*.txt' -print0 | xargs -0 mv {} {}.abc
Read a line of standard input with prompt "Enter the path to the file: " and suggestion "/usr/local/etc/" and save the response to variable "FILEPATH" </s> read -e -p "Enter the path to the file: " -i "/usr/local/etc/" FILEPATH
Compress regular files in the current directory tree that were last modified more than 7 days ago </s> find . -type f  -mtime +7 | tee compressedP.list | xargs compress
Search the .log files in the current directory tree for string "The SAS System" </s> find `pwd` -name "*.log" -exec grep "The SAS System" {} \;
Find all files under and below the current working directory with the word California in the file, and count the number of lines in the output </s> find . -type f -exec grep -n California {} \; -print | wc -l
delete all the broken symbolic links from the folder /usr/ports/packages </s> find -L /usr/ports/packages -type l -exec rm -- {} +
Find all .sh files in the current directory tree and remove them </s> find . -name "*.sh"| xargs rm -rf
find all the error, access, ssl_engine and rewrite logs which are bigger than 300MB and are less then 5GB in the folder /opt </s> find /opt \( -name error_log -o -name 'access_log' -o -name 'ssl_engine_log' -o -name 'rewrite_log' -o  -name 'catalina.out' \) -size +300000k -a -size -5000000k
Removes all empty folders under current folder. </s> find . -type d -empty -exec rmdir "{}" \;
Stores system load average number in the 'proc_load_average' variable. </s> proc_load_average=$(w | head -1 | cut -d" " -f13 | cut -d"," -f1-2 | tr ',' '.')
Count the number of regular files in the current directory tree </s> find . -type f | wc -l
Find all directories under current directory whose paths are 5 characters long </s> find . -regextype posix-extended -type d -regex ".{5}"
Find writable regular files omitting those that contain sites/default/files in their names </s> find . -type f -writable | grep -v sites/default/files
Sort the contents of file "ips.txt", eliminate duplicate entries, and prefix each entry with number of occurrences. </s> sort ips.txt | uniq -c
ERROR - Probably means -pgoDt (capital D) </s> sudo rsync -pgodt /home/ /newhome/
find all the symbolic links in the current folder and check the file type and display the output of those files which are broken </s> find ./ -type l -exec file {} \; |grep broken
Add group write permission to all files and directories in the current directory including hidden files and excluding ".." </s> chmod g+w .[^.]* ..?*
Recursively removes all files like '*.pyc' of '*.pyo' in a current folder without prompting. </s> find . -type f -name "*.py[c|o]" -exec rm -f {} +
Find files under /etc/apache-perl that are modified more recently than /etc/apache-perl/httpd.conf </s> find /etc/apache-perl -newer /etc/apache-perl/httpd.conf
Find regular files in the current directory that are writable by at least somebody </s> find -maxdepth 1 -type f -perm /222
Login in 'whatever.com' as user 'whoever' with X11 forwarding to enable GUI programs on remote to be run </s> ssh -X whoever@whatever.com
get all files in a current directory modified in the last 7 days </s> find . -mtime -7 -print0 | xargs -0 tar -rf /foo/archive.tar
Finds all the log* files recursively in /myDir that are more than 7 days older and compresses them. </s> find /myDir -name "log*" -ctime +7 -exec bzip2 -zv {} \;
find all the files in the home folder which have been modified in 1 year or more ( which are not modified in the last 1 year ). </s> find $HOME -mtime +365
Find *.c and *.sh files </s> find . -type f \( -name "*.c" -o -name "*.sh" \)
Search the /media/shared directory recursively for MP3 and OGG files </s> find /media/shared \( -iname "*.mp3" -o -iname "*.ogg" \)
Find '.git' directories in directory tree /home/madhu/release/workspace </s> find /home/madhu/release/workspace -type d -name '.git'
find all the files in the file system which have read permission to the user and display the ten files </s> find / -perm /u=r | head
delete all the files which start with "Tes" in the current folder </s> find . -type f -name "Tes*" -exec rm {} \;
change the owner of all the files in the current directory </s> find . -exec chown myuser:a-common-group-name {} +
create directory TestProject </s> mkdir TestProject
search for the file "foobar.txt" in the folder "/home/mywebsite" </s> find /home/mywebsite -type f -name "foobar.txt"
find the file "filename.txt" in the usr folder </s> find /usr -name filename.txt -print
start 2 sleep processes in the background </s> sleep 100 | sleep 200 &
Split a file "file.tar.gz" into pieces named as "file.tar.gz.part-NNN" with size 1024 MB where NNN is a numeric suffix </s> split -b 1024m "file.tar.gz" "file.tar.gz.part-"
Print only digits in variable "$name" </s> echo $name | tr -c -d 0-9
File 'mydatafile' has a number on each line, display the sum of these numbers. </s> awk '{s+=$1} END {print s}' mydatafile
display all the regular/normal files in the current folder excluding the files with the name mmm </s> find . -name mmm -prune -o -type f -print
Find all the files that are not named "MyCProgram.c" in the current directory only and without regards to case. </s> find -maxdepth 1 -not -iname "MyCProgram.c"
display all files in the folder bar only in the path /foo/bar/myfile (no output is generated) </s> find bar -path /foo/bar/myfile -print
Add execute permission to all files ending in ".sh" </s> chmod +x *.sh
Saves listing of a current folder in 'OUTPUT' variable. </s> OUTPUT="$(ls -1)"
remove all the files in the current folder which have not been changed in the last 30*24 hours </s> find ./ -ctime +30 -type f -exec rm -f {} \;
Copy all files matching "file_name.extension" to "/path/to/receiving/folder" preserving directory hierarchy </s> find . -name 'file_name.extension' -print | cpio -pavd /path/to/receiving/folder
Search the .sh files in the current directory tree for string "ksh" </s> find . -name "*.sh" | xargs grep "ksh"
Find all files owned by user `comp' </s> find / -user comp
find all the files in the home folder which have been modified in the last 24 hours </s> find $HOME -mtime -1
Remove all Thumbs.db files from the current directory tree </s> find . -name Thumbs.db -exec rm {} \;
Find all regular files under /home/www and replace every occurrences of 'subdomainA' with 'subdomainB' in those files (may produce 'agument too long' error) </s> sed -i '' -e 's/subdomainA/subdomainB/g' $(find /home/www/ -type f)
Save the full path of command "f" to variable "full_f" </s> full_f="$(which f)"
List all files under the current working directory tree </s> find $(pwd)/ -type f
Remove "\r" at the end of each line in "infile" and display the result as printable characters or backslash escapes </s> cat infile | sed 's/\r$//' | od -c
Print the names of all files in /some/directory and its subdirectories recursively whose MIME type is video </s> find /some/directory -type f -exec file -N -i -- {} + | sed -n 's!: video/[^:]*$!!p'
Save the canonical filename of the script in variable "me" </s> me=$(readlink --canonicalize --no-newline $0)
Verbosely compresses all files on fifth and sixth depth level keeping original files in place. </s> bzip2 -kv */*/*/*/*/*
Move "caniwrite" without clobbering into "/usr/local/bin" </s> mv -nv caniwrite /usr/local/bin
Find all the files which are changed in last 1 hour </s> find / -cmin -60
Find all the files which are changed in last 1 hour in entire file system and show a few lines of output from the beginning </s> find / -cmin -60 | head
Copies all files like "*foo*" under the current directory to the '/your/dest' directory. </s> find . -name "*foo*" | sed -e "s/'/\\\'/g" -e 's/"/\\"/g' -e 's/ /\\ /g' | xargs cp /your/dest
Uncompress "archive.tar.gz" and extract the archive to "/destination" </s> gzip -dc archive.tar.gz | tar -xf - -C /destination
List all files in the current directory tree that were modified 60 minutes ago </s> find -mmin 60
Make 3 directories named "~/Labs/lab4a/folder" followed by the number 1, 2, or 3 </s> mkdir ~/Labs/lab4a/folder{1..3}
Delete all hard links to the physical file with inode number 2655341 </s> find /home -xdev -inum 2655341 | xargs rm
Delete all files and directories </s> find -delete
Split a file "file.tar.gz" into pieces with size 1024 MB </s> split -b 1024m file.tar.gz
Go to directory pointed by last element of array "dirs" in bash version 4.2 </s> cd "${dirs[-1]}"
Generates temporary file in a '/dev/shm' folder and saves path to it in a 'tFile' variable. </s> tFile=$(mktemp --tmpdir=/dev/shm)
Search the current directory recursively for regular files last changed 2 days ago </s> find . type -f -ctime 2
Print '-ok is an action so an implicit -print is not applied' with confirmation from the user for each file or directory found by the name 'file' under current directory tree </s> find -name file -ok echo '-ok is an action so an implicit -print is not applied' \;
remove all core files in the file system </s> find / -name "*.core" | xargs rm
Remove the files or directories 'bin/node', 'bin/node-waf', 'include/node', 'lib/node', 'lib/pkgconfig/nodejs.pc' and 'share/man/man1/node.1' </s> rm -r bin/node bin/node-waf include/node lib/node lib/pkgconfig/nodejs.pc share/man/man1/node.1
Print the average time of 4 ping requests to "www.stackoverflow.com" </s> ping -c 4 www.stackoverflow.com | tail -1| awk '{print $4}' | cut -d '/' -f 2
Save the first 3 lines output by 'yes' to 'file', and log the rest through 'more' which simply waits for user interaction at each page. </s> yes | awk 'FNR<4 {print >>"file"; close("file")}  1' | more
Recursively copy all files matching "*.sh" in "$from" to "root@$host:/home/tmp/" compressing data during transmission </s> rsync -zvr --exclude="*" --include="*.sh" --include="*/" "$from" root@$host:/home/tmp/
change the extension of all the ".abc" files in the folder "/the/path" to ".edefg" and do not change in the sub directories. execdir ensures that the command after it is executed only in the folder where the file is found </s> find /the/path -type f -name '*.abc' -execdir rename 's/\.\/(.+)\.abc$/version1_$1.abc/' {} \;
Kill all processes which were executed in background by the current shell. </s> jobs -p | xargs kill -9
list all *.java files under the src directory </s> find src -name "*.java"
Search for "vid=123" in all compressed files found under "/my_home" matching "*log.20140226*" </s> zcat `find /my_home -name '*log.20140226*'`|grep 'vid=123'
Copies file 'index.html' to each top-level directory in the current directory. </s> find . -mindepth 1 -maxdepth 1 -type d| xargs -n 1 cp -i index.html
List each subdirectory name composing the current working directory </s> pwd | cut -b2- | tr '/' '\n'
Find all files/directories not with the name 'query_to_avoid' under current directory </s> find -not -name "query_to_avoid"
Gets a current job back to the foreground. </s> fg
Assign permissions 755 to directories in the current directory tree </s> find . -type d -print0 | xargs -0 chmod 755
find all the text files in the folder /home/calvin and do not search beyond 2 levels </s> find /home/calvin/ -maxdepth 2  -name “*.txt”
Find all directories in the current one recursively which have the write bit set for "other" </s> find . -type d -perm -o=w
Find all filename.* files/directories under /root/directory/to/search </s> find /root/directory/to/search -name 'filename.*'
Print content of 'file' file reverted characterwise </s> rev file
Create a symbolic link named "/lib/libc.so.0" to "/lib/libc.so.6" </s> ln -s /lib/libc.so.6 /lib/libc.so.0
List files/directories at least three levels down the directory tree </s> find / -mindepth 3  -name "*log"
change the ownership of all regular/normal files in the current directory(print0 is used to handle all the files which have spaces or new lines in their names) </s> find . -type f -print0 | xargs -0 chown username
extract "backup.tar.gz" with verbose output </s> tar -xzvf backup.tar.gz
Recursively set all permissions under "/directory" to 755 </s> chmod -R 755 /directory
display all the regular/normal files in current directory </s> find . -type f
Print the MD5 message digest of "/path/to/destination/file" </s> md5sum /path/to/destination/file
Print the names of all regular files in the current directory tree </s> find . -type f -exec echo {} \;
Lists all files in a current folder, separating names with comma. </s> ls | sed '$!s/$/,/' | tr -d '\n'
Find the top 5 big files </s> find . -type f -exec ls -s {} \; | sort -n -r | head -5
Execute commands from "$file" in the current shell. </s> source "$file"
List regular files in current directory with read, write and execute permission for all users and also show the permissions </s> find . -type f  -perm a=rwx -exec ls -l {} \;
Print the base name of the current working directory </s> basename `pwd`
Print the help message for tree </s> tree --help
Find all .java files starting from the current folder </s> find . -name "*.java"
Trim leading and trailing whitespace from variable 'var'. </s> var=`echo $var | awk '{gsub(/^ +| +$/,"")}1'`
Remove blank lines and replace " " with "/" in "struct.txt" as input to make directories with parents as needed </s> sed '/^$/d;s/ /\//g' struct.txt | xargs mkdir -p
Find files/directories in entire file system newer than myfile </s> find / -newer myfile
recall the second argument from a previous command by pressing alt-shift-y </s> bind '"\eY": "\e2\e."'
find all files in current folder which are less than 300MB </s> find . -size -300M
search for all the files in the folder /data/images which have been modified after /tmp/start and before /tmp/end </s> find /data/images -type f -newer /tmp/start -not -newer /tmp/end
Remove all files in and below the current directory whose names begin with "not" </s> find . -name not\* -print0 | xargs -0 rm
find all the text files in the current folder and do not  search in the sub directories </s> find -maxdepth 1 -iname "*.txt"
Find all *.csv files under /foo/bar and move them to some_dir </s> find /foot/bar/ -name '*.csv' -print0 | xargs -0 mv -t some_dir
find all the normal files in the home directory which have been accesed in the last 30 days with the size greater than or equal to 100k. </s> find $HOME -type f -atime +30 -size 100k
Find all HTML files starting with letter 'a' in the current directory and below </s> find . -name a\*.html
Print the minimum transmission time of 10 ping requests to "google.com" from cygwin </s> ping google.com -n 10 | awk '/Minimum =/ { sub(",","",$3); print $3 }'
Find all files/directories under current directory that were accessed 30 minutes ago </s> find -amin 30
Take first text field from file 'file.txt' as a domain name and get short A record for this one. </s> cut -d' ' -f1 file.txt | xargs dig +short
Find recursively all Python files in the current directory and search them for the word ‘import’ </s> find . -name '*.py' | xargs grep 'import'
Synchronize "/home/user1/" to "wobgalaxy02:/home/user1/" including hidden files </s> rsync -av /home/user1/ wobgalaxy02:/home/user1/
display the file name and the file type of all the files in the current directory </s> find . -printf "%y %p\n"
Remount "/mnt/mountpoint" as read only </s> mount /mnt/mountpoint -oremount,ro
Display a long listing of all files/directories that are bigger than 10MB under '/var/' directory tree </s> find /var/ -size +10M -ls
create a hard link as directory named "new_hard_link" to the directory "existing_dir" as root </s> sudo  ln  -d  existing_dir  new_hard_link
searching for all files with the extension mp3 </s> find / -name *.mp3
Display human-readable file type description of ascii.txt </s> file ascii.txt
Change directory to the output of command '~/marker.sh go "$@"' </s> cd $( ~/marker.sh go "$@" )
display a long listing of all regular files  in current folder which have been modified in the last 60 minutes </s> find . -mmin -60 -type f | xargs ls -l
Receive input and print it to terminal </s> cat
display a long listing of all the files in the current folder which have been modified in the last 24 hours </s> find . -mtime -1 -ls
Save the physical current working directory to variable "END_ABS" </s> END_ABS=`pwd -P`
Search everywhere for directories named `root' </s> find / -type d -name root
Search /usr/src for filenames not ending in "*,v" </s> find /usr/src ! \( -name '*,v' -o -name '.*,v' \) '{}' \; -print
Find files/directories named<filetype> under current directory which were accessed less than 5 days ago </s> find -name "<filetype>" -atime -5
Copies all files under the current directory like any-cased '*foobar*' to the '~/foo/bar' directory. </s> find . -iname "*foobar*" -exec cp "{}" ~/foo/bar \;
find  directory which case-insensitive name is too in currect directory </s> find . -iname foo -type d
all the files that end with .mp3 and end with .jpg </s> find . -name '*.mp3' -name '*.jpg' -print
Find all files/directories named 'file' without descending into directories with the same name under current directory tree </s> find -name file -prune
Lists all files in a '/home/dreftymac/' folder and subfolders without recursion. </s> ls /home/dreftymac/*
Print count of unique lines in all files like 'list_part*' </s> cat list_part* | sort --unique | wc -l
display all the ".mov" video files in the current folder in the format filename and folder path </s> find . -iname "*.mov" -printf "%p %f\n"
delete all the mp4 files in the folder /home which are bigger than 10MB </s> find /home -type f -name *.mp4 -size +10M -exec rm {} \;
Make directories to "/my/other/path/here" as needed </s> mkdir -p /my/other/path/here
Request that the master ssh connection "otherHosttunnel" exits </s> ssh -O exit otherHosttunnel
Find all files under directory tree /path/to/dir whose permissions are not 644 </s> find /path/to/dir ! -perm 0644
Creates temporary folder in a TMPDIR folder or /tmp folder if TMPDIR doesn`t defined, with folder name like current shell name and 10-letter suffix, and saves created path in 'mydir' variable. </s> mydir=$(mktemp -d "${TMPDIR:-/tmp/}$(basename $0).XXXXXXXXXXXX")
display list of all the hidden directories in the directory "/dir/to/search/" </s> find /dir/to/search -path '*/.*' -ls
Removes all listed folders with content in sudo mode. </s> sudo rm -rf /usr/local/bin/npm /usr/local/share/man/man1/node* /usr/local/lib/dtrace/node.d ~/.npm ~/.node-gyp /opt/local/bin/node opt/local/include/node /opt/local/lib/node_modules
Change the ownership to eva for all files/directories that belong to the user 'george' in the entire file system without traversing to other devices/partitions </s> find -x / -user george -print0 | xargs -0 chown eva
search for swap files (.swp files) in temp folder and remove them </s> find /tmp -name '*.swp' -exec rm {} \;
Find all php files in a directory </s> find . -type f -name "*.php"
Gets IP address of first listed active network interface in system. </s> ifconfig  | grep 'inet addr:' | grep -v '127.0.0.1' | awk -F: '{print $2}' | awk '{print $1}' | head -1
Print "RDBMS exit code : $RC  " to the console and append to "${LOG_FILE}" </s> echo " RDBMS exit code : $RC  "     | tee -a ${LOG_FILE}
Compress "archive.tar" </s> gzip archive.tar
Create a rsa key with comment specified by variable APP and passphrase specified y SSHKEYPASS. </s> ssh-keygen -t rsa -C "$APP" -N "$SSHKEYPASS" -f ~/.ssh/id_rsa
find all the video files which are bigger than 10 MB which have not been modified in the last 60 days but have been changed in the last 100 days in /tmp and /var/tmp folder home folders </s> find /tmp /var/tmp ~ -type f -size +10M -mtime +60 -ctime -100 -exec file -N -i -- {} + | sed -n 's!: video/[^:]*$!!p'
List all files that matches both the case insensitive patterns *$1* and *$2* under /home/musicuser/Music/ directory </s> find /home/musicuser/Music/ -type f  -iname "*$1*" -iname "*$2*" -exec echo {} \;
Look for any instance of "HIGHMEM" in the current kernel's compile-time config file. </s> grep “HIGHMEM” /boot/config-`uname -r`
Show the value of variable "list", discarding consecutive duplicates and adding number of occurrences at the beginning of each line. </s> echo "$list" | uniq -c
Copy file "exist" from directory "/file/that" to a new file named "file" in "/location/for/new" </s> cp /file/that/exists /location/for/new/file
search for a word in all the php files in the current folder and display the count of all matching lines. </s> find . -name \*.php -type f -exec grep -Hn '$test' {} \+ | wc -l
execute command "who" when key "\eW" is pressed </s> bind -x '"\eW":"who"'
Find all files/directories with '.log' extension that belong to the group 'adm' under '/var/log' directory tree </s> find /var/log -group adm -name "*.log"
find all files in the folder "myfiles" which are exactly 5 bytes </s> find /myfiles -size 5
Find all filenames ending with .c in the current directory tree </s> find -name "*.c"
Find all *.py (case insensitive) files/directories under dir directory ignoring .git path </s> find dir -not -path '.git' -iname '*.py'
Split "$1" into files of at most "$2" or default 10000 using a numeric suffix of length 6 </s> split -l ${2:-10000} -d -a 6 "$1"
Replace spaces with underscores in the names of all files and directories in the "/tmp" directory tree </s> find /tmp/ -depth -name "* *" -execdir rename 's/ /_/g' "{}" \;
Print full path of command "programname" </s> which programname
Set permissions for files in `foldername' to 777 </s> find foldername -exec chmod a+rwx {} ";"
Replace all occurrences of 'previousword' with 'newword' in all regular files with '.cpp' extension under '/home/www' directory tree and modify them in-place </s> find /home/www -type f -name '*.cpp'  -exec sed -i 's/previousword/newword/g' '{}' \;
Search the regular files of the current directory tree for string "foo" </s> find ./ -type f | xargs grep "foo"
Find all files/directories named 'date' under /usr </s> find /usr -name date
Recursively change ownership of "~/.npm" to the current user </s> sudo chown -R `whoami` ~/.npm
Removes first and last parts of path $path and saves the result in 'finalName' variable. </s> finalName=$(basename -- "$(dirname -- "$path")")
Print the list of files in the home directory tree whose names begin with "Foto" </s> find ~ -name 'Foto*'
Create a copy of the current working directory structure in the usr/project directory, </s> find . -type d -print|sed 's@^@/usr/project/@'|xargs mkdir
List all symlinks under current directory and search for targetfile.txt in this list </s> find . -type l | xargs -I % ls -l % | grep targetfile.txt
find all regular/normal files which have execute permission in current folder and copy them to another folder </s> cp `find -perm -111 -type f` /usr/local/bin
SSH into "localhost" with forced pseudo-terminal allocation, execute "$heredoc", and save the output to variable "REL_DIR" </s> REL_DIR="$(ssh -t localhost "$heredoc")"
change the owner of the files which belong to the group 1000 to username and modify only the symbolic link not the originally pointed file </s> find -gid 1000 -exec chown -h :username {} \;
display all file in the folder /dir/to/search except ".c" files </s> find /dir/to/search/ \! -name "*.c" print
Reformat date "Sat Aug 09 13:37:14 2014 +1100" according to format string "%a %b %d %H:%M:%S %Y %z" </s> date -j -f "%a %b %d %H:%M:%S %Y %z" "Sat Aug 09 13:37:14 2014 +1100"
Find all files on the system whose names are 'composer.json' </s> find / -name composer.json
find all the regular/normal files in the /path folder and delete them </s> find /path -type f -print0 | xargs -0 rm
add read,write permissions to all the files in the current folder which have the permission 600 </s> find . -perm 600 -print | xargs chmod 666
Find all files that contain the case insensitive regex 'stringtofind' in maximum 1 level down the / directory without descending into other partitions </s> find / -maxdepth 1 -xdev -type f  -exec grep -li stringtofind '{}' \;
search for files that are readable for everybody, have at least on write bit set but are not executable for anybody </s> find . -perm -a+r -perm /a+w ! -perm /a+x
Find all files/directories under current directory tree that belong to the user 'tom' </s> find ./ -user tom
Find all files/directories under current directory that were accessed more than 25 but less than 35 minutes ago </s> find -amin +25 -amin -35
Print "deb http://ppa.launchpad.net/webupd8team/java/ubuntu precise main" and append to file "/etc/apt/sources.list" </s> echo "deb http://ppa.launchpad.net/webupd8team/java/ubuntu precise main" | tee -a /etc/apt/sources.list
recursively change owner of the directory /usr/local to the current user </s> sudo chown -R `whoami` /usr/local
find all the files in the entire file system starting with the word top </s> find / -name 'top?????*'
Filter the cron list of user "user" through "my_wonderful_sed_script" and re-apply the resulting output. </s> crontab -u user -l | sed "$my_wonderful_sed_script" | crontab -u user -
Find all the files which are accessed 50 days back </s> find / -atime 50
search for all the files in the folder /home which have sticky bit set and have the permissions 553 </s> find /home -perm 1553
Rename all files in current directory whose name starts with 'F0000', trimming a zero from any sequence of four zeroes in the name. </s> rename s/0000/000/ F0000*
Print all logins formatted as "The user USER is on TTY" where USER is the user name and TTY is the login terminal </s> who | awk '{print "The user " $1 " is on " $2}'
List the names of all file.ext files/directories under present working directory </s> find `pwd` -name "file.ext" -printf "%f\n"
Find all files named "test2" in the current directory tree </s> find -name test2
Copy a whole directory tree skipping files residing on other files systems to destination_dir </s> find ./ -mount -depth -print | cpio -pdm /destination_dir
Lists all directories in a current folder. </s> ls -d */
Find files in the current directory tree whose names begin with "file" and whose size is 0, and remove them </s> find . -name 'file*' -size 0 -print0 | xargs -0 rm
Find the top 5 small files </s> find . -type f -exec ls -s {} \; | sort -n  | head -5
Numerically sort each line in file "out" and print the result to console </s> sort -n out
FInd files in current directory and grep text and html files - but not index.html and report things that contain the word 'elevator' in four or more lines </s> find . -type f -print0 | egrep -iazZ '(\.txt|\.html?)$' | grep -vazZ 'index.html' | xargs -n 1 -0 grep -c -Hi elevator | egrep -v ':[0123]$'
Find every vim undo file under current directory </s> find -type f -iname '*.un~'
find all files in the current directory and sub-directories that were accessed after modifying /etc/hosts </s> find -anewer /etc/hosts
Prints process tree for the current process with ASCII line drawing characters. </s> pstree -A -s $$
Split "$SOURCE_FILE" into files of at most 100 lines each </s> split -l 100 "$SOURCE_FILE"
finds all directories named CVS, and deletes them and their contents. </s> find . -type d -name CVS -exec rm -r {} \;
display all the file in the folder /home/david/ which start with the word "index" ( case insensitive search) </s> find /home/david -iname 'index*'
Lists '/tmp/hashmap.$1' file or folder '/tmp/hashmap.$1' content one file per line. </s> ls -1 /tmp/hashmap.$1
List files with C-style escape sequences for non-alphanumeric characters </s> ls -b
display long listing of all normal/regular files in the current directory which have been modified in the last 2 days. </s> find . -mtime -2 -type f -name "t*" -exec ls -l '{}' \;
Saves 'tmux' version in the 'tmux_version' variable. </s> tmux_version="$(tmux -V | cut -c 6-)"
Find all files in current directory that were modified less than 1 day ago excluding hidden files  and archive them and put the output into the variable file_changed </s> file_changed=$(find . -depth \( -wholename \./\.\* \) -prune -o -mtime -1 -print | cpio -oav)
Find all regular files under $dir directory tree that are bigger than $size MB in size and print them along with their sizes in decreasing order of size </s> find $dir -type f -size +"$size"M -printf '%s %p\n' | sort -rn
Unhide all hidden files in the current directory </s> find . -maxdepth 1 -type f -name '\.*' | sed -e 's,^\./\.,,' | sort | xargs -iname mv .name name
Rename "fghfilea" to "jklfilea" </s> mv fghfilea jklfilea
Find all the files recursively in directories or files taken from the glob pattern /tmp/test/* that have been modified today </s> find /tmp/test/* -mtime -0
Find files and directories modified in last 24 hours </s> find . -mtime 1
Find all or single file called FindCommandExamples.txt under / directory of owner root </s> find / -user root -name FindCommandExamples.txt
Find all files recursively starting from / that have been modified in the past 30 minutes and list them </s> find / -mmin -30 -ls
Set the 'xtrace' shell option </s> set -o xtrace
Find all files/directories named 'file_name' under current directory tree </s> find . -name file_name
Compress every file in the current directory tree with gzip and keep file extensions the same </s> find folder -type f -exec gzip -9 {} \; -exec mv {}.gz {} \;
Counts number of occurences of all ip addresses in 'ip_addresses' file, and prints all addresses with number of occurences in a descending order. </s> cat ip_addresses | sort | uniq -c | sort -nr | awk '{print $2 " " $1}'
Find files/directories under current directory without descending into it </s> find -prune
Enable history in a script </s> set -o history
Find all files in the home directory with open permissions </s> find ~ -perm 777
Find files/directories under current directory that matches 'projects/insanewebproject' in their paths </s> find -ipath 'projects/insanewebproject'
List the z* links in the /usr/bin directory and the file to which it points to </s> find /usr/bin  -type l  -name "z*" -exec ls  -l {} \;
Delete all files in the /myDir directory tree that were last modfied more than 7 days ago </s> find /myDir -mindepth 1 -mtime +7 -delete
Find all files/directories under current directory following symlinks if needed </s> find -L
Display file type information for all instances of "file" in the current PATH. </s> which file | xargs file
Make directories to "/tmp/boostinst" as needed and print a message for each created directory </s> mkdir -pv /tmp/boostinst
Find files changed in the last 1 day </s> find . -mtime -1 -type f
Removes first and last parts of path $path and saves the result in 'finalName' variable. </s> finalName=$(dirname ${path#*/})
Insert "|" every 30 characters in file "longline" </s> fold -w30 longline | tr '\n' '|' | sed 's/|$/\n/'
Prints all NS servers of domain google.com. </s> dig google.com ns | awk 'p{print $5}/^;; ANSWER SECTION:$/{p=1}/^$/{p=0}'
search for a shell script in the current folder and display the current folder path but search from the sub directories </s> find . -name onlyme.sh -execdir pwd \;
create directory certs </s> mkdir certs/
split file "your_file" into pieces per 9 lines </s> split -l9 your_file
Find files in the /home/user directory tree changed exactly 10 minutes ago </s> find /home/user/ -cmin 10 -print
Search the current directory tree for symbolic links named "link1" </s> find . -type l -name link1
Search in current directory downwards all files whose owner is aa1 and grop is grp . </s> find .  \( -user aa1 - group grp \) -print
Search the current directory tree for files larger than 10MB but smaller than 50MB </s> find . -size +10M -size -50M -print
find for xml files in current folder using regular expressions </s> find ./ -regex "cmn-.*[\x4e00-\x9fa5]*\.xml"
Create a symbolic link named "${DESTINATION}${file}" to "${TARGET}${file}" </s> ln -s  "${TARGET}${file}"  "${DESTINATION}${file}"
Output lines 16224 to 16482 of 'file', and stop reading 'file' after line 16482. </s> awk 'NR==16224, NR==16482-1; NR==16482 {print; exit}' file
Display the biggest file sizes only </s> find -type f -exec du -Sh {} + | sort -rh | head -n 5
Add executable permission to "java_ee_sdk-6u2-jdk-linux-x64.sh" </s> sudo chmod +x java_ee_sdk-6u2-jdk-linux-x64.sh
Prints dates of $m month in $y year, preceded by month number and slash like ' 10/1'. </s> cal $m $y | sed -e '1,2d' -e 's/^/ /' -e "s/ \([0-9]\)/ $m\/\1/g"
Replace all URLs in "MyHTMLFile.html" with "$pub_url" and create a backup with suffix ".bak" </s> sed -i.bak "s#https.*\.com#$pub_url#g" MyHTMLFile.html
Counts number of processors and saves in variable NUMCPU. </s> NUMCPU=$(grep $'^processor\t*:' /proc/cpuinfo |wc -l)
Find all files in the /home/ directory tree that were last accessed more than 7 days ago </s> find /home -atime +7
Prints full path to files in a current folder. </s> ls -d -1 $PWD/**
Removes all empty folders with modification time more that 10 minutes ago from $homeDirData folder. </s> find $homeDirData -type d -mmin +10 -print0 | xargs -0 rmdir
split file t.txt into pieces per 30000000 lines named as "t.NN" with numeric suffix </s> split --lines=30000000 --numeric-suffixes --suffix-length=2 t.txt t
Remove all files named "filename" from the current directory tree, ignoring directory "FOLDER1" </s> find . -name FOLDER1 -prune -o -name filename -delete
search for all regular files in the current directory which have the extension "c" or "asm" </s> find . -type f \( -iname "*.c" -or -iname "*.asm" \)
display a long listing of all images with the name "articles" in the current folder </s> find . -iname "Articles.jpg" -exec ls -l {} \;
Removes 'folderName', and removes all content within if 'folderName' is folder. </s> rm -rf folderName
Find all regular files in minimum 1 level down the $dir directory </s> find "$dir" -mindepth 1 -type f
Print IP addresses of the host name </s> hostname  -i
Create intermediate directories "b and "c" as required and directory "c" </s> mkdir -p a/b/c
Find all directories with 755 permission and change the permission to 700 </s> find . -type d -perm 755 -exec chmod 700 {} \;
find all symbolic links in the current folder </s> find -type l
Search directory foo for files containing "/tmp/foo/bar" in their full names </s> find foo -path /tmp/foo/bar -print
Find all regular files that start with stat </s> find . -type f –iname stat*
Copy all files in "/var/spool/mail" to "/home/username/mail" preserving the directory hierarchy and modification times </s> find /var/spool/mail -type f | cpio -pvdmB /home/username/mail
Recursively copy all files and directories matching "*ela*L1*TE*" in localhost's directory /tdggendska10/vig-preview-dmz-prod/docs/sbo/pdf/ to /var/www/html/sbo/2010/teacher/ela/level1 on localhost connecting as ssh user "dalvarado", in batch mode (no prompt for passwords) preserving file permissions and timestamps, and without displaying progress information. </s> scp -Bpqr /tdggendska10/vig-preview-dmz-prod/docs/sbo/pdf/*ela*L1*TE* dalvarado@localhost:/var/www/html/sbo/2010/teacher/ela/level1
Find files/directories that does not have write permssion for group and others </s> find /path ! -perm /022
Print '"HTTP/1.1 200 OK', two new lines and the current date </s> echo -e "HTTP/1.1 200 OK\n\n $(date)"
forcible create a symbolic link named "/etc/file.conf" to file "/etc/configuration/file.conf" </s> ln -fs /etc/configuration/file.conf /etc/file.conf
Wrap each line in "longline" to a maximum of 30 characters </s> fold -w30 longline
Recursively copy /path/foo on host "prod" to local directory "/home/user/Desktop", connecting as ssh username corresponding to local username. </s> scp -r prod:/path/foo /home/user/Desktop
Read one character from standard input into variable "REPLY" </s> read -n 1 -r
search for all the mp3 files in the folder /home/you which have been accessed 24 ago </s> find /home/you -iname “*.mp3” -atime 01 -type -f
Send SIGTERM (signal 15) signal to all process whose username is "username" and whose command is "your_command". </s> ps -o uid,pid,cmd|awk '{if($1=="username" && $3=="your_command") print $2}'|xargs kill -15
Find all regular files under current directory (excluding hidden directories) and replace every occurrences of 'subdomainA.example.com' with 'subdomainB.example.com' in those files </s> find . \( ! -regex '.*/\..*' \) -type f -print0 | xargs -0 sed -i 's/subdomainA.example.com/subdomainB.example.com/g'
Print numbered list of all top-level files in the current directory, with name containing 'android' </s> ls | grep "android" | cat -n
search for files in current folder using name patterns </s> find . -name "S1A*1S*SAFE"
Calculate md5 checksum of $KEY, take the 1st to 10th character, append them with the string '/tmp/command_cache.' and save the rsultant string to variable FILE </s> FILE="/tmp/command_cache.`echo -n "$KEY" | md5sum | cut -c -10`"
List files larger than 10MB under /var/log </s> find /var/log -size +10M -ls
list all running jobs </s> jobs
find all hidden files in the current folder which have been modified after profile file </s> find . -type f -name ".*" -newer .cshrc -print
Use "vagrant-ssh" as the config file and ssh into "default" host </s> ssh -F vagrant-ssh default
display the names without extensions of all the data files in current folder which have not been changed in the last 60 mins </s> find . -prune -name "*.dat"  -type f -cmin +60 |xargs -i basename {} \;
Find all files/directories with permission $permissions under $directory directory tree </s> find "$directory" -perm "$permissions"
find all the files in the current folder which are bigger than 9MB </s> find . -size +9M
Print a randomly sorted list of numbers from 1 to 10 to file "/tmp/lst" and outputs "-------" followed by the reverse list to the screen </s> seq 1 10 | sort -R | tee /tmp/lst |cat <(cat /tmp/lst) <(echo '-------') | tac
Look up for 'myip.opendns.com' in server 'resolver1.opendns.com' and save the terse output in 'IP' variable </s> IP=$(dig +short myip.opendns.com @resolver1.opendns.com)
prints a line 19 lines from the line containing PATTERN </s> tac | sed -n '/PATTERN/,+19{h;d};x;/^$/!{p;s/.*//};x' | tac
Find all directories under /path/to/dir and change their permission to 755 </s> find /path/to/dir -type d -exec chmod 755 {} +
Find all files whose names begin with 'Makefile' in the /usr/ports directory tree and count how many of them contain 'QMAKESPEC' </s> find /usr/ports/ -name Makefile\* -exec grep -l QMAKESPEC '{}' '+' | wc -l
display all the files in the current folder which have been modified in the last 2 days </s> find . -mtime -2
Delete files in the DIR directory tree whose names begin with "2015" and contain "album" or "picture" </s> find DIR \( -name 2015\* -a \( -name \*album\* -o -name \*picture\* \) \) -delete
Search file /etc/logs/Server.log for lines containing "Error" </s> find /etc/logs/Server.log -exec grep Error {} \; -print
Print login information of all users except the first two and replace all instances of " " with ", " </s> who | awk '{ if (NR!=1 && NR!=2) {print} }' | sed -e 's/ /, /g'
find all the files in the directory which is pointed by $1 variable ending with the name held in the variable $2 or having the extension of value saved in the argument $2. </s> find $1 \( -name "*$2" -o -name ".*$2" \) -print
list *.bmp and *.txt files under the /home/user/Desktop directory. </s> find /home/user/Desktop -name '*.bmp' -o -name '*.txt'
Print second field from semicolon-seprated line <line>. </s> echo "<line>" | cut -d ";" -f 2
Create directories "/tmp/x/y/z/" on remote host before copying "$source" to "user@remote:/tmp/x/y/z/" </s> rsync -a --rsync-path="mkdir -p /tmp/x/y/z/ && rsync" $source user@remote:/tmp/x/y/z/
Search for 'Text To Find' in all regular files under current directory tree and show the matched files and matched lines with line numbers </s> find ./ -type f -exec grep -Hn "Text To Find" {} \;
Print the file system disk space usage for "/dev/disk0s2" if exists </s> df | grep /dev/disk0s2
Find all files under current directory and count the output line number </s> find . -type f | wc -l
Find all empty directories recursively starting from the current one and delete them </s> find . -type d -empty -print0 | xargs -0 /bin/rmdir
Calculate md5 checksum of theDirname </s> cpio -i -e theDirname | md5sum
Print space separated numbers from 1 to 10 </s> seq 10 | xargs echo
Find all dir* files/directories under parent </s> find parent -name dir*
Prints top-ten of most used utilities from history. </s> history | awk '{print $2}' | awk 'BEGIN {FS="|"}{print $1}' | sort | uniq -c | sort -nr | head
Download "http://archive.ubuntu.com/ubuntu/pool/universe/s/splint/splint_3.1.2.dfsg1-2.diff.gz", unzip it, and view the output in "less" </s> curl -s 'http://archive.ubuntu.com/ubuntu/pool/universe/s/splint/splint_3.1.2.dfsg1-2.diff.gz' | gunzip -dc | less
Remove all core dump files from user's home directory </s> find ~/ -name 'core*' -exec rm {} \;
find all the files that have not been modified in the last 24 hours </s> find /tmp/test/* -mtime +1
Find disk usage of all files inside the directory </s> du -a
find all the text files in  the current folder and do not search in somedir, bin directories </s> find . -name somedir -prune , -name bin -prune -o -name "*.txt" -print
Enables shell option 'lastpipe'. </s> shopt -s lastpipe
Write current directory listing to standard output and to "files.txt" </s> ls |& tee files.txt
Change the owner of "/var/www/html/mysite/images/" to "nobody" </s> sudo chown nobody /var/www/html/mysite/images/
Remove all .mpg files in the /home/luser directory tree </s> find /home/luser -type f -name '*.mpg' -print0 | xargs -0 rm -f
Report file system containing path to the current working directory disk usage human-readable. </s> df -h .
display all the regular files in the folder "$(FOLDER)" which are modified in the last $(RETENTION)*24 hours and excluding hidden files </s> find ${FOLDER} -type f ! -name \".*\" -mtime -${RETENTION}
Sort and remove duplicate lines in the output of "finger" </s> finger | sort -u
Find all files that were last modified less than7 days ago under /home </s> find /home -mtime -7
Find all files owned by group `group2' </s> find / -group group2
Create a ssh key of RSA type, and prompt for a filename to store it, presenting the default for this type of key as $HOME/.ssh/id_rsa </s> ssh-keygen -t rsa
Find files/directories under current directory that matches './projects/insanewebproject' in their paths and show the first one </s> find -ipath './projects/insanewebproject'| head -n1
Find recursively all regular files in the current directory skipping hidden files and directories matching pattern '.?*' </s> find -name '.?*' -prune -o \( -type f -print0 \)
remove all the files in current folder which have the extension "DS_Store" </s> find . -name ".DS_Store" -exec rm {} \;
list txt files older than 5 days or html files of any age, null separated </s> find . \( -name '*.txt'  -mtime +5 -o -name '*.html' \) -print0
List all regular files in the current directory tree that were modified less than 60 minutes ago </s> find . -mmin -60 -type f -exec ls -l {} +
Search the regular files of the current directory tree for string "whatever" </s> find . -type f -exec grep -H whatever {} \;
Read a line from standard input into variable "REPLY" with prompt "Press [Enter] key to release lock..." </s> read -p "Press [Enter] key to release lock..."
Remount "rfs" filesystem "/dev/stl12" on "/system" with read and write permission </s> mount -o rw,remount -t rfs /dev/stl12 /system
